const int[10..10] TimeScaler = 10;
group Lock:
  group UI:
    automaton UEbbGate:
      uncontrollable u_open;
      uncontrollable u_close;
      uncontrollable u_stop;
      alg bool InitialOpen = false;
      location Open:
        initial InitialOpen;
        edge u_close goto Close;
        edge u_stop goto Stop;
      location Close:
        initial not InitialOpen;
        edge u_open goto Open;
        edge u_stop goto Stop;
      location Stop:
        edge u_close goto Close;
        edge u_open goto Open;
    end
    automaton UFloodGate:
      uncontrollable u_open;
      uncontrollable u_close;
      uncontrollable u_stop;
      alg bool InitialOpen = false;
      location Open:
        initial InitialOpen;
        edge u_close goto Close;
        edge u_stop goto Stop;
      location Close:
        initial not InitialOpen;
        edge u_open goto Open;
        edge u_stop goto Stop;
      location Stop:
        edge u_close goto Close;
        edge u_open goto Open;
    end
    automaton DEbbGate:
      uncontrollable u_open;
      uncontrollable u_close;
      uncontrollable u_stop;
      alg bool InitialOpen = false;
      location Open:
        initial InitialOpen;
        edge u_close goto Close;
        edge u_stop goto Stop;
      location Close:
        initial not InitialOpen;
        edge u_open goto Open;
        edge u_stop goto Stop;
      location Stop:
        edge u_close goto Close;
        edge u_open goto Open;
    end
    automaton DFloodGate:
      uncontrollable u_open;
      uncontrollable u_close;
      uncontrollable u_stop;
      alg bool InitialOpen = false;
      location Open:
        initial InitialOpen;
        edge u_close goto Close;
        edge u_stop goto Stop;
      location Close:
        initial not InitialOpen;
        edge u_open goto Open;
        edge u_stop goto Stop;
      location Stop:
        edge u_close goto Close;
        edge u_open goto Open;
    end
    automaton DStormFloodGate:
      uncontrollable u_open;
      uncontrollable u_close;
      uncontrollable u_stop;
      alg bool InitialOpen = false;
      location Open:
        initial InitialOpen;
        edge u_close goto Close;
        edge u_stop goto Stop;
      location Close:
        initial not InitialOpen;
        edge u_open goto Open;
        edge u_stop goto Stop;
      location Stop:
        edge u_close goto Close;
        edge u_open goto Open;
    end
    automaton UEbbPaddle:
      uncontrollable u_open;
      uncontrollable u_close;
      uncontrollable u_stop;
      alg bool InitialOpen = false;
      location Open:
        initial InitialOpen;
        edge u_close goto Close;
        edge u_stop goto Stop;
      location Close:
        initial not InitialOpen;
        edge u_open goto Open;
        edge u_stop goto Stop;
      location Stop:
        edge u_close goto Close;
        edge u_open goto Open;
    end
    automaton UFloodPaddle:
      uncontrollable u_open;
      uncontrollable u_close;
      uncontrollable u_stop;
      alg bool InitialOpen = false;
      location Open:
        initial InitialOpen;
        edge u_close goto Close;
        edge u_stop goto Stop;
      location Close:
        initial not InitialOpen;
        edge u_open goto Open;
        edge u_stop goto Stop;
      location Stop:
        edge u_close goto Close;
        edge u_open goto Open;
    end
    automaton DEbbPaddle:
      uncontrollable u_open;
      uncontrollable u_close;
      uncontrollable u_stop;
      alg bool InitialOpen = false;
      location Open:
        initial InitialOpen;
        edge u_close goto Close;
        edge u_stop goto Stop;
      location Close:
        initial not InitialOpen;
        edge u_open goto Open;
        edge u_stop goto Stop;
      location Stop:
        edge u_close goto Close;
        edge u_open goto Open;
    end
    automaton DFloodPaddle:
      uncontrollable u_open;
      uncontrollable u_close;
      uncontrollable u_stop;
      alg bool InitialOpen = false;
      location Open:
        initial InitialOpen;
        edge u_close goto Close;
        edge u_stop goto Stop;
      location Close:
        initial not InitialOpen;
        edge u_open goto Open;
        edge u_stop goto Stop;
      location Stop:
        edge u_close goto Close;
        edge u_open goto Open;
    end
    automaton DStormFloodPaddle:
      uncontrollable u_open;
      uncontrollable u_close;
      uncontrollable u_stop;
      alg bool InitialOpen = false;
      location Open:
        initial InitialOpen;
        edge u_close goto Close;
        edge u_stop goto Stop;
      location Close:
        initial not InitialOpen;
        edge u_open goto Open;
        edge u_stop goto Stop;
      location Stop:
        edge u_close goto Close;
        edge u_open goto Open;
    end
    automaton DLockTrafficLight:
      uncontrollable u_r;
      uncontrollable u_rr;
      uncontrollable u_rg;
      uncontrollable u_g;
      location RedRed:
        edge u_r goto Red;
      location Red:
        initial;
        edge u_rr goto RedRed;
        edge u_rg goto RedGreen;
      location RedGreen:
        edge u_r goto Red;
        edge u_g goto Green;
      location Green:
        edge u_r goto Red;
    end
    automaton ULockTrafficLight:
      uncontrollable u_r;
      uncontrollable u_rr;
      uncontrollable u_rg;
      uncontrollable u_g;
      location RedRed:
        edge u_r goto Red;
      location Red:
        initial;
        edge u_rr goto RedRed;
        edge u_rg goto RedGreen;
      location RedGreen:
        edge u_r goto Red;
        edge u_g goto Green;
      location Green:
        edge u_r goto Red;
    end
    automaton DBridgeTraffigLight:
      uncontrollable u_r;
      uncontrollable u_rg;
      uncontrollable u_g;
      location Red:
        initial;
        edge u_rg goto RedGreen;
      location RedGreen:
        edge u_g goto Green;
        edge u_r goto Red;
      location Green:
        edge u_r goto Red;
    end
  end
  automaton EmergencyStop:
    uncontrollable u_activate;
    uncontrollable u_reset;
    location Deactivated:
      initial;
      edge u_activate goto Activated;
    location Activated:
      edge u_reset goto Deactivated;
  end
  group LTL:
    group DE:
      alg bool Red1On = SensorR1.On;
      alg bool GreenOn = SensorG.On;
      alg bool Red2On = SensorR2.On;
      automaton Actuator:
        controllable c_r;
        controllable c_rr;
        controllable c_rg;
        controllable c_g;
        controllable c_emerg;
        location RedRed:
          edge c_r, c_emerg goto Red;
        location Red:
          initial;
          edge c_rr goto RedRed;
          edge c_rg goto RedGreen;
        location RedGreen:
          edge c_r, c_emerg goto Red;
          edge c_g goto Green;
        location Green:
          edge c_r, c_emerg goto Red;
      end
      automaton SensorR1:
        uncontrollable u_on;
        uncontrollable u_off;
        alg bool InitialLocationOn = true;
        location Off:
          initial not InitialLocationOn;
          edge u_on goto On;
        location On:
          initial InitialLocationOn;
          edge u_off goto Off;
      end
      automaton SensorG:
        uncontrollable u_on;
        uncontrollable u_off;
        alg bool InitialLocationOn = false;
        location Off:
          initial not InitialLocationOn;
          edge u_on goto On;
        location On:
          initial InitialLocationOn;
          edge u_off goto Off;
      end
      automaton SensorR2:
        uncontrollable u_on;
        uncontrollable u_off;
        alg bool InitialLocationOn = false;
        location Off:
          initial not InitialLocationOn;
          edge u_on goto On;
        location On:
          initial InitialLocationOn;
          edge u_off goto Off;
      end
      automaton DynamicsR1:
        alg bool On = not Actuator.Green;
        alg bool Off = Actuator.Green;
        location:
          initial;
          edge SensorR1.u_on when On;
          edge SensorR1.u_off when Off;
      end
      automaton DynamicsG:
        alg bool On = Actuator.Green or Actuator.RedGreen;
        alg bool Off = Actuator.Red or Actuator.RedRed;
        location:
          initial;
          edge SensorG.u_on when On;
          edge SensorG.u_off when Off;
      end
      automaton DynamicsR2:
        alg bool On = Actuator.RedRed;
        alg bool Off = not Actuator.RedRed;
        location:
          initial;
          edge SensorR2.u_on when On;
          edge SensorR2.u_off when Off;
      end
    end
    group DW:
      alg bool Red1On = SensorR1.On;
      alg bool GreenOn = SensorG.On;
      alg bool Red2On = SensorR2.On;
      automaton Actuator:
        controllable c_r;
        controllable c_rr;
        controllable c_rg;
        controllable c_g;
        controllable c_emerg;
        location RedRed:
          edge c_r, c_emerg goto Red;
        location Red:
          initial;
          edge c_rr goto RedRed;
          edge c_rg goto RedGreen;
        location RedGreen:
          edge c_r, c_emerg goto Red;
          edge c_g goto Green;
        location Green:
          edge c_r, c_emerg goto Red;
      end
      automaton SensorR1:
        uncontrollable u_on;
        uncontrollable u_off;
        alg bool InitialLocationOn = true;
        location Off:
          initial not InitialLocationOn;
          edge u_on goto On;
        location On:
          initial InitialLocationOn;
          edge u_off goto Off;
      end
      automaton SensorG:
        uncontrollable u_on;
        uncontrollable u_off;
        alg bool InitialLocationOn = false;
        location Off:
          initial not InitialLocationOn;
          edge u_on goto On;
        location On:
          initial InitialLocationOn;
          edge u_off goto Off;
      end
      automaton SensorR2:
        uncontrollable u_on;
        uncontrollable u_off;
        alg bool InitialLocationOn = false;
        location Off:
          initial not InitialLocationOn;
          edge u_on goto On;
        location On:
          initial InitialLocationOn;
          edge u_off goto Off;
      end
      automaton DynamicsR1:
        alg bool On = not Actuator.Green;
        alg bool Off = Actuator.Green;
        location:
          initial;
          edge SensorR1.u_on when On;
          edge SensorR1.u_off when Off;
      end
      automaton DynamicsG:
        alg bool On = Actuator.Green or Actuator.RedGreen;
        alg bool Off = Actuator.Red or Actuator.RedRed;
        location:
          initial;
          edge SensorG.u_on when On;
          edge SensorG.u_off when Off;
      end
      automaton DynamicsR2:
        alg bool On = Actuator.RedRed;
        alg bool Off = not Actuator.RedRed;
        location:
          initial;
          edge SensorR2.u_on when On;
          edge SensorR2.u_off when Off;
      end
    end
    group UE:
      alg bool Red1On = SensorR1.On;
      alg bool GreenOn = SensorG.On;
      alg bool Red2On = SensorR2.On;
      automaton Actuator:
        controllable c_r;
        controllable c_rr;
        controllable c_rg;
        controllable c_g;
        controllable c_emerg;
        location RedRed:
          edge c_r, c_emerg goto Red;
        location Red:
          initial;
          edge c_rr goto RedRed;
          edge c_rg goto RedGreen;
        location RedGreen:
          edge c_r, c_emerg goto Red;
          edge c_g goto Green;
        location Green:
          edge c_r, c_emerg goto Red;
      end
      automaton SensorR1:
        uncontrollable u_on;
        uncontrollable u_off;
        alg bool InitialLocationOn = true;
        location Off:
          initial not InitialLocationOn;
          edge u_on goto On;
        location On:
          initial InitialLocationOn;
          edge u_off goto Off;
      end
      automaton SensorG:
        uncontrollable u_on;
        uncontrollable u_off;
        alg bool InitialLocationOn = false;
        location Off:
          initial not InitialLocationOn;
          edge u_on goto On;
        location On:
          initial InitialLocationOn;
          edge u_off goto Off;
      end
      automaton SensorR2:
        uncontrollable u_on;
        uncontrollable u_off;
        alg bool InitialLocationOn = false;
        location Off:
          initial not InitialLocationOn;
          edge u_on goto On;
        location On:
          initial InitialLocationOn;
          edge u_off goto Off;
      end
      automaton DynamicsR1:
        alg bool On = not Actuator.Green;
        alg bool Off = Actuator.Green;
        location:
          initial;
          edge SensorR1.u_on when On;
          edge SensorR1.u_off when Off;
      end
      automaton DynamicsG:
        alg bool On = Actuator.Green or Actuator.RedGreen;
        alg bool Off = Actuator.Red or Actuator.RedRed;
        location:
          initial;
          edge SensorG.u_on when On;
          edge SensorG.u_off when Off;
      end
      automaton DynamicsR2:
        alg bool On = Actuator.RedRed;
        alg bool Off = not Actuator.RedRed;
        location:
          initial;
          edge SensorR2.u_on when On;
          edge SensorR2.u_off when Off;
      end
    end
    group UW:
      alg bool Red1On = SensorR1.On;
      alg bool GreenOn = SensorG.On;
      alg bool Red2On = SensorR2.On;
      automaton Actuator:
        controllable c_r;
        controllable c_rr;
        controllable c_rg;
        controllable c_g;
        controllable c_emerg;
        location RedRed:
          edge c_r, c_emerg goto Red;
        location Red:
          initial;
          edge c_rr goto RedRed;
          edge c_rg goto RedGreen;
        location RedGreen:
          edge c_r, c_emerg goto Red;
          edge c_g goto Green;
        location Green:
          edge c_r, c_emerg goto Red;
      end
      automaton SensorR1:
        uncontrollable u_on;
        uncontrollable u_off;
        alg bool InitialLocationOn = true;
        location Off:
          initial not InitialLocationOn;
          edge u_on goto On;
        location On:
          initial InitialLocationOn;
          edge u_off goto Off;
      end
      automaton SensorG:
        uncontrollable u_on;
        uncontrollable u_off;
        alg bool InitialLocationOn = false;
        location Off:
          initial not InitialLocationOn;
          edge u_on goto On;
        location On:
          initial InitialLocationOn;
          edge u_off goto Off;
      end
      automaton SensorR2:
        uncontrollable u_on;
        uncontrollable u_off;
        alg bool InitialLocationOn = false;
        location Off:
          initial not InitialLocationOn;
          edge u_on goto On;
        location On:
          initial InitialLocationOn;
          edge u_off goto Off;
      end
      automaton DynamicsR1:
        alg bool On = not Actuator.Green;
        alg bool Off = Actuator.Green;
        location:
          initial;
          edge SensorR1.u_on when On;
          edge SensorR1.u_off when Off;
      end
      automaton DynamicsG:
        alg bool On = Actuator.Green or Actuator.RedGreen;
        alg bool Off = Actuator.Red or Actuator.RedRed;
        location:
          initial;
          edge SensorG.u_on when On;
          edge SensorG.u_off when Off;
      end
      automaton DynamicsR2:
        alg bool On = Actuator.RedRed;
        alg bool Off = not Actuator.RedRed;
        location:
          initial;
          edge SensorR2.u_on when On;
          edge SensorR2.u_off when Off;
      end
    end
  end
  group BTL:
    group DE:
      alg bool RedOn = SensorR.On;
      alg bool GreenOn = SensorG.On;
      automaton Actuator:
        controllable c_r;
        controllable c_rg;
        controllable c_g;
        controllable c_emerg;
        location Red:
          initial;
          edge c_rg goto RedGreen;
        location RedGreen:
          edge c_r, c_emerg goto Red;
          edge c_g goto Green;
        location Green:
          edge c_r, c_emerg goto Red;
      end
      automaton SensorR:
        uncontrollable u_on;
        uncontrollable u_off;
        alg bool InitialLocationOn = true;
        location Off:
          initial not InitialLocationOn;
          edge u_on goto On;
        location On:
          initial InitialLocationOn;
          edge u_off goto Off;
      end
      automaton SensorG:
        uncontrollable u_on;
        uncontrollable u_off;
        alg bool InitialLocationOn = false;
        location Off:
          initial not InitialLocationOn;
          edge u_on goto On;
        location On:
          initial InitialLocationOn;
          edge u_off goto Off;
      end
      automaton DynamicsR:
        alg bool On = not Actuator.Green;
        alg bool Off = Actuator.Green;
        location:
          initial;
          edge SensorR.u_on when On;
          edge SensorR.u_off when Off;
      end
      automaton DynamicsG:
        alg bool On = not Actuator.Red;
        alg bool Off = Actuator.Red;
        location:
          initial;
          edge SensorG.u_on when On;
          edge SensorG.u_off when Off;
      end
    end
    group DW:
      alg bool RedOn = SensorR.On;
      alg bool GreenOn = SensorG.On;
      automaton Actuator:
        controllable c_r;
        controllable c_rg;
        controllable c_g;
        controllable c_emerg;
        location Red:
          initial;
          edge c_rg goto RedGreen;
        location RedGreen:
          edge c_r, c_emerg goto Red;
          edge c_g goto Green;
        location Green:
          edge c_r, c_emerg goto Red;
      end
      automaton SensorR:
        uncontrollable u_on;
        uncontrollable u_off;
        alg bool InitialLocationOn = true;
        location Off:
          initial not InitialLocationOn;
          edge u_on goto On;
        location On:
          initial InitialLocationOn;
          edge u_off goto Off;
      end
      automaton SensorG:
        uncontrollable u_on;
        uncontrollable u_off;
        alg bool InitialLocationOn = false;
        location Off:
          initial not InitialLocationOn;
          edge u_on goto On;
        location On:
          initial InitialLocationOn;
          edge u_off goto Off;
      end
      automaton DynamicsR:
        alg bool On = not Actuator.Green;
        alg bool Off = Actuator.Green;
        location:
          initial;
          edge SensorR.u_on when On;
          edge SensorR.u_off when Off;
      end
      automaton DynamicsG:
        alg bool On = not Actuator.Red;
        alg bool Off = Actuator.Red;
        location:
          initial;
          edge SensorG.u_on when On;
          edge SensorG.u_off when Off;
      end
    end
  end
  group UpstreamEbb:
    group EastGate:
      alg real a = Dynamics.a;
      alg bool Open = Sensor.Open;
      alg bool InitialLocationClosed = true;
      automaton Actuator:
        controllable c_open;
        controllable c_close;
        controllable c_emrgStop;
        controllable c_endStopClosing;
        controllable c_endStopOpening;
        location Rest:
          initial;
          edge c_open goto Opening;
          edge c_close goto Closing;
        location Opening:
          edge c_emrgStop, c_endStopOpening goto Rest;
        location Closing:
          edge c_emrgStop, c_endStopClosing goto Rest;
      end
      automaton Sensor:
        uncontrollable u_open_on;
        uncontrollable u_open_off;
        uncontrollable u_closed_on;
        uncontrollable u_closed_off;
        alg bool InitialLocationClosed = .Lock.UpstreamEbb.EastGate.InitialLocationClosed;
        location Closed:
          initial InitialLocationClosed;
          edge u_closed_off goto Intermediate;
        location Intermediate:
          edge u_closed_on goto Closed;
          edge u_open_on goto Open;
        location Open:
          initial not InitialLocationClosed;
          edge u_open_off goto Intermediate;
      end
      automaton Dynamics:
        const real a_open = 3.0;
        const real a_closed = 0.0;
        cont a = if InitialLocationClosed: a_closed else a_open end der if Actuator.Opening and a < a_open: +1.0 elif Actuator.Closing and a > a_closed: -1.0 else 0.0 end;
        alg bool InitialLocationClosed = .Lock.UpstreamEbb.EastGate.InitialLocationClosed;
        location:
          initial;
          edge Sensor.u_open_on when a >= a_open;
          edge Sensor.u_closed_off when a < a_open;
          edge Sensor.u_closed_on when a <= a_closed;
          edge Sensor.u_open_off when a > a_closed;
      end
    end
    group WestGate:
      alg real a = Dynamics.a;
      alg bool Open = Sensor.Open;
      alg bool InitialLocationClosed = true;
      automaton Actuator:
        controllable c_open;
        controllable c_close;
        controllable c_emrgStop;
        controllable c_endStopClosing;
        controllable c_endStopOpening;
        location Rest:
          initial;
          edge c_open goto Opening;
          edge c_close goto Closing;
        location Opening:
          edge c_emrgStop, c_endStopOpening goto Rest;
        location Closing:
          edge c_emrgStop, c_endStopClosing goto Rest;
      end
      automaton Sensor:
        uncontrollable u_open_on;
        uncontrollable u_open_off;
        uncontrollable u_closed_on;
        uncontrollable u_closed_off;
        alg bool InitialLocationClosed = .Lock.UpstreamEbb.WestGate.InitialLocationClosed;
        location Closed:
          initial InitialLocationClosed;
          edge u_closed_off goto Intermediate;
        location Intermediate:
          edge u_closed_on goto Closed;
          edge u_open_on goto Open;
        location Open:
          initial not InitialLocationClosed;
          edge u_open_off goto Intermediate;
      end
      automaton Dynamics:
        const real a_open = 3.0;
        const real a_closed = 0.0;
        cont a = if InitialLocationClosed: a_closed else a_open end der if Actuator.Opening and a < a_open: +1.0 elif Actuator.Closing and a > a_closed: -1.0 else 0.0 end;
        alg bool InitialLocationClosed = .Lock.UpstreamEbb.WestGate.InitialLocationClosed;
        location:
          initial;
          edge Sensor.u_open_on when a >= a_open;
          edge Sensor.u_closed_off when a < a_open;
          edge Sensor.u_closed_on when a <= a_closed;
          edge Sensor.u_open_off when a > a_closed;
      end
    end
    group EastPaddle:
      alg real a = Dynamics.a;
      alg bool Open = Sensor.Open;
      alg bool InitialLocationClosed = true;
      automaton Actuator:
        controllable c_open;
        controllable c_close;
        controllable c_emrgStop;
        controllable c_endStopClosing;
        controllable c_endStopOpening;
        location Rest:
          initial;
          edge c_open goto Opening;
          edge c_close goto Closing;
        location Opening:
          edge c_emrgStop, c_endStopOpening goto Rest;
        location Closing:
          edge c_emrgStop, c_endStopClosing goto Rest;
      end
      automaton Sensor:
        uncontrollable u_open_on;
        uncontrollable u_open_off;
        uncontrollable u_closed_on;
        uncontrollable u_closed_off;
        alg bool InitialLocationClosed = .Lock.UpstreamEbb.EastPaddle.InitialLocationClosed;
        location Closed:
          initial InitialLocationClosed;
          edge u_closed_off goto Intermediate;
        location Intermediate:
          edge u_closed_on goto Closed;
          edge u_open_on goto Open;
        location Open:
          initial not InitialLocationClosed;
          edge u_open_off goto Intermediate;
      end
      automaton Dynamics:
        const real a_open = 3.0;
        const real a_closed = 0.0;
        cont a = if InitialLocationClosed: a_closed else a_open end der if Actuator.Opening and a < a_open: +1.0 elif Actuator.Closing and a > a_closed: -1.0 else 0.0 end;
        alg bool InitialLocationClosed = .Lock.UpstreamEbb.EastPaddle.InitialLocationClosed;
        location:
          initial;
          edge Sensor.u_open_on when a >= a_open;
          edge Sensor.u_closed_off when a < a_open;
          edge Sensor.u_closed_on when a <= a_closed;
          edge Sensor.u_open_off when a > a_closed;
      end
    end
    group WestPaddle:
      alg real a = Dynamics.a;
      alg bool Open = Sensor.Open;
      alg bool InitialLocationClosed = true;
      automaton Actuator:
        controllable c_open;
        controllable c_close;
        controllable c_emrgStop;
        controllable c_endStopClosing;
        controllable c_endStopOpening;
        location Rest:
          initial;
          edge c_open goto Opening;
          edge c_close goto Closing;
        location Opening:
          edge c_emrgStop, c_endStopOpening goto Rest;
        location Closing:
          edge c_emrgStop, c_endStopClosing goto Rest;
      end
      automaton Sensor:
        uncontrollable u_open_on;
        uncontrollable u_open_off;
        uncontrollable u_closed_on;
        uncontrollable u_closed_off;
        alg bool InitialLocationClosed = .Lock.UpstreamEbb.WestPaddle.InitialLocationClosed;
        location Closed:
          initial InitialLocationClosed;
          edge u_closed_off goto Intermediate;
        location Intermediate:
          edge u_closed_on goto Closed;
          edge u_open_on goto Open;
        location Open:
          initial not InitialLocationClosed;
          edge u_open_off goto Intermediate;
      end
      automaton Dynamics:
        const real a_open = 3.0;
        const real a_closed = 0.0;
        cont a = if InitialLocationClosed: a_closed else a_open end der if Actuator.Opening and a < a_open: +1.0 elif Actuator.Closing and a > a_closed: -1.0 else 0.0 end;
        alg bool InitialLocationClosed = .Lock.UpstreamEbb.WestPaddle.InitialLocationClosed;
        location:
          initial;
          edge Sensor.u_open_on when a >= a_open;
          edge Sensor.u_closed_off when a < a_open;
          edge Sensor.u_closed_on when a <= a_closed;
          edge Sensor.u_open_off when a > a_closed;
      end
    end
  end
  group UpstreamFlood:
    group EastGate:
      alg real a = Dynamics.a;
      alg bool Open = Sensor.Open;
      alg bool InitialLocationClosed = true;
      automaton Actuator:
        controllable c_open;
        controllable c_close;
        controllable c_emrgStop;
        controllable c_endStopClosing;
        controllable c_endStopOpening;
        location Rest:
          initial;
          edge c_open goto Opening;
          edge c_close goto Closing;
        location Opening:
          edge c_emrgStop, c_endStopOpening goto Rest;
        location Closing:
          edge c_emrgStop, c_endStopClosing goto Rest;
      end
      automaton Sensor:
        uncontrollable u_open_on;
        uncontrollable u_open_off;
        uncontrollable u_closed_on;
        uncontrollable u_closed_off;
        alg bool InitialLocationClosed = .Lock.UpstreamFlood.EastGate.InitialLocationClosed;
        location Closed:
          initial InitialLocationClosed;
          edge u_closed_off goto Intermediate;
        location Intermediate:
          edge u_closed_on goto Closed;
          edge u_open_on goto Open;
        location Open:
          initial not InitialLocationClosed;
          edge u_open_off goto Intermediate;
      end
      automaton Dynamics:
        const real a_open = 3.0;
        const real a_closed = 0.0;
        cont a = if InitialLocationClosed: a_closed else a_open end der if Actuator.Opening and a < a_open: +1.0 elif Actuator.Closing and a > a_closed: -1.0 else 0.0 end;
        alg bool InitialLocationClosed = .Lock.UpstreamFlood.EastGate.InitialLocationClosed;
        location:
          initial;
          edge Sensor.u_open_on when a >= a_open;
          edge Sensor.u_closed_off when a < a_open;
          edge Sensor.u_closed_on when a <= a_closed;
          edge Sensor.u_open_off when a > a_closed;
      end
    end
    group WestGate:
      alg real a = Dynamics.a;
      alg bool Open = Sensor.Open;
      alg bool InitialLocationClosed = true;
      automaton Actuator:
        controllable c_open;
        controllable c_close;
        controllable c_emrgStop;
        controllable c_endStopClosing;
        controllable c_endStopOpening;
        location Rest:
          initial;
          edge c_open goto Opening;
          edge c_close goto Closing;
        location Opening:
          edge c_emrgStop, c_endStopOpening goto Rest;
        location Closing:
          edge c_emrgStop, c_endStopClosing goto Rest;
      end
      automaton Sensor:
        uncontrollable u_open_on;
        uncontrollable u_open_off;
        uncontrollable u_closed_on;
        uncontrollable u_closed_off;
        alg bool InitialLocationClosed = .Lock.UpstreamFlood.WestGate.InitialLocationClosed;
        location Closed:
          initial InitialLocationClosed;
          edge u_closed_off goto Intermediate;
        location Intermediate:
          edge u_closed_on goto Closed;
          edge u_open_on goto Open;
        location Open:
          initial not InitialLocationClosed;
          edge u_open_off goto Intermediate;
      end
      automaton Dynamics:
        const real a_open = 3.0;
        const real a_closed = 0.0;
        cont a = if InitialLocationClosed: a_closed else a_open end der if Actuator.Opening and a < a_open: +1.0 elif Actuator.Closing and a > a_closed: -1.0 else 0.0 end;
        alg bool InitialLocationClosed = .Lock.UpstreamFlood.WestGate.InitialLocationClosed;
        location:
          initial;
          edge Sensor.u_open_on when a >= a_open;
          edge Sensor.u_closed_off when a < a_open;
          edge Sensor.u_closed_on when a <= a_closed;
          edge Sensor.u_open_off when a > a_closed;
      end
    end
    group EastPaddle:
      alg real a = Dynamics.a;
      alg bool Open = Sensor.Open;
      alg bool InitialLocationClosed = true;
      automaton Actuator:
        controllable c_open;
        controllable c_close;
        controllable c_emrgStop;
        controllable c_endStopClosing;
        controllable c_endStopOpening;
        location Rest:
          initial;
          edge c_open goto Opening;
          edge c_close goto Closing;
        location Opening:
          edge c_emrgStop, c_endStopOpening goto Rest;
        location Closing:
          edge c_emrgStop, c_endStopClosing goto Rest;
      end
      automaton Sensor:
        uncontrollable u_open_on;
        uncontrollable u_open_off;
        uncontrollable u_closed_on;
        uncontrollable u_closed_off;
        alg bool InitialLocationClosed = .Lock.UpstreamFlood.EastPaddle.InitialLocationClosed;
        location Closed:
          initial InitialLocationClosed;
          edge u_closed_off goto Intermediate;
        location Intermediate:
          edge u_closed_on goto Closed;
          edge u_open_on goto Open;
        location Open:
          initial not InitialLocationClosed;
          edge u_open_off goto Intermediate;
      end
      automaton Dynamics:
        const real a_open = 3.0;
        const real a_closed = 0.0;
        cont a = if InitialLocationClosed: a_closed else a_open end der if Actuator.Opening and a < a_open: +1.0 elif Actuator.Closing and a > a_closed: -1.0 else 0.0 end;
        alg bool InitialLocationClosed = .Lock.UpstreamFlood.EastPaddle.InitialLocationClosed;
        location:
          initial;
          edge Sensor.u_open_on when a >= a_open;
          edge Sensor.u_closed_off when a < a_open;
          edge Sensor.u_closed_on when a <= a_closed;
          edge Sensor.u_open_off when a > a_closed;
      end
    end
    group WestPaddle:
      alg real a = Dynamics.a;
      alg bool Open = Sensor.Open;
      alg bool InitialLocationClosed = true;
      automaton Actuator:
        controllable c_open;
        controllable c_close;
        controllable c_emrgStop;
        controllable c_endStopClosing;
        controllable c_endStopOpening;
        location Rest:
          initial;
          edge c_open goto Opening;
          edge c_close goto Closing;
        location Opening:
          edge c_emrgStop, c_endStopOpening goto Rest;
        location Closing:
          edge c_emrgStop, c_endStopClosing goto Rest;
      end
      automaton Sensor:
        uncontrollable u_open_on;
        uncontrollable u_open_off;
        uncontrollable u_closed_on;
        uncontrollable u_closed_off;
        alg bool InitialLocationClosed = .Lock.UpstreamFlood.WestPaddle.InitialLocationClosed;
        location Closed:
          initial InitialLocationClosed;
          edge u_closed_off goto Intermediate;
        location Intermediate:
          edge u_closed_on goto Closed;
          edge u_open_on goto Open;
        location Open:
          initial not InitialLocationClosed;
          edge u_open_off goto Intermediate;
      end
      automaton Dynamics:
        const real a_open = 3.0;
        const real a_closed = 0.0;
        cont a = if InitialLocationClosed: a_closed else a_open end der if Actuator.Opening and a < a_open: +1.0 elif Actuator.Closing and a > a_closed: -1.0 else 0.0 end;
        alg bool InitialLocationClosed = .Lock.UpstreamFlood.WestPaddle.InitialLocationClosed;
        location:
          initial;
          edge Sensor.u_open_on when a >= a_open;
          edge Sensor.u_closed_off when a < a_open;
          edge Sensor.u_closed_on when a <= a_closed;
          edge Sensor.u_open_off when a > a_closed;
      end
    end
  end
  group DownstreamEbb:
    group EastGate:
      alg real a = Dynamics.a;
      alg bool Open = Sensor.Open;
      alg bool InitialLocationClosed = true;
      automaton Actuator:
        controllable c_open;
        controllable c_close;
        controllable c_emrgStop;
        controllable c_endStopClosing;
        controllable c_endStopOpening;
        location Rest:
          initial;
          edge c_open goto Opening;
          edge c_close goto Closing;
        location Opening:
          edge c_emrgStop, c_endStopOpening goto Rest;
        location Closing:
          edge c_emrgStop, c_endStopClosing goto Rest;
      end
      automaton Sensor:
        uncontrollable u_open_on;
        uncontrollable u_open_off;
        uncontrollable u_closed_on;
        uncontrollable u_closed_off;
        alg bool InitialLocationClosed = .Lock.DownstreamEbb.EastGate.InitialLocationClosed;
        location Closed:
          initial InitialLocationClosed;
          edge u_closed_off goto Intermediate;
        location Intermediate:
          edge u_closed_on goto Closed;
          edge u_open_on goto Open;
        location Open:
          initial not InitialLocationClosed;
          edge u_open_off goto Intermediate;
      end
      automaton Dynamics:
        const real a_open = 3.0;
        const real a_closed = 0.0;
        cont a = if InitialLocationClosed: a_closed else a_open end der if Actuator.Opening and a < a_open: +1.0 elif Actuator.Closing and a > a_closed: -1.0 else 0.0 end;
        alg bool InitialLocationClosed = .Lock.DownstreamEbb.EastGate.InitialLocationClosed;
        location:
          initial;
          edge Sensor.u_open_on when a >= a_open;
          edge Sensor.u_closed_off when a < a_open;
          edge Sensor.u_closed_on when a <= a_closed;
          edge Sensor.u_open_off when a > a_closed;
      end
    end
    group WestGate:
      alg real a = Dynamics.a;
      alg bool Open = Sensor.Open;
      alg bool InitialLocationClosed = true;
      automaton Actuator:
        controllable c_open;
        controllable c_close;
        controllable c_emrgStop;
        controllable c_endStopClosing;
        controllable c_endStopOpening;
        location Rest:
          initial;
          edge c_open goto Opening;
          edge c_close goto Closing;
        location Opening:
          edge c_emrgStop, c_endStopOpening goto Rest;
        location Closing:
          edge c_emrgStop, c_endStopClosing goto Rest;
      end
      automaton Sensor:
        uncontrollable u_open_on;
        uncontrollable u_open_off;
        uncontrollable u_closed_on;
        uncontrollable u_closed_off;
        alg bool InitialLocationClosed = .Lock.DownstreamEbb.WestGate.InitialLocationClosed;
        location Closed:
          initial InitialLocationClosed;
          edge u_closed_off goto Intermediate;
        location Intermediate:
          edge u_closed_on goto Closed;
          edge u_open_on goto Open;
        location Open:
          initial not InitialLocationClosed;
          edge u_open_off goto Intermediate;
      end
      automaton Dynamics:
        const real a_open = 3.0;
        const real a_closed = 0.0;
        cont a = if InitialLocationClosed: a_closed else a_open end der if Actuator.Opening and a < a_open: +1.0 elif Actuator.Closing and a > a_closed: -1.0 else 0.0 end;
        alg bool InitialLocationClosed = .Lock.DownstreamEbb.WestGate.InitialLocationClosed;
        location:
          initial;
          edge Sensor.u_open_on when a >= a_open;
          edge Sensor.u_closed_off when a < a_open;
          edge Sensor.u_closed_on when a <= a_closed;
          edge Sensor.u_open_off when a > a_closed;
      end
    end
    group EastPaddle:
      alg real a = Dynamics.a;
      alg bool Open = Sensor.Open;
      alg bool InitialLocationClosed = true;
      automaton Actuator:
        controllable c_open;
        controllable c_close;
        controllable c_emrgStop;
        controllable c_endStopClosing;
        controllable c_endStopOpening;
        location Rest:
          initial;
          edge c_open goto Opening;
          edge c_close goto Closing;
        location Opening:
          edge c_emrgStop, c_endStopOpening goto Rest;
        location Closing:
          edge c_emrgStop, c_endStopClosing goto Rest;
      end
      automaton Sensor:
        uncontrollable u_open_on;
        uncontrollable u_open_off;
        uncontrollable u_closed_on;
        uncontrollable u_closed_off;
        alg bool InitialLocationClosed = .Lock.DownstreamEbb.EastPaddle.InitialLocationClosed;
        location Closed:
          initial InitialLocationClosed;
          edge u_closed_off goto Intermediate;
        location Intermediate:
          edge u_closed_on goto Closed;
          edge u_open_on goto Open;
        location Open:
          initial not InitialLocationClosed;
          edge u_open_off goto Intermediate;
      end
      automaton Dynamics:
        const real a_open = 3.0;
        const real a_closed = 0.0;
        cont a = if InitialLocationClosed: a_closed else a_open end der if Actuator.Opening and a < a_open: +1.0 elif Actuator.Closing and a > a_closed: -1.0 else 0.0 end;
        alg bool InitialLocationClosed = .Lock.DownstreamEbb.EastPaddle.InitialLocationClosed;
        location:
          initial;
          edge Sensor.u_open_on when a >= a_open;
          edge Sensor.u_closed_off when a < a_open;
          edge Sensor.u_closed_on when a <= a_closed;
          edge Sensor.u_open_off when a > a_closed;
      end
    end
    group WestPaddle:
      alg real a = Dynamics.a;
      alg bool Open = Sensor.Open;
      alg bool InitialLocationClosed = true;
      automaton Actuator:
        controllable c_open;
        controllable c_close;
        controllable c_emrgStop;
        controllable c_endStopClosing;
        controllable c_endStopOpening;
        location Rest:
          initial;
          edge c_open goto Opening;
          edge c_close goto Closing;
        location Opening:
          edge c_emrgStop, c_endStopOpening goto Rest;
        location Closing:
          edge c_emrgStop, c_endStopClosing goto Rest;
      end
      automaton Sensor:
        uncontrollable u_open_on;
        uncontrollable u_open_off;
        uncontrollable u_closed_on;
        uncontrollable u_closed_off;
        alg bool InitialLocationClosed = .Lock.DownstreamEbb.WestPaddle.InitialLocationClosed;
        location Closed:
          initial InitialLocationClosed;
          edge u_closed_off goto Intermediate;
        location Intermediate:
          edge u_closed_on goto Closed;
          edge u_open_on goto Open;
        location Open:
          initial not InitialLocationClosed;
          edge u_open_off goto Intermediate;
      end
      automaton Dynamics:
        const real a_open = 3.0;
        const real a_closed = 0.0;
        cont a = if InitialLocationClosed: a_closed else a_open end der if Actuator.Opening and a < a_open: +1.0 elif Actuator.Closing and a > a_closed: -1.0 else 0.0 end;
        alg bool InitialLocationClosed = .Lock.DownstreamEbb.WestPaddle.InitialLocationClosed;
        location:
          initial;
          edge Sensor.u_open_on when a >= a_open;
          edge Sensor.u_closed_off when a < a_open;
          edge Sensor.u_closed_on when a <= a_closed;
          edge Sensor.u_open_off when a > a_closed;
      end
    end
  end
  group DownstreamFlood:
    group EastGate:
      alg real a = Dynamics.a;
      alg bool Open = Sensor.Open;
      alg bool InitialLocationClosed = true;
      automaton Actuator:
        controllable c_open;
        controllable c_close;
        controllable c_emrgStop;
        controllable c_endStopClosing;
        controllable c_endStopOpening;
        location Rest:
          initial;
          edge c_open goto Opening;
          edge c_close goto Closing;
        location Opening:
          edge c_emrgStop, c_endStopOpening goto Rest;
        location Closing:
          edge c_emrgStop, c_endStopClosing goto Rest;
      end
      automaton Sensor:
        uncontrollable u_open_on;
        uncontrollable u_open_off;
        uncontrollable u_closed_on;
        uncontrollable u_closed_off;
        alg bool InitialLocationClosed = .Lock.DownstreamFlood.EastGate.InitialLocationClosed;
        location Closed:
          initial InitialLocationClosed;
          edge u_closed_off goto Intermediate;
        location Intermediate:
          edge u_closed_on goto Closed;
          edge u_open_on goto Open;
        location Open:
          initial not InitialLocationClosed;
          edge u_open_off goto Intermediate;
      end
      automaton Dynamics:
        const real a_open = 3.0;
        const real a_closed = 0.0;
        cont a = if InitialLocationClosed: a_closed else a_open end der if Actuator.Opening and a < a_open: +1.0 elif Actuator.Closing and a > a_closed: -1.0 else 0.0 end;
        alg bool InitialLocationClosed = .Lock.DownstreamFlood.EastGate.InitialLocationClosed;
        location:
          initial;
          edge Sensor.u_open_on when a >= a_open;
          edge Sensor.u_closed_off when a < a_open;
          edge Sensor.u_closed_on when a <= a_closed;
          edge Sensor.u_open_off when a > a_closed;
      end
    end
    group WestGate:
      alg real a = Dynamics.a;
      alg bool Open = Sensor.Open;
      alg bool InitialLocationClosed = true;
      automaton Actuator:
        controllable c_open;
        controllable c_close;
        controllable c_emrgStop;
        controllable c_endStopClosing;
        controllable c_endStopOpening;
        location Rest:
          initial;
          edge c_open goto Opening;
          edge c_close goto Closing;
        location Opening:
          edge c_emrgStop, c_endStopOpening goto Rest;
        location Closing:
          edge c_emrgStop, c_endStopClosing goto Rest;
      end
      automaton Sensor:
        uncontrollable u_open_on;
        uncontrollable u_open_off;
        uncontrollable u_closed_on;
        uncontrollable u_closed_off;
        alg bool InitialLocationClosed = .Lock.DownstreamFlood.WestGate.InitialLocationClosed;
        location Closed:
          initial InitialLocationClosed;
          edge u_closed_off goto Intermediate;
        location Intermediate:
          edge u_closed_on goto Closed;
          edge u_open_on goto Open;
        location Open:
          initial not InitialLocationClosed;
          edge u_open_off goto Intermediate;
      end
      automaton Dynamics:
        const real a_open = 3.0;
        const real a_closed = 0.0;
        cont a = if InitialLocationClosed: a_closed else a_open end der if Actuator.Opening and a < a_open: +1.0 elif Actuator.Closing and a > a_closed: -1.0 else 0.0 end;
        alg bool InitialLocationClosed = .Lock.DownstreamFlood.WestGate.InitialLocationClosed;
        location:
          initial;
          edge Sensor.u_open_on when a >= a_open;
          edge Sensor.u_closed_off when a < a_open;
          edge Sensor.u_closed_on when a <= a_closed;
          edge Sensor.u_open_off when a > a_closed;
      end
    end
    group EastPaddle:
      alg real a = Dynamics.a;
      alg bool Open = Sensor.Open;
      alg bool InitialLocationClosed = true;
      automaton Actuator:
        controllable c_open;
        controllable c_close;
        controllable c_emrgStop;
        controllable c_endStopClosing;
        controllable c_endStopOpening;
        location Rest:
          initial;
          edge c_open goto Opening;
          edge c_close goto Closing;
        location Opening:
          edge c_emrgStop, c_endStopOpening goto Rest;
        location Closing:
          edge c_emrgStop, c_endStopClosing goto Rest;
      end
      automaton Sensor:
        uncontrollable u_open_on;
        uncontrollable u_open_off;
        uncontrollable u_closed_on;
        uncontrollable u_closed_off;
        alg bool InitialLocationClosed = .Lock.DownstreamFlood.EastPaddle.InitialLocationClosed;
        location Closed:
          initial InitialLocationClosed;
          edge u_closed_off goto Intermediate;
        location Intermediate:
          edge u_closed_on goto Closed;
          edge u_open_on goto Open;
        location Open:
          initial not InitialLocationClosed;
          edge u_open_off goto Intermediate;
      end
      automaton Dynamics:
        const real a_open = 3.0;
        const real a_closed = 0.0;
        cont a = if InitialLocationClosed: a_closed else a_open end der if Actuator.Opening and a < a_open: +1.0 elif Actuator.Closing and a > a_closed: -1.0 else 0.0 end;
        alg bool InitialLocationClosed = .Lock.DownstreamFlood.EastPaddle.InitialLocationClosed;
        location:
          initial;
          edge Sensor.u_open_on when a >= a_open;
          edge Sensor.u_closed_off when a < a_open;
          edge Sensor.u_closed_on when a <= a_closed;
          edge Sensor.u_open_off when a > a_closed;
      end
    end
    group WestPaddle:
      alg real a = Dynamics.a;
      alg bool Open = Sensor.Open;
      alg bool InitialLocationClosed = true;
      automaton Actuator:
        controllable c_open;
        controllable c_close;
        controllable c_emrgStop;
        controllable c_endStopClosing;
        controllable c_endStopOpening;
        location Rest:
          initial;
          edge c_open goto Opening;
          edge c_close goto Closing;
        location Opening:
          edge c_emrgStop, c_endStopOpening goto Rest;
        location Closing:
          edge c_emrgStop, c_endStopClosing goto Rest;
      end
      automaton Sensor:
        uncontrollable u_open_on;
        uncontrollable u_open_off;
        uncontrollable u_closed_on;
        uncontrollable u_closed_off;
        alg bool InitialLocationClosed = .Lock.DownstreamFlood.WestPaddle.InitialLocationClosed;
        location Closed:
          initial InitialLocationClosed;
          edge u_closed_off goto Intermediate;
        location Intermediate:
          edge u_closed_on goto Closed;
          edge u_open_on goto Open;
        location Open:
          initial not InitialLocationClosed;
          edge u_open_off goto Intermediate;
      end
      automaton Dynamics:
        const real a_open = 3.0;
        const real a_closed = 0.0;
        cont a = if InitialLocationClosed: a_closed else a_open end der if Actuator.Opening and a < a_open: +1.0 elif Actuator.Closing and a > a_closed: -1.0 else 0.0 end;
        alg bool InitialLocationClosed = .Lock.DownstreamFlood.WestPaddle.InitialLocationClosed;
        location:
          initial;
          edge Sensor.u_open_on when a >= a_open;
          edge Sensor.u_closed_off when a < a_open;
          edge Sensor.u_closed_on when a <= a_closed;
          edge Sensor.u_open_off when a > a_closed;
      end
    end
  end
  group DownstreamStormFlood:
    group EastGate:
      alg real a = Dynamics.a;
      alg bool Open = Sensor.Open;
      alg bool InitialLocationClosed = true;
      automaton Actuator:
        controllable c_open;
        controllable c_close;
        controllable c_emrgStop;
        controllable c_endStopClosing;
        controllable c_endStopOpening;
        location Rest:
          initial;
          edge c_open goto Opening;
          edge c_close goto Closing;
        location Opening:
          edge c_emrgStop, c_endStopOpening goto Rest;
        location Closing:
          edge c_emrgStop, c_endStopClosing goto Rest;
      end
      automaton Sensor:
        uncontrollable u_open_on;
        uncontrollable u_open_off;
        uncontrollable u_closed_on;
        uncontrollable u_closed_off;
        alg bool InitialLocationClosed = .Lock.DownstreamStormFlood.EastGate.InitialLocationClosed;
        location Closed:
          initial InitialLocationClosed;
          edge u_closed_off goto Intermediate;
        location Intermediate:
          edge u_closed_on goto Closed;
          edge u_open_on goto Open;
        location Open:
          initial not InitialLocationClosed;
          edge u_open_off goto Intermediate;
      end
      automaton Dynamics:
        const real a_open = 3.0;
        const real a_closed = 0.0;
        cont a = if InitialLocationClosed: a_closed else a_open end der if Actuator.Opening and a < a_open: +1.0 elif Actuator.Closing and a > a_closed: -1.0 else 0.0 end;
        alg bool InitialLocationClosed = .Lock.DownstreamStormFlood.EastGate.InitialLocationClosed;
        location:
          initial;
          edge Sensor.u_open_on when a >= a_open;
          edge Sensor.u_closed_off when a < a_open;
          edge Sensor.u_closed_on when a <= a_closed;
          edge Sensor.u_open_off when a > a_closed;
      end
    end
    group WestGate:
      alg real a = Dynamics.a;
      alg bool Open = Sensor.Open;
      alg bool InitialLocationClosed = true;
      automaton Actuator:
        controllable c_open;
        controllable c_close;
        controllable c_emrgStop;
        controllable c_endStopClosing;
        controllable c_endStopOpening;
        location Rest:
          initial;
          edge c_open goto Opening;
          edge c_close goto Closing;
        location Opening:
          edge c_emrgStop, c_endStopOpening goto Rest;
        location Closing:
          edge c_emrgStop, c_endStopClosing goto Rest;
      end
      automaton Sensor:
        uncontrollable u_open_on;
        uncontrollable u_open_off;
        uncontrollable u_closed_on;
        uncontrollable u_closed_off;
        alg bool InitialLocationClosed = .Lock.DownstreamStormFlood.WestGate.InitialLocationClosed;
        location Closed:
          initial InitialLocationClosed;
          edge u_closed_off goto Intermediate;
        location Intermediate:
          edge u_closed_on goto Closed;
          edge u_open_on goto Open;
        location Open:
          initial not InitialLocationClosed;
          edge u_open_off goto Intermediate;
      end
      automaton Dynamics:
        const real a_open = 3.0;
        const real a_closed = 0.0;
        cont a = if InitialLocationClosed: a_closed else a_open end der if Actuator.Opening and a < a_open: +1.0 elif Actuator.Closing and a > a_closed: -1.0 else 0.0 end;
        alg bool InitialLocationClosed = .Lock.DownstreamStormFlood.WestGate.InitialLocationClosed;
        location:
          initial;
          edge Sensor.u_open_on when a >= a_open;
          edge Sensor.u_closed_off when a < a_open;
          edge Sensor.u_closed_on when a <= a_closed;
          edge Sensor.u_open_off when a > a_closed;
      end
    end
    group EastPaddle:
      alg real a = Dynamics.a;
      alg bool Open = Sensor.Open;
      alg bool InitialLocationClosed = true;
      automaton Actuator:
        controllable c_open;
        controllable c_close;
        controllable c_emrgStop;
        controllable c_endStopClosing;
        controllable c_endStopOpening;
        location Rest:
          initial;
          edge c_open goto Opening;
          edge c_close goto Closing;
        location Opening:
          edge c_emrgStop, c_endStopOpening goto Rest;
        location Closing:
          edge c_emrgStop, c_endStopClosing goto Rest;
      end
      automaton Sensor:
        uncontrollable u_open_on;
        uncontrollable u_open_off;
        uncontrollable u_closed_on;
        uncontrollable u_closed_off;
        alg bool InitialLocationClosed = .Lock.DownstreamStormFlood.EastPaddle.InitialLocationClosed;
        location Closed:
          initial InitialLocationClosed;
          edge u_closed_off goto Intermediate;
        location Intermediate:
          edge u_closed_on goto Closed;
          edge u_open_on goto Open;
        location Open:
          initial not InitialLocationClosed;
          edge u_open_off goto Intermediate;
      end
      automaton Dynamics:
        const real a_open = 3.0;
        const real a_closed = 0.0;
        cont a = if InitialLocationClosed: a_closed else a_open end der if Actuator.Opening and a < a_open: +1.0 elif Actuator.Closing and a > a_closed: -1.0 else 0.0 end;
        alg bool InitialLocationClosed = .Lock.DownstreamStormFlood.EastPaddle.InitialLocationClosed;
        location:
          initial;
          edge Sensor.u_open_on when a >= a_open;
          edge Sensor.u_closed_off when a < a_open;
          edge Sensor.u_closed_on when a <= a_closed;
          edge Sensor.u_open_off when a > a_closed;
      end
    end
    group WestPaddle:
      alg real a = Dynamics.a;
      alg bool Open = Sensor.Open;
      alg bool InitialLocationClosed = true;
      automaton Actuator:
        controllable c_open;
        controllable c_close;
        controllable c_emrgStop;
        controllable c_endStopClosing;
        controllable c_endStopOpening;
        location Rest:
          initial;
          edge c_open goto Opening;
          edge c_close goto Closing;
        location Opening:
          edge c_emrgStop, c_endStopOpening goto Rest;
        location Closing:
          edge c_emrgStop, c_endStopClosing goto Rest;
      end
      automaton Sensor:
        uncontrollable u_open_on;
        uncontrollable u_open_off;
        uncontrollable u_closed_on;
        uncontrollable u_closed_off;
        alg bool InitialLocationClosed = .Lock.DownstreamStormFlood.WestPaddle.InitialLocationClosed;
        location Closed:
          initial InitialLocationClosed;
          edge u_closed_off goto Intermediate;
        location Intermediate:
          edge u_closed_on goto Closed;
          edge u_open_on goto Open;
        location Open:
          initial not InitialLocationClosed;
          edge u_open_off goto Intermediate;
      end
      automaton Dynamics:
        const real a_open = 3.0;
        const real a_closed = 0.0;
        cont a = if InitialLocationClosed: a_closed else a_open end der if Actuator.Opening and a < a_open: +1.0 elif Actuator.Closing and a > a_closed: -1.0 else 0.0 end;
        alg bool InitialLocationClosed = .Lock.DownstreamStormFlood.WestPaddle.InitialLocationClosed;
        location:
          initial;
          edge Sensor.u_open_on when a >= a_open;
          edge Sensor.u_closed_off when a < a_open;
          edge Sensor.u_closed_on when a <= a_closed;
          edge Sensor.u_open_off when a > a_closed;
      end
    end
  end
  automaton EqualWaterUpstream:
    uncontrollable u_on;
    uncontrollable u_off;
    alg bool InitialLocationOn = false;
    location Off:
      initial not InitialLocationOn;
      edge u_on goto On;
    location On:
      initial InitialLocationOn;
      edge u_off goto Off;
  end
  automaton EqualWaterDownstream:
    uncontrollable u_on;
    uncontrollable u_off;
    alg bool InitialLocationOn = true;
    location Off:
      initial not InitialLocationOn;
      edge u_on goto On;
    location On:
      initial InitialLocationOn;
      edge u_off goto Off;
  end
  automaton Water:
    const real h_upstream = 10.0;
    const real h_downstream = 2.0;
    cont h = 2.0 der if UpstreamOpen and h < h_upstream: +1.0 elif DownstreamOpen and h > h_downstream: -1.0 else 0.0 end;
    alg bool DownstreamOpen = (DownstreamEbb.EastPaddle.Open or DownstreamEbb.WestPaddle.Open or DownstreamEbb.EastGate.Open or DownstreamEbb.WestGate.Open) and (DownstreamFlood.EastPaddle.Open or DownstreamFlood.WestPaddle.Open or DownstreamFlood.EastGate.Open or DownstreamFlood.WestGate.Open) and (DownstreamStormFlood.EastPaddle.Open or DownstreamStormFlood.WestPaddle.Open or DownstreamStormFlood.EastGate.Open or DownstreamStormFlood.WestGate.Open);
    alg bool UpstreamOpen = (UpstreamEbb.EastPaddle.Open or UpstreamEbb.WestPaddle.Open or UpstreamEbb.EastGate.Open or UpstreamEbb.WestGate.Open) and (UpstreamFlood.EastPaddle.Open or UpstreamFlood.WestPaddle.Open or UpstreamFlood.EastGate.Open or UpstreamFlood.WestGate.Open);
    location Low:
      initial;
      edge when h > h_downstream goto Middle;
      edge EqualWaterUpstream.u_off;
      edge EqualWaterDownstream.u_on;
    location Middle:
      edge when h <= h_downstream goto Low;
      edge when h >= h_upstream goto High;
      edge EqualWaterUpstream.u_off;
      edge EqualWaterDownstream.u_off;
    location High:
      edge when h < h_upstream goto Middle;
      edge EqualWaterUpstream.u_on;
      edge EqualWaterDownstream.u_off;
  end
end
group Bridge:
  group UI:
    automaton LT:
      uncontrollable u_activate;
      uncontrollable u_deactivate;
      uncontrollable u_stop;
      location Deactivated:
        initial;
        edge u_activate goto Activated;
        edge u_stop goto Stopped;
      location Activated:
        edge u_deactivate goto Deactivated;
        edge u_stop goto Stopped;
      location Stopped:
        edge u_activate goto Activated;
        edge u_deactivate goto Deactivated;
    end
    automaton Barrier1:
      uncontrollable u_open;
      uncontrollable u_close;
      uncontrollable u_stop;
      alg bool InitialOpen = true;
      location Open:
        initial InitialOpen;
        edge u_close goto Close;
        edge u_stop goto Stop;
      location Close:
        initial not InitialOpen;
        edge u_open goto Open;
        edge u_stop goto Stop;
      location Stop:
        edge u_close goto Close;
        edge u_open goto Open;
    end
    automaton Barrier27:
      uncontrollable u_open;
      uncontrollable u_close;
      uncontrollable u_stop;
      alg bool InitialOpen = true;
      location Open:
        initial InitialOpen;
        edge u_close goto Close;
        edge u_stop goto Stop;
      location Close:
        initial not InitialOpen;
        edge u_open goto Open;
        edge u_stop goto Stop;
      location Stop:
        edge u_close goto Close;
        edge u_open goto Open;
    end
    automaton Barrier36:
      uncontrollable u_open;
      uncontrollable u_close;
      uncontrollable u_stop;
      alg bool InitialOpen = true;
      location Open:
        initial InitialOpen;
        edge u_close goto Close;
        edge u_stop goto Stop;
      location Close:
        initial not InitialOpen;
        edge u_open goto Open;
        edge u_stop goto Stop;
      location Stop:
        edge u_close goto Close;
        edge u_open goto Open;
    end
    automaton Barrier48:
      uncontrollable u_open;
      uncontrollable u_close;
      uncontrollable u_stop;
      alg bool InitialOpen = true;
      location Open:
        initial InitialOpen;
        edge u_close goto Close;
        edge u_stop goto Stop;
      location Close:
        initial not InitialOpen;
        edge u_open goto Open;
        edge u_stop goto Stop;
      location Stop:
        edge u_close goto Close;
        edge u_open goto Open;
    end
    automaton Barrier5:
      uncontrollable u_open;
      uncontrollable u_close;
      uncontrollable u_stop;
      alg bool InitialOpen = true;
      location Open:
        initial InitialOpen;
        edge u_close goto Close;
        edge u_stop goto Stop;
      location Close:
        initial not InitialOpen;
        edge u_open goto Open;
        edge u_stop goto Stop;
      location Stop:
        edge u_close goto Close;
        edge u_open goto Open;
    end
    automaton Deck:
      uncontrollable u_open;
      uncontrollable u_close;
      uncontrollable u_stop;
      alg bool InitialOpen = false;
      location Open:
        initial InitialOpen;
        edge u_close goto Close;
        edge u_stop goto Stop;
      location Close:
        initial not InitialOpen;
        edge u_open goto Open;
        edge u_stop goto Stop;
      location Stop:
        edge u_close goto Close;
        edge u_open goto Open;
    end
  end
  automaton EmergencyStop:
    uncontrollable u_activate;
    uncontrollable u_reset;
    location Deactivated:
      initial;
      edge u_activate goto Activated;
    location Activated:
      edge u_reset goto Deactivated;
  end
  group LTAS:
    automaton FarActuator:
      controllable c_on;
      controllable c_off;
      alg bool InitialLocationOn = false;
      location Off:
        initial not InitialLocationOn;
        edge c_on goto On;
      location On:
        initial InitialLocationOn;
        edge c_off goto Off;
    end
    automaton NearActuator:
      controllable c_on;
      controllable c_off;
      alg bool InitialLocationOn = false;
      location Off:
        initial not InitialLocationOn;
        edge c_on goto On;
      location On:
        initial InitialLocationOn;
        edge c_off goto Off;
    end
    group ApproachSign1:
      alg bool On = FarActuator.On and Sensor.On;
      alg bool Off = FarActuator.Off and Sensor.Off;
      automaton Sensor:
        uncontrollable u_on;
        uncontrollable u_off;
        alg bool InitialLocationOn = false;
        location Off:
          initial not InitialLocationOn;
          edge u_on goto On;
        location On:
          initial InitialLocationOn;
          edge u_off goto Off;
      end
      automaton Dynamics:
        alg bool On = FarActuator.On;
        alg bool Off = FarActuator.Off;
        location:
          initial;
          edge Sensor.u_on when On;
          edge Sensor.u_off when Off;
      end
    end
    group ApproachSign2:
      alg bool On = FarActuator.On and Sensor.On;
      alg bool Off = FarActuator.Off and Sensor.Off;
      automaton Sensor:
        uncontrollable u_on;
        uncontrollable u_off;
        alg bool InitialLocationOn = false;
        location Off:
          initial not InitialLocationOn;
          edge u_on goto On;
        location On:
          initial InitialLocationOn;
          edge u_off goto Off;
      end
      automaton Dynamics:
        alg bool On = FarActuator.On;
        alg bool Off = FarActuator.Off;
        location:
          initial;
          edge Sensor.u_on when On;
          edge Sensor.u_off when Off;
      end
    end
    group ApproachSign3:
      alg bool On = NearActuator.On and Sensor.On;
      alg bool Off = NearActuator.Off and Sensor.Off;
      automaton Sensor:
        uncontrollable u_on;
        uncontrollable u_off;
        alg bool InitialLocationOn = false;
        location Off:
          initial not InitialLocationOn;
          edge u_on goto On;
        location On:
          initial InitialLocationOn;
          edge u_off goto Off;
      end
      automaton Dynamics:
        alg bool On = NearActuator.On;
        alg bool Off = NearActuator.Off;
        location:
          initial;
          edge Sensor.u_on when On;
          edge Sensor.u_off when Off;
      end
    end
    group ApproachSign4:
      alg bool On = NearActuator.On and Sensor.On;
      alg bool Off = NearActuator.Off and Sensor.Off;
      automaton Sensor:
        uncontrollable u_on;
        uncontrollable u_off;
        alg bool InitialLocationOn = false;
        location Off:
          initial not InitialLocationOn;
          edge u_on goto On;
        location On:
          initial InitialLocationOn;
          edge u_off goto Off;
      end
      automaton Dynamics:
        alg bool On = NearActuator.On;
        alg bool Off = NearActuator.Off;
        location:
          initial;
          edge Sensor.u_on when On;
          edge Sensor.u_off when Off;
      end
    end
    group ApproachSign5:
      alg bool On = NearActuator.On and Sensor.On;
      alg bool Off = NearActuator.Off and Sensor.Off;
      automaton Sensor:
        uncontrollable u_on;
        uncontrollable u_off;
        alg bool InitialLocationOn = false;
        location Off:
          initial not InitialLocationOn;
          edge u_on goto On;
        location On:
          initial InitialLocationOn;
          edge u_off goto Off;
      end
      automaton Dynamics:
        alg bool On = NearActuator.On;
        alg bool Off = NearActuator.Off;
        location:
          initial;
          edge Sensor.u_on when On;
          edge Sensor.u_off when Off;
      end
    end
    automaton On15Timer:
      cont Y = 0.0 der if Running: -1.0 else 0.0 end;
      controllable c_on;
      controllable c_reset;
      uncontrollable u_timeout;
      alg real T = 15.0 / TimeScaler;
      location Off:
        initial;
        edge c_on do Y := T goto Running;
      location Running:
        edge c_reset goto Off;
        edge u_timeout when Y <= 0 goto Finished;
      location Finished:
        edge c_reset goto Off;
    end
    automaton On20Timer:
      cont Y = 0.0 der if Running: -1.0 else 0.0 end;
      controllable c_on;
      controllable c_reset;
      uncontrollable u_timeout;
      alg real T = 20.0 / TimeScaler;
      location Off:
        initial;
        edge c_on do Y := T goto Running;
      location Running:
        edge c_reset goto Off;
        edge u_timeout when Y <= 0 goto Finished;
      location Finished:
        edge c_reset goto Off;
    end
    automaton NearOff60Timer:
      cont Y = 0.0 der if Running: -1.0 else 0.0 end;
      controllable c_on;
      controllable c_reset;
      uncontrollable u_timeout;
      alg real T = 60.0 / TimeScaler;
      location Off:
        initial;
        edge c_on do Y := T goto Running;
      location Running:
        edge c_reset goto Off;
        edge u_timeout when Y <= 0 goto Finished;
      location Finished:
        edge c_reset goto Off;
    end
  end
  group LTSS:
    automaton MainLaneActuator:
      controllable c_on;
      controllable c_off;
      alg bool InitialLocationOn = false;
      location Off:
        initial not InitialLocationOn;
        edge c_on goto On;
      location On:
        initial InitialLocationOn;
        edge c_off goto Off;
    end
    automaton SwitchLaneActuator:
      controllable c_on;
      controllable c_off;
      alg bool InitialLocationOn = false;
      location Off:
        initial not InitialLocationOn;
        edge c_on goto On;
      location On:
        initial InitialLocationOn;
        edge c_off goto Off;
    end
    group StopSign1:
      alg bool On = SwitchLaneActuator.On and Sensor.On;
      alg bool Off = SwitchLaneActuator.Off and Sensor.Off;
      automaton Sensor:
        uncontrollable u_on;
        uncontrollable u_off;
        alg bool InitialLocationOn = false;
        location Off:
          initial not InitialLocationOn;
          edge u_on goto On;
        location On:
          initial InitialLocationOn;
          edge u_off goto Off;
      end
      automaton Dynamics:
        alg bool On = SwitchLaneActuator.On;
        alg bool Off = SwitchLaneActuator.Off;
        location:
          initial;
          edge Sensor.u_on when On;
          edge Sensor.u_off when Off;
      end
    end
    group StopSign2:
      alg bool On = SwitchLaneActuator.On and Sensor.On;
      alg bool Off = SwitchLaneActuator.Off and Sensor.Off;
      automaton Sensor:
        uncontrollable u_on;
        uncontrollable u_off;
        alg bool InitialLocationOn = false;
        location Off:
          initial not InitialLocationOn;
          edge u_on goto On;
        location On:
          initial InitialLocationOn;
          edge u_off goto Off;
      end
      automaton Dynamics:
        alg bool On = SwitchLaneActuator.On;
        alg bool Off = SwitchLaneActuator.Off;
        location:
          initial;
          edge Sensor.u_on when On;
          edge Sensor.u_off when Off;
      end
    end
    group StopSign3:
      alg bool On = SwitchLaneActuator.On and Sensor.On;
      alg bool Off = SwitchLaneActuator.Off and Sensor.Off;
      automaton Sensor:
        uncontrollable u_on;
        uncontrollable u_off;
        alg bool InitialLocationOn = false;
        location Off:
          initial not InitialLocationOn;
          edge u_on goto On;
        location On:
          initial InitialLocationOn;
          edge u_off goto Off;
      end
      automaton Dynamics:
        alg bool On = SwitchLaneActuator.On;
        alg bool Off = SwitchLaneActuator.Off;
        location:
          initial;
          edge Sensor.u_on when On;
          edge Sensor.u_off when Off;
      end
    end
    group StopSign4:
      alg bool On = SwitchLaneActuator.On and Sensor.On;
      alg bool Off = SwitchLaneActuator.Off and Sensor.Off;
      automaton Sensor:
        uncontrollable u_on;
        uncontrollable u_off;
        alg bool InitialLocationOn = false;
        location Off:
          initial not InitialLocationOn;
          edge u_on goto On;
        location On:
          initial InitialLocationOn;
          edge u_off goto Off;
      end
      automaton Dynamics:
        alg bool On = SwitchLaneActuator.On;
        alg bool Off = SwitchLaneActuator.Off;
        location:
          initial;
          edge Sensor.u_on when On;
          edge Sensor.u_off when Off;
      end
    end
    group StopSign5:
      alg bool On = MainLaneActuator.On and Sensor.On;
      alg bool Off = MainLaneActuator.Off and Sensor.Off;
      automaton Sensor:
        uncontrollable u_on;
        uncontrollable u_off;
        alg bool InitialLocationOn = false;
        location Off:
          initial not InitialLocationOn;
          edge u_on goto On;
        location On:
          initial InitialLocationOn;
          edge u_off goto Off;
      end
      automaton Dynamics:
        alg bool On = MainLaneActuator.On;
        alg bool Off = MainLaneActuator.Off;
        location:
          initial;
          edge Sensor.u_on when On;
          edge Sensor.u_off when Off;
      end
    end
    group StopSign6:
      alg bool On = MainLaneActuator.On and Sensor.On;
      alg bool Off = MainLaneActuator.Off and Sensor.Off;
      automaton Sensor:
        uncontrollable u_on;
        uncontrollable u_off;
        alg bool InitialLocationOn = false;
        location Off:
          initial not InitialLocationOn;
          edge u_on goto On;
        location On:
          initial InitialLocationOn;
          edge u_off goto Off;
      end
      automaton Dynamics:
        alg bool On = MainLaneActuator.On;
        alg bool Off = MainLaneActuator.Off;
        location:
          initial;
          edge Sensor.u_on when On;
          edge Sensor.u_off when Off;
      end
    end
    group StopSign7:
      alg bool On = MainLaneActuator.On and Sensor.On;
      alg bool Off = MainLaneActuator.Off and Sensor.Off;
      automaton Sensor:
        uncontrollable u_on;
        uncontrollable u_off;
        alg bool InitialLocationOn = false;
        location Off:
          initial not InitialLocationOn;
          edge u_on goto On;
        location On:
          initial InitialLocationOn;
          edge u_off goto Off;
      end
      automaton Dynamics:
        alg bool On = MainLaneActuator.On;
        alg bool Off = MainLaneActuator.Off;
        location:
          initial;
          edge Sensor.u_on when On;
          edge Sensor.u_off when Off;
      end
    end
    group StopSign8:
      alg bool On = MainLaneActuator.On and Sensor.On;
      alg bool Off = MainLaneActuator.Off and Sensor.Off;
      automaton Sensor:
        uncontrollable u_on;
        uncontrollable u_off;
        alg bool InitialLocationOn = false;
        location Off:
          initial not InitialLocationOn;
          edge u_on goto On;
        location On:
          initial InitialLocationOn;
          edge u_off goto Off;
      end
      automaton Dynamics:
        alg bool On = MainLaneActuator.On;
        alg bool Off = MainLaneActuator.Off;
        location:
          initial;
          edge Sensor.u_on when On;
          edge Sensor.u_off when Off;
      end
    end
    group StopSign9:
      alg bool On = MainLaneActuator.On and Sensor.On;
      alg bool Off = MainLaneActuator.Off and Sensor.Off;
      automaton Sensor:
        uncontrollable u_on;
        uncontrollable u_off;
        alg bool InitialLocationOn = false;
        location Off:
          initial not InitialLocationOn;
          edge u_on goto On;
        location On:
          initial InitialLocationOn;
          edge u_off goto Off;
      end
      automaton Dynamics:
        alg bool On = MainLaneActuator.On;
        alg bool Off = MainLaneActuator.Off;
        location:
          initial;
          edge Sensor.u_on when On;
          edge Sensor.u_off when Off;
      end
    end
    group StopSign10:
      alg bool On = MainLaneActuator.On and Sensor.On;
      alg bool Off = MainLaneActuator.Off and Sensor.Off;
      automaton Sensor:
        uncontrollable u_on;
        uncontrollable u_off;
        alg bool InitialLocationOn = false;
        location Off:
          initial not InitialLocationOn;
          edge u_on goto On;
        location On:
          initial InitialLocationOn;
          edge u_off goto Off;
      end
      automaton Dynamics:
        alg bool On = MainLaneActuator.On;
        alg bool Off = MainLaneActuator.Off;
        location:
          initial;
          edge Sensor.u_on when On;
          edge Sensor.u_off when Off;
      end
    end
    group StopSign11:
      alg bool On = MainLaneActuator.On and Sensor.On;
      alg bool Off = MainLaneActuator.Off and Sensor.Off;
      automaton Sensor:
        uncontrollable u_on;
        uncontrollable u_off;
        alg bool InitialLocationOn = false;
        location Off:
          initial not InitialLocationOn;
          edge u_on goto On;
        location On:
          initial InitialLocationOn;
          edge u_off goto Off;
      end
      automaton Dynamics:
        alg bool On = MainLaneActuator.On;
        alg bool Off = MainLaneActuator.Off;
        location:
          initial;
          edge Sensor.u_on when On;
          edge Sensor.u_off when Off;
      end
    end
    group StopSign12:
      alg bool On = MainLaneActuator.On and Sensor.On;
      alg bool Off = MainLaneActuator.Off and Sensor.Off;
      automaton Sensor:
        uncontrollable u_on;
        uncontrollable u_off;
        alg bool InitialLocationOn = false;
        location Off:
          initial not InitialLocationOn;
          edge u_on goto On;
        location On:
          initial InitialLocationOn;
          edge u_off goto Off;
      end
      automaton Dynamics:
        alg bool On = MainLaneActuator.On;
        alg bool Off = MainLaneActuator.Off;
        location:
          initial;
          edge Sensor.u_on when On;
          edge Sensor.u_off when Off;
      end
    end
    automaton On15Timer:
      cont Y = 0.0 der if Running: -1.0 else 0.0 end;
      controllable c_on;
      controllable c_reset;
      uncontrollable u_timeout;
      alg real T = 15.0 / TimeScaler;
      location Off:
        initial;
        edge c_on do Y := T goto Running;
      location Running:
        edge c_reset goto Off;
        edge u_timeout when Y <= 0 goto Finished;
      location Finished:
        edge c_reset goto Off;
    end
    automaton Off60Timer:
      cont Y = 0.0 der if Running: -1.0 else 0.0 end;
      controllable c_on;
      controllable c_reset;
      uncontrollable u_timeout;
      alg real T = 60.0 / TimeScaler;
      location Off:
        initial;
        edge c_on do Y := T goto Running;
      location Running:
        edge c_reset goto Off;
        edge u_timeout when Y <= 0 goto Finished;
      location Finished:
        edge c_reset goto Off;
    end
  end
  group Barriers:
    group B1:
      alg real a = Dynamics.a;
      alg bool Open = Sensor.Open;
      alg bool InitialLocationClosed = false;
      automaton Actuator:
        controllable c_open;
        controllable c_close;
        controllable c_emrgStop;
        controllable c_endStopClosing;
        controllable c_endStopOpening;
        location Rest:
          initial;
          edge c_open goto Opening;
          edge c_close goto Closing;
        location Opening:
          edge c_emrgStop, c_endStopOpening goto Rest;
        location Closing:
          edge c_emrgStop, c_endStopClosing goto Rest;
      end
      automaton Sensor:
        uncontrollable u_open_on;
        uncontrollable u_open_off;
        uncontrollable u_closed_on;
        uncontrollable u_closed_off;
        alg bool InitialLocationClosed = .Bridge.Barriers.B1.InitialLocationClosed;
        location Closed:
          initial InitialLocationClosed;
          edge u_closed_off goto Intermediate;
        location Intermediate:
          edge u_closed_on goto Closed;
          edge u_open_on goto Open;
        location Open:
          initial not InitialLocationClosed;
          edge u_open_off goto Intermediate;
      end
      automaton Dynamics:
        const real a_open = 3.0;
        const real a_closed = 0.0;
        cont a = if InitialLocationClosed: a_closed else a_open end der if Actuator.Opening and a < a_open: +1.0 elif Actuator.Closing and a > a_closed: -1.0 else 0.0 end;
        alg bool InitialLocationClosed = .Bridge.Barriers.B1.InitialLocationClosed;
        location:
          initial;
          edge Sensor.u_open_on when a >= a_open;
          edge Sensor.u_closed_off when a < a_open;
          edge Sensor.u_closed_on when a <= a_closed;
          edge Sensor.u_open_off when a > a_closed;
      end
    end
    group B2:
      alg real a = Dynamics.a;
      alg bool Open = Sensor.Open;
      alg bool InitialLocationClosed = false;
      automaton Actuator:
        controllable c_open;
        controllable c_close;
        controllable c_emrgStop;
        controllable c_endStopClosing;
        controllable c_endStopOpening;
        location Rest:
          initial;
          edge c_open goto Opening;
          edge c_close goto Closing;
        location Opening:
          edge c_emrgStop, c_endStopOpening goto Rest;
        location Closing:
          edge c_emrgStop, c_endStopClosing goto Rest;
      end
      automaton Sensor:
        uncontrollable u_open_on;
        uncontrollable u_open_off;
        uncontrollable u_closed_on;
        uncontrollable u_closed_off;
        alg bool InitialLocationClosed = .Bridge.Barriers.B2.InitialLocationClosed;
        location Closed:
          initial InitialLocationClosed;
          edge u_closed_off goto Intermediate;
        location Intermediate:
          edge u_closed_on goto Closed;
          edge u_open_on goto Open;
        location Open:
          initial not InitialLocationClosed;
          edge u_open_off goto Intermediate;
      end
      automaton Dynamics:
        const real a_open = 3.0;
        const real a_closed = 0.0;
        cont a = if InitialLocationClosed: a_closed else a_open end der if Actuator.Opening and a < a_open: +1.0 elif Actuator.Closing and a > a_closed: -1.0 else 0.0 end;
        alg bool InitialLocationClosed = .Bridge.Barriers.B2.InitialLocationClosed;
        location:
          initial;
          edge Sensor.u_open_on when a >= a_open;
          edge Sensor.u_closed_off when a < a_open;
          edge Sensor.u_closed_on when a <= a_closed;
          edge Sensor.u_open_off when a > a_closed;
      end
    end
    group B3:
      alg real a = Dynamics.a;
      alg bool Open = Sensor.Open;
      alg bool InitialLocationClosed = false;
      automaton Actuator:
        controllable c_open;
        controllable c_close;
        controllable c_emrgStop;
        controllable c_endStopClosing;
        controllable c_endStopOpening;
        location Rest:
          initial;
          edge c_open goto Opening;
          edge c_close goto Closing;
        location Opening:
          edge c_emrgStop, c_endStopOpening goto Rest;
        location Closing:
          edge c_emrgStop, c_endStopClosing goto Rest;
      end
      automaton Sensor:
        uncontrollable u_open_on;
        uncontrollable u_open_off;
        uncontrollable u_closed_on;
        uncontrollable u_closed_off;
        alg bool InitialLocationClosed = .Bridge.Barriers.B3.InitialLocationClosed;
        location Closed:
          initial InitialLocationClosed;
          edge u_closed_off goto Intermediate;
        location Intermediate:
          edge u_closed_on goto Closed;
          edge u_open_on goto Open;
        location Open:
          initial not InitialLocationClosed;
          edge u_open_off goto Intermediate;
      end
      automaton Dynamics:
        const real a_open = 3.0;
        const real a_closed = 0.0;
        cont a = if InitialLocationClosed: a_closed else a_open end der if Actuator.Opening and a < a_open: +1.0 elif Actuator.Closing and a > a_closed: -1.0 else 0.0 end;
        alg bool InitialLocationClosed = .Bridge.Barriers.B3.InitialLocationClosed;
        location:
          initial;
          edge Sensor.u_open_on when a >= a_open;
          edge Sensor.u_closed_off when a < a_open;
          edge Sensor.u_closed_on when a <= a_closed;
          edge Sensor.u_open_off when a > a_closed;
      end
    end
    group B4:
      alg real a = Dynamics.a;
      alg bool Open = Sensor.Open;
      alg bool InitialLocationClosed = false;
      automaton Actuator:
        controllable c_open;
        controllable c_close;
        controllable c_emrgStop;
        controllable c_endStopClosing;
        controllable c_endStopOpening;
        location Rest:
          initial;
          edge c_open goto Opening;
          edge c_close goto Closing;
        location Opening:
          edge c_emrgStop, c_endStopOpening goto Rest;
        location Closing:
          edge c_emrgStop, c_endStopClosing goto Rest;
      end
      automaton Sensor:
        uncontrollable u_open_on;
        uncontrollable u_open_off;
        uncontrollable u_closed_on;
        uncontrollable u_closed_off;
        alg bool InitialLocationClosed = .Bridge.Barriers.B4.InitialLocationClosed;
        location Closed:
          initial InitialLocationClosed;
          edge u_closed_off goto Intermediate;
        location Intermediate:
          edge u_closed_on goto Closed;
          edge u_open_on goto Open;
        location Open:
          initial not InitialLocationClosed;
          edge u_open_off goto Intermediate;
      end
      automaton Dynamics:
        const real a_open = 3.0;
        const real a_closed = 0.0;
        cont a = if InitialLocationClosed: a_closed else a_open end der if Actuator.Opening and a < a_open: +1.0 elif Actuator.Closing and a > a_closed: -1.0 else 0.0 end;
        alg bool InitialLocationClosed = .Bridge.Barriers.B4.InitialLocationClosed;
        location:
          initial;
          edge Sensor.u_open_on when a >= a_open;
          edge Sensor.u_closed_off when a < a_open;
          edge Sensor.u_closed_on when a <= a_closed;
          edge Sensor.u_open_off when a > a_closed;
      end
    end
    group B5:
      alg real a = Dynamics.a;
      alg bool Open = Sensor.Open;
      alg bool InitialLocationClosed = false;
      automaton Actuator:
        controllable c_open;
        controllable c_close;
        controllable c_emrgStop;
        controllable c_endStopClosing;
        controllable c_endStopOpening;
        location Rest:
          initial;
          edge c_open goto Opening;
          edge c_close goto Closing;
        location Opening:
          edge c_emrgStop, c_endStopOpening goto Rest;
        location Closing:
          edge c_emrgStop, c_endStopClosing goto Rest;
      end
      automaton Sensor:
        uncontrollable u_open_on;
        uncontrollable u_open_off;
        uncontrollable u_closed_on;
        uncontrollable u_closed_off;
        alg bool InitialLocationClosed = .Bridge.Barriers.B5.InitialLocationClosed;
        location Closed:
          initial InitialLocationClosed;
          edge u_closed_off goto Intermediate;
        location Intermediate:
          edge u_closed_on goto Closed;
          edge u_open_on goto Open;
        location Open:
          initial not InitialLocationClosed;
          edge u_open_off goto Intermediate;
      end
      automaton Dynamics:
        const real a_open = 3.0;
        const real a_closed = 0.0;
        cont a = if InitialLocationClosed: a_closed else a_open end der if Actuator.Opening and a < a_open: +1.0 elif Actuator.Closing and a > a_closed: -1.0 else 0.0 end;
        alg bool InitialLocationClosed = .Bridge.Barriers.B5.InitialLocationClosed;
        location:
          initial;
          edge Sensor.u_open_on when a >= a_open;
          edge Sensor.u_closed_off when a < a_open;
          edge Sensor.u_closed_on when a <= a_closed;
          edge Sensor.u_open_off when a > a_closed;
      end
    end
    group B6:
      alg real a = Dynamics.a;
      alg bool Open = Sensor.Open;
      alg bool InitialLocationClosed = false;
      automaton Actuator:
        controllable c_open;
        controllable c_close;
        controllable c_emrgStop;
        controllable c_endStopClosing;
        controllable c_endStopOpening;
        location Rest:
          initial;
          edge c_open goto Opening;
          edge c_close goto Closing;
        location Opening:
          edge c_emrgStop, c_endStopOpening goto Rest;
        location Closing:
          edge c_emrgStop, c_endStopClosing goto Rest;
      end
      automaton Sensor:
        uncontrollable u_open_on;
        uncontrollable u_open_off;
        uncontrollable u_closed_on;
        uncontrollable u_closed_off;
        alg bool InitialLocationClosed = .Bridge.Barriers.B6.InitialLocationClosed;
        location Closed:
          initial InitialLocationClosed;
          edge u_closed_off goto Intermediate;
        location Intermediate:
          edge u_closed_on goto Closed;
          edge u_open_on goto Open;
        location Open:
          initial not InitialLocationClosed;
          edge u_open_off goto Intermediate;
      end
      automaton Dynamics:
        const real a_open = 3.0;
        const real a_closed = 0.0;
        cont a = if InitialLocationClosed: a_closed else a_open end der if Actuator.Opening and a < a_open: +1.0 elif Actuator.Closing and a > a_closed: -1.0 else 0.0 end;
        alg bool InitialLocationClosed = .Bridge.Barriers.B6.InitialLocationClosed;
        location:
          initial;
          edge Sensor.u_open_on when a >= a_open;
          edge Sensor.u_closed_off when a < a_open;
          edge Sensor.u_closed_on when a <= a_closed;
          edge Sensor.u_open_off when a > a_closed;
      end
    end
    group B7:
      alg real a = Dynamics.a;
      alg bool Open = Sensor.Open;
      alg bool InitialLocationClosed = false;
      automaton Actuator:
        controllable c_open;
        controllable c_close;
        controllable c_emrgStop;
        controllable c_endStopClosing;
        controllable c_endStopOpening;
        location Rest:
          initial;
          edge c_open goto Opening;
          edge c_close goto Closing;
        location Opening:
          edge c_emrgStop, c_endStopOpening goto Rest;
        location Closing:
          edge c_emrgStop, c_endStopClosing goto Rest;
      end
      automaton Sensor:
        uncontrollable u_open_on;
        uncontrollable u_open_off;
        uncontrollable u_closed_on;
        uncontrollable u_closed_off;
        alg bool InitialLocationClosed = .Bridge.Barriers.B7.InitialLocationClosed;
        location Closed:
          initial InitialLocationClosed;
          edge u_closed_off goto Intermediate;
        location Intermediate:
          edge u_closed_on goto Closed;
          edge u_open_on goto Open;
        location Open:
          initial not InitialLocationClosed;
          edge u_open_off goto Intermediate;
      end
      automaton Dynamics:
        const real a_open = 3.0;
        const real a_closed = 0.0;
        cont a = if InitialLocationClosed: a_closed else a_open end der if Actuator.Opening and a < a_open: +1.0 elif Actuator.Closing and a > a_closed: -1.0 else 0.0 end;
        alg bool InitialLocationClosed = .Bridge.Barriers.B7.InitialLocationClosed;
        location:
          initial;
          edge Sensor.u_open_on when a >= a_open;
          edge Sensor.u_closed_off when a < a_open;
          edge Sensor.u_closed_on when a <= a_closed;
          edge Sensor.u_open_off when a > a_closed;
      end
    end
    group B8:
      alg real a = Dynamics.a;
      alg bool Open = Sensor.Open;
      alg bool InitialLocationClosed = false;
      automaton Actuator:
        controllable c_open;
        controllable c_close;
        controllable c_emrgStop;
        controllable c_endStopClosing;
        controllable c_endStopOpening;
        location Rest:
          initial;
          edge c_open goto Opening;
          edge c_close goto Closing;
        location Opening:
          edge c_emrgStop, c_endStopOpening goto Rest;
        location Closing:
          edge c_emrgStop, c_endStopClosing goto Rest;
      end
      automaton Sensor:
        uncontrollable u_open_on;
        uncontrollable u_open_off;
        uncontrollable u_closed_on;
        uncontrollable u_closed_off;
        alg bool InitialLocationClosed = .Bridge.Barriers.B8.InitialLocationClosed;
        location Closed:
          initial InitialLocationClosed;
          edge u_closed_off goto Intermediate;
        location Intermediate:
          edge u_closed_on goto Closed;
          edge u_open_on goto Open;
        location Open:
          initial not InitialLocationClosed;
          edge u_open_off goto Intermediate;
      end
      automaton Dynamics:
        const real a_open = 3.0;
        const real a_closed = 0.0;
        cont a = if InitialLocationClosed: a_closed else a_open end der if Actuator.Opening and a < a_open: +1.0 elif Actuator.Closing and a > a_closed: -1.0 else 0.0 end;
        alg bool InitialLocationClosed = .Bridge.Barriers.B8.InitialLocationClosed;
        location:
          initial;
          edge Sensor.u_open_on when a >= a_open;
          edge Sensor.u_closed_off when a < a_open;
          edge Sensor.u_closed_on when a <= a_closed;
          edge Sensor.u_open_off when a > a_closed;
      end
    end
    automaton LightSignals:
      controllable c_on;
      controllable c_off;
      alg bool InitialLocationOn = false;
      location Off:
        initial not InitialLocationOn;
        edge c_on goto On;
      location On:
        initial InitialLocationOn;
        edge c_off goto Off;
    end
    automaton SoundSignals:
      controllable c_on;
      controllable c_off;
      alg bool InitialLocationOn = false;
      location Off:
        initial not InitialLocationOn;
        edge c_on goto On;
      location On:
        initial InitialLocationOn;
        edge c_off goto Off;
    end
    automaton B3B6Closed1Timer:
      cont Y = 0.0 der if Running: -1.0 else 0.0 end;
      controllable c_on;
      controllable c_reset;
      uncontrollable u_timeout;
      alg real T = 1.0 / TimeScaler;
      location Off:
        initial;
        edge c_on do Y := T goto Running;
      location Running:
        edge c_reset goto Off;
        edge u_timeout when Y <= 0 goto Finished;
      location Finished:
        edge c_reset goto Off;
    end
    automaton B2B7Open1Timer:
      cont Y = 0.0 der if Running: -1.0 else 0.0 end;
      controllable c_on;
      controllable c_reset;
      uncontrollable u_timeout;
      alg real T = 1.0 / TimeScaler;
      location Off:
        initial;
        edge c_on do Y := T goto Running;
      location Running:
        edge c_reset goto Off;
        edge u_timeout when Y <= 0 goto Finished;
      location Finished:
        edge c_reset goto Off;
    end
    automaton SoundOn6Timer:
      cont Y = 0.0 der if Running: -1.0 else 0.0 end;
      controllable c_on;
      controllable c_reset;
      uncontrollable u_timeout;
      alg real T = 6.0 / TimeScaler;
      location Off:
        initial;
        edge c_on do Y := T goto Running;
      location Running:
        edge c_reset goto Off;
        edge u_timeout when Y <= 0 goto Finished;
      location Finished:
        edge c_reset goto Off;
    end
  end
  group Deck:
    alg real a = Dynamics.a;
    alg bool Open = Sensor.Open;
    alg bool InitialLocationClosed = true;
    automaton Actuator:
      controllable c_open;
      controllable c_close;
      controllable c_emrgStop;
      controllable c_endStopClosing;
      controllable c_endStopOpening;
      location Rest:
        initial;
        edge c_open goto Opening;
        edge c_close goto Closing;
      location Opening:
        edge c_emrgStop, c_endStopOpening goto Rest;
      location Closing:
        edge c_emrgStop, c_endStopClosing goto Rest;
    end
    automaton Sensor:
      uncontrollable u_open_on;
      uncontrollable u_open_off;
      uncontrollable u_closed_on;
      uncontrollable u_closed_off;
      alg bool InitialLocationClosed = .Bridge.Deck.InitialLocationClosed;
      location Closed:
        initial InitialLocationClosed;
        edge u_closed_off goto Intermediate;
      location Intermediate:
        edge u_closed_on goto Closed;
        edge u_open_on goto Open;
      location Open:
        initial not InitialLocationClosed;
        edge u_open_off goto Intermediate;
    end
    automaton Dynamics:
      const real a_open = 3.0;
      const real a_closed = 0.0;
      cont a = if InitialLocationClosed: a_closed else a_open end der if Actuator.Opening and a < a_open: +1.0 elif Actuator.Closing and a > a_closed: -1.0 else 0.0 end;
      alg bool InitialLocationClosed = .Bridge.Deck.InitialLocationClosed;
      location:
        initial;
        edge Sensor.u_open_on when a >= a_open;
        edge Sensor.u_closed_off when a < a_open;
        edge Sensor.u_closed_on when a <= a_closed;
        edge Sensor.u_open_off when a > a_closed;
    end
  end
  automaton CloseRequest:
    uncontrollable u_on;
    uncontrollable u_off;
    alg bool InitialLocationOn = false;
    location Off:
      initial not InitialLocationOn;
      edge u_on goto On;
    location On:
      initial InitialLocationOn;
      edge u_off goto Off;
  end
end
group sup:
  group Requirement1:
    requirement invariant .Bridge.Deck.Actuator.c_open needs not(Lock.UpstreamEbb.GatesMoving or Lock.UpstreamFlood.GatesMoving or Lock.DownstreamEbb.GatesMoving or Lock.DownstreamFlood.GatesMoving or Lock.DownstreamStormFlood.GatesMoving);
    requirement invariant .Bridge.Deck.Actuator.c_open needs not(Lock.UpstreamEbb.GatesMoving or Lock.UpstreamFlood.GatesMoving or Lock.DownstreamEbb.GatesMoving or Lock.DownstreamFlood.GatesMoving or Lock.DownstreamStormFlood.GatesMoving);
    requirement invariant .Bridge.Deck.Actuator.c_open needs Lock.BTL.DRed;
    requirement invariant .Bridge.Deck.Actuator.c_close needs Lock.BTL.DRed;
    requirement invariant .Bridge.Deck.Actuator.c_open needs Lock.LTL.DRed or Lock.LTL.DRedRed;
    requirement invariant .Bridge.Deck.Actuator.c_close needs Lock.LTL.DRed or Lock.LTL.DRedRed;
    requirement invariant .Lock.LTL.DE.Actuator.c_g needs Lock.DownstreamEbb.GatesOpen and Lock.DownstreamFlood.GatesOpen and Lock.DownstreamStormFlood.GatesOpen;
    requirement invariant .Lock.LTL.DW.Actuator.c_g needs Lock.DownstreamEbb.GatesOpen and Lock.DownstreamFlood.GatesOpen and Lock.DownstreamStormFlood.GatesOpen;
    requirement invariant .Lock.LTL.UE.Actuator.c_g needs Lock.UpstreamEbb.GatesOpen and Lock.UpstreamFlood.GatesOpen;
    requirement invariant .Lock.LTL.UW.Actuator.c_g needs Lock.UpstreamEbb.GatesOpen and Lock.UpstreamFlood.GatesOpen;
    requirement invariant .Lock.LTL.DE.Actuator.c_g needs Lock.BTL.DRed;
    requirement invariant .Lock.LTL.DW.Actuator.c_g needs Lock.BTL.DRed;
    requirement invariant .Bridge.LTSS.MainLaneActuator.c_on needs Bridge.LTAS.On;
    requirement invariant .Bridge.LTSS.MainLaneActuator.c_on needs Bridge.LTAS.On15Timer.Finished;
    requirement invariant .Bridge.LTSS.SwitchLaneActuator.c_on needs Bridge.LTAS.On;
    requirement invariant .Bridge.LTSS.SwitchLaneActuator.c_on needs Bridge.LTAS.On15Timer.Finished;
    requirement invariant .Bridge.Barriers.LightSignals.c_on needs Bridge.LTAS.On;
    requirement invariant .Bridge.Barriers.LightSignals.c_on needs Bridge.LTAS.On15Timer.Finished;
  end
  group Requirement2:
    requirement invariant .Lock.UpstreamEbb.EastGate.Actuator.c_open needs not Bridge.Deck.Moving;
    requirement invariant .Lock.UpstreamEbb.EastGate.Actuator.c_close needs not Bridge.Deck.Moving;
    requirement invariant .Lock.UpstreamEbb.WestGate.Actuator.c_open needs not Bridge.Deck.Moving;
    requirement invariant .Lock.UpstreamEbb.WestGate.Actuator.c_close needs not Bridge.Deck.Moving;
    requirement invariant .Lock.UpstreamFlood.EastGate.Actuator.c_open needs not Bridge.Deck.Moving;
    requirement invariant .Lock.UpstreamFlood.EastGate.Actuator.c_close needs not Bridge.Deck.Moving;
    requirement invariant .Lock.UpstreamFlood.WestGate.Actuator.c_open needs not Bridge.Deck.Moving;
    requirement invariant .Lock.UpstreamFlood.WestGate.Actuator.c_close needs not Bridge.Deck.Moving;
    requirement invariant .Lock.DownstreamEbb.EastGate.Actuator.c_open needs not Bridge.Deck.Moving;
    requirement invariant .Lock.DownstreamEbb.EastGate.Actuator.c_close needs not Bridge.Deck.Moving;
    requirement invariant .Lock.DownstreamEbb.WestGate.Actuator.c_open needs not Bridge.Deck.Moving;
    requirement invariant .Lock.DownstreamEbb.WestGate.Actuator.c_close needs not Bridge.Deck.Moving;
    requirement invariant .Lock.DownstreamFlood.EastGate.Actuator.c_open needs not Bridge.Deck.Moving;
    requirement invariant .Lock.DownstreamFlood.EastGate.Actuator.c_close needs not Bridge.Deck.Moving;
    requirement invariant .Lock.DownstreamFlood.WestGate.Actuator.c_open needs not Bridge.Deck.Moving;
    requirement invariant .Lock.DownstreamFlood.WestGate.Actuator.c_close needs not Bridge.Deck.Moving;
    requirement invariant .Lock.DownstreamStormFlood.EastGate.Actuator.c_open needs not Bridge.Deck.Moving;
    requirement invariant .Lock.DownstreamStormFlood.EastGate.Actuator.c_close needs not Bridge.Deck.Moving;
    requirement invariant .Lock.DownstreamStormFlood.WestGate.Actuator.c_open needs not Bridge.Deck.Moving;
    requirement invariant .Lock.DownstreamStormFlood.WestGate.Actuator.c_close needs not Bridge.Deck.Moving;
    requirement invariant .Lock.BTL.DE.Actuator.c_g needs Lock.DownstreamEbb.GatesOpen and Lock.DownstreamFlood.GatesOpen and Lock.DownstreamStormFlood.GatesOpen;
    requirement invariant .Lock.BTL.DW.Actuator.c_g needs Lock.DownstreamEbb.GatesOpen and Lock.DownstreamFlood.GatesOpen and Lock.DownstreamStormFlood.GatesOpen;
    requirement invariant .Lock.BTL.DE.Actuator.c_g needs Lock.LTL.DRed or Lock.LTL.DRedRed;
    requirement invariant .Lock.BTL.DW.Actuator.c_g needs Lock.LTL.DRed or Lock.LTL.DRedRed;
    requirement invariant .Bridge.Barriers.SoundSignals.c_on needs Bridge.LTAS.On;
    requirement invariant .Bridge.Barriers.SoundSignals.c_on needs Bridge.LTAS.On20Timer.Finished;
    requirement invariant .Bridge.Barriers.SoundSignals.c_on needs not Bridge.Barriers.SlowClosed;
    requirement invariant .Bridge.Barriers.SoundSignals.c_off needs Bridge.Barriers.SlowClosed;
  end
  group Requirement3:
    requirement invariant .Lock.BTL.DE.Actuator.c_g needs Bridge.Deck.Open or Bridge.Deck.Closed;
    requirement invariant .Lock.BTL.DW.Actuator.c_g needs Bridge.Deck.Open or Bridge.Deck.Closed;
    requirement invariant .Lock.DownstreamEbb.EastGate.Actuator.c_close needs Lock.LTL.DRed or Lock.LTL.DRedRed;
    requirement invariant .Lock.DownstreamEbb.WestGate.Actuator.c_close needs Lock.LTL.DRed or Lock.LTL.DRedRed;
    requirement invariant .Lock.DownstreamFlood.EastGate.Actuator.c_close needs Lock.LTL.DRed or Lock.LTL.DRedRed;
    requirement invariant .Lock.DownstreamFlood.WestGate.Actuator.c_close needs Lock.LTL.DRed or Lock.LTL.DRedRed;
    requirement invariant .Lock.DownstreamStormFlood.EastGate.Actuator.c_close needs Lock.LTL.DRed or Lock.LTL.DRedRed;
    requirement invariant .Lock.DownstreamStormFlood.WestGate.Actuator.c_close needs Lock.LTL.DRed or Lock.LTL.DRedRed;
    requirement invariant .Lock.UpstreamEbb.EastGate.Actuator.c_close needs Lock.LTL.URed or Lock.LTL.URedRed;
    requirement invariant .Lock.UpstreamEbb.WestGate.Actuator.c_close needs Lock.LTL.URed or Lock.LTL.URedRed;
    requirement invariant .Lock.UpstreamFlood.EastGate.Actuator.c_close needs Lock.LTL.URed or Lock.LTL.URedRed;
    requirement invariant .Lock.UpstreamFlood.WestGate.Actuator.c_close needs Lock.LTL.URed or Lock.LTL.URedRed;
    requirement invariant .Lock.DownstreamEbb.EastGate.Actuator.c_close needs Lock.BTL.DRed;
    requirement invariant .Lock.DownstreamEbb.WestGate.Actuator.c_close needs Lock.BTL.DRed;
    requirement invariant .Lock.DownstreamFlood.EastGate.Actuator.c_close needs Lock.BTL.DRed;
    requirement invariant .Lock.DownstreamFlood.WestGate.Actuator.c_close needs Lock.BTL.DRed;
    requirement invariant .Lock.DownstreamStormFlood.EastGate.Actuator.c_close needs Lock.BTL.DRed;
    requirement invariant .Lock.DownstreamStormFlood.WestGate.Actuator.c_close needs Lock.BTL.DRed;
    requirement invariant .Bridge.Barriers.B3.Actuator.c_close needs Bridge.LTSS.On;
    requirement invariant .Bridge.Barriers.B3.Actuator.c_close needs Bridge.LTSS.On15Timer.Finished;
    requirement invariant .Bridge.Barriers.B6.Actuator.c_close needs Bridge.LTSS.On;
    requirement invariant .Bridge.Barriers.B6.Actuator.c_close needs Bridge.LTSS.On15Timer.Finished;
  end
  group Requirement4:
    requirement invariant .Lock.LTL.DE.Actuator.c_g needs Bridge.Deck.Open or Bridge.Deck.Closed;
    requirement invariant .Lock.LTL.DW.Actuator.c_g needs Bridge.Deck.Open or Bridge.Deck.Closed;
    requirement invariant .Lock.DownstreamEbb.EastGate.Actuator.c_open needs Lock.UpstreamEbb.Closed or Lock.UpstreamFlood.Closed;
    requirement invariant .Lock.DownstreamEbb.WestGate.Actuator.c_open needs Lock.UpstreamEbb.Closed or Lock.UpstreamFlood.Closed;
    requirement invariant .Lock.DownstreamFlood.EastGate.Actuator.c_open needs Lock.UpstreamEbb.Closed or Lock.UpstreamFlood.Closed;
    requirement invariant .Lock.DownstreamFlood.WestGate.Actuator.c_open needs Lock.UpstreamEbb.Closed or Lock.UpstreamFlood.Closed;
    requirement invariant .Lock.DownstreamStormFlood.EastGate.Actuator.c_open needs Lock.UpstreamEbb.Closed or Lock.UpstreamFlood.Closed;
    requirement invariant .Lock.DownstreamStormFlood.WestGate.Actuator.c_open needs Lock.UpstreamEbb.Closed or Lock.UpstreamFlood.Closed;
    requirement invariant .Lock.UpstreamEbb.EastGate.Actuator.c_open needs Lock.DownstreamEbb.Closed or Lock.DownstreamFlood.Closed or Lock.DownstreamStormFlood.Closed;
    requirement invariant .Lock.UpstreamEbb.WestGate.Actuator.c_open needs Lock.DownstreamEbb.Closed or Lock.DownstreamFlood.Closed or Lock.DownstreamStormFlood.Closed;
    requirement invariant .Lock.UpstreamFlood.EastGate.Actuator.c_open needs Lock.DownstreamEbb.Closed or Lock.DownstreamFlood.Closed or Lock.DownstreamStormFlood.Closed;
    requirement invariant .Lock.UpstreamFlood.WestGate.Actuator.c_open needs Lock.DownstreamEbb.Closed or Lock.DownstreamFlood.Closed or Lock.DownstreamStormFlood.Closed;
    requirement invariant .Lock.DownstreamEbb.EastGate.Actuator.c_open needs Lock.EqualWaterDownstream.On;
    requirement invariant .Lock.DownstreamEbb.WestGate.Actuator.c_open needs Lock.EqualWaterDownstream.On;
    requirement invariant .Lock.DownstreamFlood.EastGate.Actuator.c_open needs Lock.EqualWaterDownstream.On;
    requirement invariant .Lock.DownstreamFlood.WestGate.Actuator.c_open needs Lock.EqualWaterDownstream.On;
    requirement invariant .Lock.DownstreamStormFlood.EastGate.Actuator.c_open needs Lock.EqualWaterDownstream.On;
    requirement invariant .Lock.DownstreamStormFlood.WestGate.Actuator.c_open needs Lock.EqualWaterDownstream.On;
    requirement invariant .Lock.UpstreamEbb.EastGate.Actuator.c_open needs Lock.EqualWaterUpstream.On;
    requirement invariant .Lock.UpstreamEbb.WestGate.Actuator.c_open needs Lock.EqualWaterUpstream.On;
    requirement invariant .Lock.UpstreamFlood.EastGate.Actuator.c_open needs Lock.EqualWaterUpstream.On;
    requirement invariant .Lock.UpstreamFlood.WestGate.Actuator.c_open needs Lock.EqualWaterUpstream.On;
    requirement invariant .Bridge.Barriers.B2.Actuator.c_close needs Bridge.Barriers.B3.Closed;
    requirement invariant .Bridge.Barriers.B2.Actuator.c_close needs Bridge.Barriers.B6.Closed;
    requirement invariant .Bridge.Barriers.B2.Actuator.c_close needs Bridge.Barriers.B3B6Closed1Timer.Finished;
    requirement invariant .Bridge.Barriers.B7.Actuator.c_close needs Bridge.Barriers.B3.Closed;
    requirement invariant .Bridge.Barriers.B7.Actuator.c_close needs Bridge.Barriers.B6.Closed;
    requirement invariant .Bridge.Barriers.B7.Actuator.c_close needs Bridge.Barriers.B3B6Closed1Timer.Finished;
  end
  group Requirement5:
    requirement invariant .Lock.DownstreamEbb.EastPaddle.Actuator.c_open needs Lock.UpstreamEbb.Closed or Lock.UpstreamFlood.Closed;
    requirement invariant .Lock.DownstreamEbb.WestPaddle.Actuator.c_open needs Lock.UpstreamEbb.Closed or Lock.UpstreamFlood.Closed;
    requirement invariant .Lock.DownstreamFlood.EastPaddle.Actuator.c_open needs Lock.UpstreamEbb.Closed or Lock.UpstreamFlood.Closed;
    requirement invariant .Lock.DownstreamFlood.WestPaddle.Actuator.c_open needs Lock.UpstreamEbb.Closed or Lock.UpstreamFlood.Closed;
    requirement invariant .Lock.DownstreamStormFlood.EastPaddle.Actuator.c_open needs Lock.UpstreamEbb.Closed or Lock.UpstreamFlood.Closed;
    requirement invariant .Lock.DownstreamStormFlood.WestPaddle.Actuator.c_open needs Lock.UpstreamEbb.Closed or Lock.UpstreamFlood.Closed;
    requirement invariant .Lock.UpstreamEbb.EastPaddle.Actuator.c_open needs Lock.DownstreamEbb.Closed or Lock.DownstreamFlood.Closed or Lock.DownstreamStormFlood.Closed;
    requirement invariant .Lock.UpstreamEbb.WestPaddle.Actuator.c_open needs Lock.DownstreamEbb.Closed or Lock.DownstreamFlood.Closed or Lock.DownstreamStormFlood.Closed;
    requirement invariant .Lock.UpstreamFlood.EastPaddle.Actuator.c_open needs Lock.DownstreamEbb.Closed or Lock.DownstreamFlood.Closed or Lock.DownstreamStormFlood.Closed;
    requirement invariant .Lock.UpstreamFlood.WestPaddle.Actuator.c_open needs Lock.DownstreamEbb.Closed or Lock.DownstreamFlood.Closed or Lock.DownstreamStormFlood.Closed;
    requirement invariant .Bridge.Barriers.B1.Actuator.c_close needs Bridge.Barriers.B2.Closed;
    requirement invariant .Bridge.Barriers.B1.Actuator.c_close needs Bridge.Barriers.B7.Closed;
    requirement invariant .Bridge.Barriers.B4.Actuator.c_close needs Bridge.Barriers.B2.Closed;
    requirement invariant .Bridge.Barriers.B4.Actuator.c_close needs Bridge.Barriers.B7.Closed;
    requirement invariant .Bridge.Barriers.B5.Actuator.c_close needs Bridge.Barriers.B2.Closed;
    requirement invariant .Bridge.Barriers.B5.Actuator.c_close needs Bridge.Barriers.B7.Closed;
    requirement invariant .Bridge.Barriers.B8.Actuator.c_close needs Bridge.Barriers.B2.Closed;
    requirement invariant .Bridge.Barriers.B8.Actuator.c_close needs Bridge.Barriers.B7.Closed;
  end
  group requirement6:
    requirement invariant Lock.DownstreamEbb.EastGate.Closed or Lock.DownstreamEbb.EastPaddle.Open;
    requirement invariant Lock.DownstreamEbb.WestGate.Closed or Lock.DownstreamEbb.WestPaddle.Open;
    requirement invariant Lock.DownstreamFlood.EastGate.Closed or Lock.DownstreamFlood.EastPaddle.Open;
    requirement invariant Lock.DownstreamFlood.WestGate.Closed or Lock.DownstreamFlood.WestPaddle.Open;
    requirement invariant Lock.DownstreamStormFlood.EastGate.Closed or Lock.DownstreamStormFlood.EastPaddle.Open;
    requirement invariant Lock.DownstreamStormFlood.WestGate.Closed or Lock.DownstreamStormFlood.WestPaddle.Open;
    requirement invariant Lock.UpstreamEbb.EastGate.Closed or Lock.UpstreamEbb.EastPaddle.Open;
    requirement invariant Lock.UpstreamEbb.WestGate.Closed or Lock.UpstreamEbb.WestPaddle.Open;
    requirement invariant Lock.UpstreamFlood.EastGate.Closed or Lock.UpstreamFlood.EastPaddle.Open;
    requirement invariant Lock.UpstreamFlood.WestGate.Closed or Lock.UpstreamFlood.WestPaddle.Open;
  end
  group requirement7:
    group LTL:
      requirement invariant .Lock.LTL.DE.Actuator.c_emerg needs Lock.EmergencyStop.Activated;
      requirement invariant .Lock.LTL.DW.Actuator.c_emerg needs Lock.EmergencyStop.Activated;
      requirement invariant .Lock.LTL.UE.Actuator.c_emerg needs Lock.EmergencyStop.Activated;
      requirement invariant .Lock.LTL.UW.Actuator.c_emerg needs Lock.EmergencyStop.Activated;
      requirement invariant .Lock.LTL.DE.Actuator.c_r needs Lock.EmergencyStop.Deactivated;
      requirement invariant .Lock.LTL.DE.Actuator.c_rg needs Lock.EmergencyStop.Deactivated;
      requirement invariant .Lock.LTL.DE.Actuator.c_g needs Lock.EmergencyStop.Deactivated;
      requirement invariant .Lock.LTL.DE.Actuator.c_rr needs Lock.EmergencyStop.Deactivated;
      requirement invariant .Lock.LTL.DW.Actuator.c_r needs Lock.EmergencyStop.Deactivated;
      requirement invariant .Lock.LTL.DW.Actuator.c_rg needs Lock.EmergencyStop.Deactivated;
      requirement invariant .Lock.LTL.DW.Actuator.c_g needs Lock.EmergencyStop.Deactivated;
      requirement invariant .Lock.LTL.DW.Actuator.c_rr needs Lock.EmergencyStop.Deactivated;
      requirement invariant .Lock.LTL.UE.Actuator.c_r needs Lock.EmergencyStop.Deactivated;
      requirement invariant .Lock.LTL.UE.Actuator.c_rg needs Lock.EmergencyStop.Deactivated;
      requirement invariant .Lock.LTL.UE.Actuator.c_g needs Lock.EmergencyStop.Deactivated;
      requirement invariant .Lock.LTL.UE.Actuator.c_rr needs Lock.EmergencyStop.Deactivated;
      requirement invariant .Lock.LTL.UW.Actuator.c_r needs Lock.EmergencyStop.Deactivated;
      requirement invariant .Lock.LTL.UW.Actuator.c_rg needs Lock.EmergencyStop.Deactivated;
      requirement invariant .Lock.LTL.UW.Actuator.c_g needs Lock.EmergencyStop.Deactivated;
      requirement invariant .Lock.LTL.UW.Actuator.c_rr needs Lock.EmergencyStop.Deactivated;
    end
    group BTL:
      requirement invariant .Lock.BTL.DE.Actuator.c_emerg needs Lock.EmergencyStop.Activated;
      requirement invariant .Lock.BTL.DW.Actuator.c_emerg needs Lock.EmergencyStop.Activated;
      requirement invariant .Lock.BTL.DE.Actuator.c_r needs Lock.EmergencyStop.Deactivated;
      requirement invariant .Lock.BTL.DE.Actuator.c_rg needs Lock.EmergencyStop.Deactivated;
      requirement invariant .Lock.BTL.DE.Actuator.c_g needs Lock.EmergencyStop.Deactivated;
      requirement invariant .Lock.BTL.DW.Actuator.c_r needs Lock.EmergencyStop.Deactivated;
      requirement invariant .Lock.BTL.DW.Actuator.c_rg needs Lock.EmergencyStop.Deactivated;
      requirement invariant .Lock.BTL.DW.Actuator.c_g needs Lock.EmergencyStop.Deactivated;
    end
  end
  group requirement8and10:
    group Gates:
      group UpstreamEbbGateEast:
        requirement invariant .Lock.UpstreamEbb.EastGate.Actuator.c_emrgStop needs Lock.UI.UEbbGate.Stop or Lock.EmergencyStop.Activated;
        requirement invariant .Lock.UpstreamEbb.EastGate.Actuator.c_open needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.UpstreamEbb.EastGate.Actuator.c_close needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.UpstreamEbb.EastGate.Actuator.c_open needs Lock.UI.UEbbGate.Open;
        requirement invariant .Lock.UpstreamEbb.EastGate.Actuator.c_close needs Lock.UI.UEbbGate.Close;
      end
      group UpstreamEbbGateWest:
        requirement invariant .Lock.UpstreamEbb.WestGate.Actuator.c_emrgStop needs Lock.UI.UEbbGate.Stop or Lock.EmergencyStop.Activated;
        requirement invariant .Lock.UpstreamEbb.WestGate.Actuator.c_open needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.UpstreamEbb.WestGate.Actuator.c_close needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.UpstreamEbb.WestGate.Actuator.c_open needs Lock.UI.UEbbGate.Open;
        requirement invariant .Lock.UpstreamEbb.WestGate.Actuator.c_close needs Lock.UI.UEbbGate.Close;
      end
      group UpstreamFloodGateEast:
        requirement invariant .Lock.UpstreamFlood.EastGate.Actuator.c_emrgStop needs Lock.UI.UFloodGate.Stop or Lock.EmergencyStop.Activated;
        requirement invariant .Lock.UpstreamFlood.EastGate.Actuator.c_open needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.UpstreamFlood.EastGate.Actuator.c_close needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.UpstreamFlood.EastGate.Actuator.c_open needs Lock.UI.UFloodGate.Open;
        requirement invariant .Lock.UpstreamFlood.EastGate.Actuator.c_close needs Lock.UI.UFloodGate.Close;
      end
      group UpstreamFloodGateWest:
        requirement invariant .Lock.UpstreamFlood.WestGate.Actuator.c_emrgStop needs Lock.UI.UFloodGate.Stop or Lock.EmergencyStop.Activated;
        requirement invariant .Lock.UpstreamFlood.WestGate.Actuator.c_open needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.UpstreamFlood.WestGate.Actuator.c_close needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.UpstreamFlood.WestGate.Actuator.c_open needs Lock.UI.UFloodGate.Open;
        requirement invariant .Lock.UpstreamFlood.WestGate.Actuator.c_close needs Lock.UI.UFloodGate.Close;
      end
      group DownstreamEbbGateEast:
        requirement invariant .Lock.DownstreamEbb.EastGate.Actuator.c_emrgStop needs Lock.UI.DEbbGate.Stop or Lock.EmergencyStop.Activated;
        requirement invariant .Lock.DownstreamEbb.EastGate.Actuator.c_open needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.DownstreamEbb.EastGate.Actuator.c_close needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.DownstreamEbb.EastGate.Actuator.c_open needs Lock.UI.DEbbGate.Open;
        requirement invariant .Lock.DownstreamEbb.EastGate.Actuator.c_close needs Lock.UI.DEbbGate.Close;
      end
      group DownstreamEbbGateWest:
        requirement invariant .Lock.DownstreamEbb.WestGate.Actuator.c_emrgStop needs Lock.UI.DEbbGate.Stop or Lock.EmergencyStop.Activated;
        requirement invariant .Lock.DownstreamEbb.WestGate.Actuator.c_open needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.DownstreamEbb.WestGate.Actuator.c_close needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.DownstreamEbb.WestGate.Actuator.c_open needs Lock.UI.DEbbGate.Open;
        requirement invariant .Lock.DownstreamEbb.WestGate.Actuator.c_close needs Lock.UI.DEbbGate.Close;
      end
      group DownstreamFloodGateEast:
        requirement invariant .Lock.DownstreamFlood.EastGate.Actuator.c_emrgStop needs Lock.UI.DFloodGate.Stop or Lock.EmergencyStop.Activated;
        requirement invariant .Lock.DownstreamFlood.EastGate.Actuator.c_open needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.DownstreamFlood.EastGate.Actuator.c_close needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.DownstreamFlood.EastGate.Actuator.c_open needs Lock.UI.DFloodGate.Open;
        requirement invariant .Lock.DownstreamFlood.EastGate.Actuator.c_close needs Lock.UI.DFloodGate.Close;
      end
      group DownstreamFloodGateWest:
        requirement invariant .Lock.DownstreamFlood.WestGate.Actuator.c_emrgStop needs Lock.UI.DFloodGate.Stop or Lock.EmergencyStop.Activated;
        requirement invariant .Lock.DownstreamFlood.WestGate.Actuator.c_open needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.DownstreamFlood.WestGate.Actuator.c_close needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.DownstreamFlood.WestGate.Actuator.c_open needs Lock.UI.DFloodGate.Open;
        requirement invariant .Lock.DownstreamFlood.WestGate.Actuator.c_close needs Lock.UI.DFloodGate.Close;
      end
      group DownstreamStormFloodGateEast:
        requirement invariant .Lock.DownstreamStormFlood.EastGate.Actuator.c_emrgStop needs Lock.UI.DStormFloodGate.Stop or Lock.EmergencyStop.Activated;
        requirement invariant .Lock.DownstreamStormFlood.EastGate.Actuator.c_open needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.DownstreamStormFlood.EastGate.Actuator.c_close needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.DownstreamStormFlood.EastGate.Actuator.c_open needs Lock.UI.DStormFloodGate.Open;
        requirement invariant .Lock.DownstreamStormFlood.EastGate.Actuator.c_close needs Lock.UI.DStormFloodGate.Close;
      end
      group DownstreamStormFloodGateWest:
        requirement invariant .Lock.DownstreamStormFlood.WestGate.Actuator.c_emrgStop needs Lock.UI.DStormFloodGate.Stop or Lock.EmergencyStop.Activated;
        requirement invariant .Lock.DownstreamStormFlood.WestGate.Actuator.c_open needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.DownstreamStormFlood.WestGate.Actuator.c_close needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.DownstreamStormFlood.WestGate.Actuator.c_open needs Lock.UI.DStormFloodGate.Open;
        requirement invariant .Lock.DownstreamStormFlood.WestGate.Actuator.c_close needs Lock.UI.DStormFloodGate.Close;
      end
    end
    group Paddles:
      group UpstreamEbbPaddleEast:
        requirement invariant .Lock.UpstreamEbb.EastPaddle.Actuator.c_emrgStop needs Lock.UI.UEbbPaddle.Stop or Lock.EmergencyStop.Activated;
        requirement invariant .Lock.UpstreamEbb.EastPaddle.Actuator.c_open needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.UpstreamEbb.EastPaddle.Actuator.c_close needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.UpstreamEbb.EastPaddle.Actuator.c_open needs Lock.UI.UEbbPaddle.Open;
        requirement invariant .Lock.UpstreamEbb.EastPaddle.Actuator.c_close needs Lock.UI.UEbbPaddle.Close;
      end
      group UpstreamEbbPaddleWest:
        requirement invariant .Lock.UpstreamEbb.WestPaddle.Actuator.c_emrgStop needs Lock.UI.UEbbPaddle.Stop or Lock.EmergencyStop.Activated;
        requirement invariant .Lock.UpstreamEbb.WestPaddle.Actuator.c_open needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.UpstreamEbb.WestPaddle.Actuator.c_close needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.UpstreamEbb.WestPaddle.Actuator.c_open needs Lock.UI.UEbbPaddle.Open;
        requirement invariant .Lock.UpstreamEbb.WestPaddle.Actuator.c_close needs Lock.UI.UEbbPaddle.Close;
      end
      group UpstreamFloodPaddleEast:
        requirement invariant .Lock.UpstreamFlood.EastPaddle.Actuator.c_emrgStop needs Lock.UI.UFloodPaddle.Stop or Lock.EmergencyStop.Activated;
        requirement invariant .Lock.UpstreamFlood.EastPaddle.Actuator.c_open needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.UpstreamFlood.EastPaddle.Actuator.c_close needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.UpstreamFlood.EastPaddle.Actuator.c_open needs Lock.UI.UFloodPaddle.Open;
        requirement invariant .Lock.UpstreamFlood.EastPaddle.Actuator.c_close needs Lock.UI.UFloodPaddle.Close;
      end
      group UpstreamFloodPaddleWest:
        requirement invariant .Lock.UpstreamFlood.WestPaddle.Actuator.c_emrgStop needs Lock.UI.UFloodPaddle.Stop or Lock.EmergencyStop.Activated;
        requirement invariant .Lock.UpstreamFlood.WestPaddle.Actuator.c_open needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.UpstreamFlood.WestPaddle.Actuator.c_close needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.UpstreamFlood.WestPaddle.Actuator.c_open needs Lock.UI.UFloodPaddle.Open;
        requirement invariant .Lock.UpstreamFlood.WestPaddle.Actuator.c_close needs Lock.UI.UFloodPaddle.Close;
      end
      group DownstreamEbbPaddleEast:
        requirement invariant .Lock.DownstreamEbb.EastPaddle.Actuator.c_emrgStop needs Lock.UI.DEbbPaddle.Stop or Lock.EmergencyStop.Activated;
        requirement invariant .Lock.DownstreamEbb.EastPaddle.Actuator.c_open needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.DownstreamEbb.EastPaddle.Actuator.c_close needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.DownstreamEbb.EastPaddle.Actuator.c_open needs Lock.UI.DEbbPaddle.Open;
        requirement invariant .Lock.DownstreamEbb.EastPaddle.Actuator.c_close needs Lock.UI.DEbbPaddle.Close;
      end
      group DownstreamEbbPaddleWest:
        requirement invariant .Lock.DownstreamEbb.WestPaddle.Actuator.c_emrgStop needs Lock.UI.DEbbPaddle.Stop or Lock.EmergencyStop.Activated;
        requirement invariant .Lock.DownstreamEbb.WestPaddle.Actuator.c_open needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.DownstreamEbb.WestPaddle.Actuator.c_close needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.DownstreamEbb.WestPaddle.Actuator.c_open needs Lock.UI.DEbbPaddle.Open;
        requirement invariant .Lock.DownstreamEbb.WestPaddle.Actuator.c_close needs Lock.UI.DEbbPaddle.Close;
      end
      group DownstreamFloodPaddleEast:
        requirement invariant .Lock.DownstreamFlood.EastPaddle.Actuator.c_emrgStop needs Lock.UI.DFloodPaddle.Stop or Lock.EmergencyStop.Activated;
        requirement invariant .Lock.DownstreamFlood.EastPaddle.Actuator.c_open needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.DownstreamFlood.EastPaddle.Actuator.c_close needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.DownstreamFlood.EastPaddle.Actuator.c_open needs Lock.UI.DFloodPaddle.Open;
        requirement invariant .Lock.DownstreamFlood.EastPaddle.Actuator.c_close needs Lock.UI.DFloodPaddle.Close;
      end
      group DownstreamFloodPaddleWest:
        requirement invariant .Lock.DownstreamFlood.WestPaddle.Actuator.c_emrgStop needs Lock.UI.DFloodPaddle.Stop or Lock.EmergencyStop.Activated;
        requirement invariant .Lock.DownstreamFlood.WestPaddle.Actuator.c_open needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.DownstreamFlood.WestPaddle.Actuator.c_close needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.DownstreamFlood.WestPaddle.Actuator.c_open needs Lock.UI.DFloodPaddle.Open;
        requirement invariant .Lock.DownstreamFlood.WestPaddle.Actuator.c_close needs Lock.UI.DFloodPaddle.Close;
      end
      group DownstreamStormFloodPaddleEast:
        requirement invariant .Lock.DownstreamStormFlood.EastPaddle.Actuator.c_emrgStop needs Lock.UI.DStormFloodPaddle.Stop or Lock.EmergencyStop.Activated;
        requirement invariant .Lock.DownstreamStormFlood.EastPaddle.Actuator.c_open needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.DownstreamStormFlood.EastPaddle.Actuator.c_close needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.DownstreamStormFlood.EastPaddle.Actuator.c_open needs Lock.UI.DStormFloodPaddle.Open;
        requirement invariant .Lock.DownstreamStormFlood.EastPaddle.Actuator.c_close needs Lock.UI.DStormFloodPaddle.Close;
      end
      group DownstreamStormFloodPaddleWest:
        requirement invariant .Lock.DownstreamStormFlood.WestPaddle.Actuator.c_emrgStop needs Lock.UI.DStormFloodPaddle.Stop or Lock.EmergencyStop.Activated;
        requirement invariant .Lock.DownstreamStormFlood.WestPaddle.Actuator.c_open needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.DownstreamStormFlood.WestPaddle.Actuator.c_close needs Lock.EmergencyStop.Deactivated;
        requirement invariant .Lock.DownstreamStormFlood.WestPaddle.Actuator.c_open needs Lock.UI.DStormFloodPaddle.Open;
        requirement invariant .Lock.DownstreamStormFlood.WestPaddle.Actuator.c_close needs Lock.UI.DStormFloodPaddle.Close;
      end
    end
  end
  group requirement9:
  end
  group requirement11:
    group IncomingDE:
      requirement invariant .Lock.LTL.DE.Actuator.c_r needs Lock.UI.DLockTrafficLight.Red;
      requirement invariant .Lock.LTL.DE.Actuator.c_rg needs Lock.UI.DLockTrafficLight.RedGreen;
      requirement invariant .Lock.LTL.DE.Actuator.c_g needs Lock.UI.DLockTrafficLight.Green;
      requirement invariant .Lock.LTL.DE.Actuator.c_rr needs Lock.UI.DLockTrafficLight.RedRed;
    end
    group IncomingDW:
      requirement invariant .Lock.LTL.DW.Actuator.c_r needs Lock.UI.DLockTrafficLight.Red;
      requirement invariant .Lock.LTL.DW.Actuator.c_rg needs Lock.UI.DLockTrafficLight.RedGreen;
      requirement invariant .Lock.LTL.DW.Actuator.c_g needs Lock.UI.DLockTrafficLight.Green;
      requirement invariant .Lock.LTL.DW.Actuator.c_rr needs Lock.UI.DLockTrafficLight.RedRed;
    end
    group IncomingUE:
      requirement invariant .Lock.LTL.UE.Actuator.c_r needs Lock.UI.ULockTrafficLight.Red;
      requirement invariant .Lock.LTL.UE.Actuator.c_rg needs Lock.UI.ULockTrafficLight.RedGreen;
      requirement invariant .Lock.LTL.UE.Actuator.c_g needs Lock.UI.ULockTrafficLight.Green;
      requirement invariant .Lock.LTL.UE.Actuator.c_rr needs Lock.UI.ULockTrafficLight.RedRed;
    end
    group IncomingUW:
      requirement invariant .Lock.LTL.UW.Actuator.c_r needs Lock.UI.ULockTrafficLight.Red;
      requirement invariant .Lock.LTL.UW.Actuator.c_rg needs Lock.UI.ULockTrafficLight.RedGreen;
      requirement invariant .Lock.LTL.UW.Actuator.c_g needs Lock.UI.ULockTrafficLight.Green;
      requirement invariant .Lock.LTL.UW.Actuator.c_rr needs Lock.UI.ULockTrafficLight.RedRed;
    end
    group BridgeUE:
      requirement invariant .Lock.BTL.DE.Actuator.c_r needs Lock.UI.DBridgeTraffigLight.Red;
      requirement invariant .Lock.BTL.DE.Actuator.c_rg needs Lock.UI.DBridgeTraffigLight.RedGreen;
      requirement invariant .Lock.BTL.DE.Actuator.c_g needs Lock.UI.DBridgeTraffigLight.Green;
    end
    group BridgeUW:
      requirement invariant .Lock.BTL.DW.Actuator.c_r needs Lock.UI.DBridgeTraffigLight.Red;
      requirement invariant .Lock.BTL.DW.Actuator.c_rg needs Lock.UI.DBridgeTraffigLight.RedGreen;
      requirement invariant .Lock.BTL.DW.Actuator.c_g needs Lock.UI.DBridgeTraffigLight.Green;
    end
  end
  group Requirement6:
    requirement invariant .Bridge.Barriers.B4.Actuator.c_close needs Bridge.Barriers.SoundSignals.On;
    requirement invariant .Bridge.Barriers.B4.Actuator.c_close needs Bridge.Barriers.SoundOn6Timer.Finished;
    requirement invariant .Bridge.Barriers.B8.Actuator.c_close needs Bridge.Barriers.SoundSignals.On;
    requirement invariant .Bridge.Barriers.B8.Actuator.c_close needs Bridge.Barriers.SoundOn6Timer.Finished;
  end
  group Requirement7:
    requirement invariant .Bridge.Deck.Actuator.c_open needs Bridge.Barriers.Closed;
  end
  group Requirement8:
    requirement invariant .Bridge.Barriers.B1.Actuator.c_open needs Bridge.Deck.Closed;
    requirement invariant .Bridge.Barriers.B2.Actuator.c_open needs Bridge.Deck.Closed;
    requirement invariant .Bridge.Barriers.B3.Actuator.c_open needs Bridge.Deck.Closed;
    requirement invariant .Bridge.Barriers.B4.Actuator.c_open needs Bridge.Deck.Closed;
    requirement invariant .Bridge.Barriers.B5.Actuator.c_open needs Bridge.Deck.Closed;
    requirement invariant .Bridge.Barriers.B6.Actuator.c_open needs Bridge.Deck.Closed;
    requirement invariant .Bridge.Barriers.B7.Actuator.c_open needs Bridge.Deck.Closed;
    requirement invariant .Bridge.Barriers.B8.Actuator.c_open needs Bridge.Deck.Closed;
  end
  group Requirement9:
    requirement invariant .Bridge.Barriers.B3.Actuator.c_open needs Bridge.Barriers.B2.Open;
    requirement invariant .Bridge.Barriers.B3.Actuator.c_open needs Bridge.Barriers.B7.Open;
    requirement invariant .Bridge.Barriers.B3.Actuator.c_open needs Bridge.Barriers.B2B7Open1Timer.Finished;
    requirement invariant .Bridge.Barriers.B6.Actuator.c_open needs Bridge.Barriers.B2.Open;
    requirement invariant .Bridge.Barriers.B6.Actuator.c_open needs Bridge.Barriers.B7.Open;
    requirement invariant .Bridge.Barriers.B6.Actuator.c_open needs Bridge.Barriers.B2B7Open1Timer.Finished;
  end
  group Requirement10:
    requirement invariant .Bridge.LTSS.MainLaneActuator.c_off needs Bridge.Barriers.Open;
    requirement invariant .Bridge.LTSS.SwitchLaneActuator.c_off needs Bridge.Barriers.Open;
    requirement invariant .Bridge.Barriers.LightSignals.c_off needs Bridge.Barriers.Open;
  end
  group Requirement11:
    requirement invariant .Bridge.LTAS.NearActuator.c_off needs Bridge.LTSS.Off;
    requirement invariant .Bridge.LTAS.NearActuator.c_off needs Bridge.LTSS.Off60Timer.Finished;
  end
  group Requirement12:
    requirement invariant .Bridge.LTAS.FarActuator.c_off needs Bridge.LTAS.NearOff;
    requirement invariant .Bridge.LTAS.FarActuator.c_off needs Bridge.LTAS.NearOff60Timer.Finished;
  end
  group Requirement13:
    requirement invariant .Bridge.Barriers.B1.Actuator.c_close needs Bridge.CloseRequest.Off;
    requirement invariant .Bridge.Barriers.B2.Actuator.c_close needs Bridge.CloseRequest.Off;
    requirement invariant .Bridge.Barriers.B3.Actuator.c_close needs Bridge.CloseRequest.Off;
    requirement invariant .Bridge.Barriers.B4.Actuator.c_close needs Bridge.CloseRequest.Off;
    requirement invariant .Bridge.Barriers.B5.Actuator.c_close needs Bridge.CloseRequest.Off;
    requirement invariant .Bridge.Barriers.B6.Actuator.c_close needs Bridge.CloseRequest.Off;
    requirement invariant .Bridge.Barriers.B7.Actuator.c_close needs Bridge.CloseRequest.Off;
    requirement invariant .Bridge.Barriers.B8.Actuator.c_close needs Bridge.CloseRequest.Off;
    requirement invariant .Bridge.Deck.Actuator.c_open needs Bridge.CloseRequest.Off;
  end
  group Requirement14and16:
    group Barriers:
      group Barrier1:
        requirement invariant .Bridge.Barriers.B1.Actuator.c_emrgStop needs Bridge.UI.Barrier1.Stop or Bridge.EmergencyStop.Activated;
        requirement invariant .Bridge.Barriers.B1.Actuator.c_open needs Bridge.EmergencyStop.Deactivated;
        requirement invariant .Bridge.Barriers.B1.Actuator.c_close needs Bridge.EmergencyStop.Deactivated;
        requirement invariant .Bridge.Barriers.B1.Actuator.c_open needs Bridge.UI.Barrier1.Open;
        requirement invariant .Bridge.Barriers.B1.Actuator.c_close needs Bridge.UI.Barrier1.Close;
      end
      group Barrier2:
        requirement invariant .Bridge.Barriers.B2.Actuator.c_emrgStop needs Bridge.UI.Barrier27.Stop or Bridge.EmergencyStop.Activated;
        requirement invariant .Bridge.Barriers.B2.Actuator.c_open needs Bridge.EmergencyStop.Deactivated;
        requirement invariant .Bridge.Barriers.B2.Actuator.c_close needs Bridge.EmergencyStop.Deactivated;
        requirement invariant .Bridge.Barriers.B2.Actuator.c_open needs Bridge.UI.Barrier27.Open;
        requirement invariant .Bridge.Barriers.B2.Actuator.c_close needs Bridge.UI.Barrier27.Close;
      end
      group Barrier3:
        requirement invariant .Bridge.Barriers.B3.Actuator.c_emrgStop needs Bridge.UI.Barrier36.Stop or Bridge.EmergencyStop.Activated;
        requirement invariant .Bridge.Barriers.B3.Actuator.c_open needs Bridge.EmergencyStop.Deactivated;
        requirement invariant .Bridge.Barriers.B3.Actuator.c_close needs Bridge.EmergencyStop.Deactivated;
        requirement invariant .Bridge.Barriers.B3.Actuator.c_open needs Bridge.UI.Barrier36.Open;
        requirement invariant .Bridge.Barriers.B3.Actuator.c_close needs Bridge.UI.Barrier36.Close;
      end
      group Barrier4:
        requirement invariant .Bridge.Barriers.B4.Actuator.c_emrgStop needs Bridge.UI.Barrier48.Stop or Bridge.EmergencyStop.Activated;
        requirement invariant .Bridge.Barriers.B4.Actuator.c_open needs Bridge.EmergencyStop.Deactivated;
        requirement invariant .Bridge.Barriers.B4.Actuator.c_close needs Bridge.EmergencyStop.Deactivated;
        requirement invariant .Bridge.Barriers.B4.Actuator.c_open needs Bridge.UI.Barrier48.Open;
        requirement invariant .Bridge.Barriers.B4.Actuator.c_close needs Bridge.UI.Barrier48.Close;
      end
      group Barrier5:
        requirement invariant .Bridge.Barriers.B5.Actuator.c_emrgStop needs Bridge.UI.Barrier5.Stop or Bridge.EmergencyStop.Activated;
        requirement invariant .Bridge.Barriers.B5.Actuator.c_open needs Bridge.EmergencyStop.Deactivated;
        requirement invariant .Bridge.Barriers.B5.Actuator.c_close needs Bridge.EmergencyStop.Deactivated;
        requirement invariant .Bridge.Barriers.B5.Actuator.c_open needs Bridge.UI.Barrier5.Open;
        requirement invariant .Bridge.Barriers.B5.Actuator.c_close needs Bridge.UI.Barrier5.Close;
      end
      group Barrier6:
        requirement invariant .Bridge.Barriers.B6.Actuator.c_emrgStop needs Bridge.UI.Barrier36.Stop or Bridge.EmergencyStop.Activated;
        requirement invariant .Bridge.Barriers.B6.Actuator.c_open needs Bridge.EmergencyStop.Deactivated;
        requirement invariant .Bridge.Barriers.B6.Actuator.c_close needs Bridge.EmergencyStop.Deactivated;
        requirement invariant .Bridge.Barriers.B6.Actuator.c_open needs Bridge.UI.Barrier36.Open;
        requirement invariant .Bridge.Barriers.B6.Actuator.c_close needs Bridge.UI.Barrier36.Close;
      end
      group Barrier7:
        requirement invariant .Bridge.Barriers.B7.Actuator.c_emrgStop needs Bridge.UI.Barrier27.Stop or Bridge.EmergencyStop.Activated;
        requirement invariant .Bridge.Barriers.B7.Actuator.c_open needs Bridge.EmergencyStop.Deactivated;
        requirement invariant .Bridge.Barriers.B7.Actuator.c_close needs Bridge.EmergencyStop.Deactivated;
        requirement invariant .Bridge.Barriers.B7.Actuator.c_open needs Bridge.UI.Barrier27.Open;
        requirement invariant .Bridge.Barriers.B7.Actuator.c_close needs Bridge.UI.Barrier27.Close;
      end
      group Barrier8:
        requirement invariant .Bridge.Barriers.B8.Actuator.c_emrgStop needs Bridge.UI.Barrier48.Stop or Bridge.EmergencyStop.Activated;
        requirement invariant .Bridge.Barriers.B8.Actuator.c_open needs Bridge.EmergencyStop.Deactivated;
        requirement invariant .Bridge.Barriers.B8.Actuator.c_close needs Bridge.EmergencyStop.Deactivated;
        requirement invariant .Bridge.Barriers.B8.Actuator.c_open needs Bridge.UI.Barrier48.Open;
        requirement invariant .Bridge.Barriers.B8.Actuator.c_close needs Bridge.UI.Barrier48.Close;
      end
    end
    group BridgeDeck:
      requirement invariant .Bridge.Deck.Actuator.c_emrgStop needs Bridge.UI.Deck.Stop or Bridge.EmergencyStop.Activated;
      requirement invariant .Bridge.Deck.Actuator.c_open needs Bridge.EmergencyStop.Deactivated;
      requirement invariant .Bridge.Deck.Actuator.c_close needs Bridge.EmergencyStop.Deactivated;
      requirement invariant .Bridge.Deck.Actuator.c_open needs Bridge.UI.Deck.Open;
      requirement invariant .Bridge.Deck.Actuator.c_close needs Bridge.UI.Deck.Close;
    end
    requirement invariant .Bridge.LTAS.NearActuator.c_on needs Bridge.UI.LT.Activated;
    requirement invariant .Bridge.LTAS.FarActuator.c_on needs Bridge.UI.LT.Activated;
    requirement invariant .Bridge.LTSS.MainLaneActuator.c_on needs Bridge.UI.LT.Activated;
    requirement invariant .Bridge.LTSS.SwitchLaneActuator.c_on needs Bridge.UI.LT.Activated;
    requirement invariant .Bridge.Barriers.LightSignals.c_on needs Bridge.UI.LT.Activated;
    requirement invariant .Bridge.Barriers.SoundSignals.c_on needs Bridge.UI.LT.Activated;
    requirement invariant .Bridge.LTAS.NearActuator.c_off needs Bridge.UI.LT.Deactivated;
    requirement invariant .Bridge.LTAS.FarActuator.c_off needs Bridge.UI.LT.Deactivated;
    requirement invariant .Bridge.LTSS.MainLaneActuator.c_off needs Bridge.UI.LT.Deactivated;
    requirement invariant .Bridge.LTSS.SwitchLaneActuator.c_off needs Bridge.UI.LT.Deactivated;
    requirement invariant .Bridge.Barriers.LightSignals.c_off needs Bridge.UI.LT.Deactivated;
  end
  group requirement15:
  end
  group Lock:
    group UI:
      plant automaton UEbbGate:
        alg bool InitialOpen = false;
        location Open:
          initial InitialOpen;
          marked InitialOpen;
          edge .Lock.UI.UEbbGate.u_close goto Close;
          edge .Lock.UI.UEbbGate.u_stop goto Stop;
        location Close:
          initial not InitialOpen;
          marked not InitialOpen;
          edge .Lock.UI.UEbbGate.u_open goto Open;
          edge .Lock.UI.UEbbGate.u_stop goto Stop;
        location Stop:
          edge .Lock.UI.UEbbGate.u_close goto Close;
          edge .Lock.UI.UEbbGate.u_open goto Open;
      end
      plant automaton UFloodGate:
        alg bool InitialOpen = false;
        location Open:
          initial InitialOpen;
          marked InitialOpen;
          edge .Lock.UI.UFloodGate.u_close goto Close;
          edge .Lock.UI.UFloodGate.u_stop goto Stop;
        location Close:
          initial not InitialOpen;
          marked not InitialOpen;
          edge .Lock.UI.UFloodGate.u_open goto Open;
          edge .Lock.UI.UFloodGate.u_stop goto Stop;
        location Stop:
          edge .Lock.UI.UFloodGate.u_close goto Close;
          edge .Lock.UI.UFloodGate.u_open goto Open;
      end
      plant automaton DEbbGate:
        alg bool InitialOpen = false;
        location Open:
          initial InitialOpen;
          marked InitialOpen;
          edge .Lock.UI.DEbbGate.u_close goto Close;
          edge .Lock.UI.DEbbGate.u_stop goto Stop;
        location Close:
          initial not InitialOpen;
          marked not InitialOpen;
          edge .Lock.UI.DEbbGate.u_open goto Open;
          edge .Lock.UI.DEbbGate.u_stop goto Stop;
        location Stop:
          edge .Lock.UI.DEbbGate.u_close goto Close;
          edge .Lock.UI.DEbbGate.u_open goto Open;
      end
      plant automaton DFloodGate:
        alg bool InitialOpen = false;
        location Open:
          initial InitialOpen;
          marked InitialOpen;
          edge .Lock.UI.DFloodGate.u_close goto Close;
          edge .Lock.UI.DFloodGate.u_stop goto Stop;
        location Close:
          initial not InitialOpen;
          marked not InitialOpen;
          edge .Lock.UI.DFloodGate.u_open goto Open;
          edge .Lock.UI.DFloodGate.u_stop goto Stop;
        location Stop:
          edge .Lock.UI.DFloodGate.u_close goto Close;
          edge .Lock.UI.DFloodGate.u_open goto Open;
      end
      plant automaton DStormFloodGate:
        alg bool InitialOpen = false;
        location Open:
          initial InitialOpen;
          marked InitialOpen;
          edge .Lock.UI.DStormFloodGate.u_close goto Close;
          edge .Lock.UI.DStormFloodGate.u_stop goto Stop;
        location Close:
          initial not InitialOpen;
          marked not InitialOpen;
          edge .Lock.UI.DStormFloodGate.u_open goto Open;
          edge .Lock.UI.DStormFloodGate.u_stop goto Stop;
        location Stop:
          edge .Lock.UI.DStormFloodGate.u_close goto Close;
          edge .Lock.UI.DStormFloodGate.u_open goto Open;
      end
      plant automaton UEbbPaddle:
        alg bool InitialOpen = false;
        location Open:
          initial InitialOpen;
          marked InitialOpen;
          edge .Lock.UI.UEbbPaddle.u_close goto Close;
          edge .Lock.UI.UEbbPaddle.u_stop goto Stop;
        location Close:
          initial not InitialOpen;
          marked not InitialOpen;
          edge .Lock.UI.UEbbPaddle.u_open goto Open;
          edge .Lock.UI.UEbbPaddle.u_stop goto Stop;
        location Stop:
          edge .Lock.UI.UEbbPaddle.u_close goto Close;
          edge .Lock.UI.UEbbPaddle.u_open goto Open;
      end
      plant automaton UFloodPaddle:
        alg bool InitialOpen = false;
        location Open:
          initial InitialOpen;
          marked InitialOpen;
          edge .Lock.UI.UFloodPaddle.u_close goto Close;
          edge .Lock.UI.UFloodPaddle.u_stop goto Stop;
        location Close:
          initial not InitialOpen;
          marked not InitialOpen;
          edge .Lock.UI.UFloodPaddle.u_open goto Open;
          edge .Lock.UI.UFloodPaddle.u_stop goto Stop;
        location Stop:
          edge .Lock.UI.UFloodPaddle.u_close goto Close;
          edge .Lock.UI.UFloodPaddle.u_open goto Open;
      end
      plant automaton DEbbPaddle:
        alg bool InitialOpen = false;
        location Open:
          initial InitialOpen;
          marked InitialOpen;
          edge .Lock.UI.DEbbPaddle.u_close goto Close;
          edge .Lock.UI.DEbbPaddle.u_stop goto Stop;
        location Close:
          initial not InitialOpen;
          marked not InitialOpen;
          edge .Lock.UI.DEbbPaddle.u_open goto Open;
          edge .Lock.UI.DEbbPaddle.u_stop goto Stop;
        location Stop:
          edge .Lock.UI.DEbbPaddle.u_close goto Close;
          edge .Lock.UI.DEbbPaddle.u_open goto Open;
      end
      plant automaton DFloodPaddle:
        alg bool InitialOpen = false;
        location Open:
          initial InitialOpen;
          marked InitialOpen;
          edge .Lock.UI.DFloodPaddle.u_close goto Close;
          edge .Lock.UI.DFloodPaddle.u_stop goto Stop;
        location Close:
          initial not InitialOpen;
          marked not InitialOpen;
          edge .Lock.UI.DFloodPaddle.u_open goto Open;
          edge .Lock.UI.DFloodPaddle.u_stop goto Stop;
        location Stop:
          edge .Lock.UI.DFloodPaddle.u_close goto Close;
          edge .Lock.UI.DFloodPaddle.u_open goto Open;
      end
      plant automaton DStormFloodPaddle:
        alg bool InitialOpen = false;
        location Open:
          initial InitialOpen;
          marked InitialOpen;
          edge .Lock.UI.DStormFloodPaddle.u_close goto Close;
          edge .Lock.UI.DStormFloodPaddle.u_stop goto Stop;
        location Close:
          initial not InitialOpen;
          marked not InitialOpen;
          edge .Lock.UI.DStormFloodPaddle.u_open goto Open;
          edge .Lock.UI.DStormFloodPaddle.u_stop goto Stop;
        location Stop:
          edge .Lock.UI.DStormFloodPaddle.u_close goto Close;
          edge .Lock.UI.DStormFloodPaddle.u_open goto Open;
      end
      plant automaton DLockTrafficLight:
        location RedRed:
          marked;
          edge .Lock.UI.DLockTrafficLight.u_r goto Red;
        location Red:
          initial;
          marked;
          edge .Lock.UI.DLockTrafficLight.u_rr goto RedRed;
          edge .Lock.UI.DLockTrafficLight.u_rg goto RedGreen;
        location RedGreen:
          edge .Lock.UI.DLockTrafficLight.u_r goto Red;
          edge .Lock.UI.DLockTrafficLight.u_g goto Green;
        location Green:
          edge .Lock.UI.DLockTrafficLight.u_r goto Red;
      end
      plant automaton ULockTrafficLight:
        location RedRed:
          marked;
          edge .Lock.UI.ULockTrafficLight.u_r goto Red;
        location Red:
          initial;
          marked;
          edge .Lock.UI.ULockTrafficLight.u_rr goto RedRed;
          edge .Lock.UI.ULockTrafficLight.u_rg goto RedGreen;
        location RedGreen:
          edge .Lock.UI.ULockTrafficLight.u_r goto Red;
          edge .Lock.UI.ULockTrafficLight.u_g goto Green;
        location Green:
          edge .Lock.UI.ULockTrafficLight.u_r goto Red;
      end
      plant automaton DBridgeTraffigLight:
        location Red:
          initial;
          marked;
          edge .Lock.UI.DBridgeTraffigLight.u_rg goto RedGreen;
        location RedGreen:
          edge .Lock.UI.DBridgeTraffigLight.u_g goto Green;
          edge .Lock.UI.DBridgeTraffigLight.u_r goto Red;
        location Green:
          edge .Lock.UI.DBridgeTraffigLight.u_r goto Red;
      end
    end
    plant automaton EmergencyStop:
      location Deactivated:
        initial;
        marked;
        edge .Lock.EmergencyStop.u_activate goto Activated;
      location Activated:
        edge .Lock.EmergencyStop.u_reset goto Deactivated;
    end
    group LTL:
      alg bool DRed = DE.Red and DW.Red;
      alg bool DRedRed = DE.RedRed and DW.RedRed;
      alg bool URed = UE.Red and UW.Red;
      alg bool URedRed = UE.RedRed and UW.RedRed;
      group DE:
        alg bool RedRed = Actuator.RedRed and SensorR1.On and SensorG.Off and SensorR2.On;
        alg bool Red = Actuator.Red and SensorR1.On and SensorG.Off and SensorR2.Off;
        alg bool RedGreen = Actuator.RedGreen and SensorR1.On and SensorG.On and SensorR2.Off;
        alg bool Green = Actuator.Green and SensorR1.Off and SensorG.On and SensorR2.Off;
        plant automaton Actuator:
          location RedRed:
            marked;
            edge .Lock.LTL.DE.Actuator.c_r, .Lock.LTL.DE.Actuator.c_emerg goto Red;
          location Red:
            initial;
            marked;
            edge .Lock.LTL.DE.Actuator.c_rr goto RedRed;
            edge .Lock.LTL.DE.Actuator.c_rg goto RedGreen;
          location RedGreen:
            edge .Lock.LTL.DE.Actuator.c_r, .Lock.LTL.DE.Actuator.c_emerg goto Red;
            edge .Lock.LTL.DE.Actuator.c_g goto Green;
          location Green:
            edge .Lock.LTL.DE.Actuator.c_r, .Lock.LTL.DE.Actuator.c_emerg goto Red;
        end
        plant automaton SensorR1:
          alg bool InitialLocationOn = true;
          location Off:
            initial not InitialLocationOn;
            marked not InitialLocationOn;
            edge .Lock.LTL.DE.SensorR1.u_on goto On;
          location On:
            initial InitialLocationOn;
            marked InitialLocationOn;
            edge .Lock.LTL.DE.SensorR1.u_off goto Off;
        end
        plant automaton SensorG:
          alg bool InitialLocationOn = false;
          location Off:
            initial not InitialLocationOn;
            marked not InitialLocationOn;
            edge .Lock.LTL.DE.SensorG.u_on goto On;
          location On:
            initial InitialLocationOn;
            marked InitialLocationOn;
            edge .Lock.LTL.DE.SensorG.u_off goto Off;
        end
        plant automaton SensorR2:
          alg bool InitialLocationOn = false;
          location Off:
            initial not InitialLocationOn;
            marked not InitialLocationOn;
            edge .Lock.LTL.DE.SensorR2.u_on goto On;
          location On:
            initial InitialLocationOn;
            marked InitialLocationOn;
            edge .Lock.LTL.DE.SensorR2.u_off goto Off;
        end
        plant automaton DynamicsR1:
          alg bool On = not Actuator.Green;
          alg bool Off = Actuator.Green;
          location:
            initial;
            marked;
            edge .Lock.LTL.DE.SensorR1.u_on when On;
            edge .Lock.LTL.DE.SensorR1.u_off when Off;
        end
        plant automaton DynamicsG:
          alg bool On = Actuator.Green or Actuator.RedGreen;
          alg bool Off = Actuator.Red or Actuator.RedRed;
          location:
            initial;
            marked;
            edge .Lock.LTL.DE.SensorG.u_on when On;
            edge .Lock.LTL.DE.SensorG.u_off when Off;
        end
        plant automaton DynamicsR2:
          alg bool On = Actuator.RedRed;
          alg bool Off = not Actuator.RedRed;
          location:
            initial;
            marked;
            edge .Lock.LTL.DE.SensorR2.u_on when On;
            edge .Lock.LTL.DE.SensorR2.u_off when Off;
        end
      end
      group DW:
        alg bool RedRed = Actuator.RedRed and SensorR1.On and SensorG.Off and SensorR2.On;
        alg bool Red = Actuator.Red and SensorR1.On and SensorG.Off and SensorR2.Off;
        alg bool RedGreen = Actuator.RedGreen and SensorR1.On and SensorG.On and SensorR2.Off;
        alg bool Green = Actuator.Green and SensorR1.Off and SensorG.On and SensorR2.Off;
        plant automaton Actuator:
          location RedRed:
            marked;
            edge .Lock.LTL.DW.Actuator.c_r, .Lock.LTL.DW.Actuator.c_emerg goto Red;
          location Red:
            initial;
            marked;
            edge .Lock.LTL.DW.Actuator.c_rr goto RedRed;
            edge .Lock.LTL.DW.Actuator.c_rg goto RedGreen;
          location RedGreen:
            edge .Lock.LTL.DW.Actuator.c_r, .Lock.LTL.DW.Actuator.c_emerg goto Red;
            edge .Lock.LTL.DW.Actuator.c_g goto Green;
          location Green:
            edge .Lock.LTL.DW.Actuator.c_r, .Lock.LTL.DW.Actuator.c_emerg goto Red;
        end
        plant automaton SensorR1:
          alg bool InitialLocationOn = true;
          location Off:
            initial not InitialLocationOn;
            marked not InitialLocationOn;
            edge .Lock.LTL.DW.SensorR1.u_on goto On;
          location On:
            initial InitialLocationOn;
            marked InitialLocationOn;
            edge .Lock.LTL.DW.SensorR1.u_off goto Off;
        end
        plant automaton SensorG:
          alg bool InitialLocationOn = false;
          location Off:
            initial not InitialLocationOn;
            marked not InitialLocationOn;
            edge .Lock.LTL.DW.SensorG.u_on goto On;
          location On:
            initial InitialLocationOn;
            marked InitialLocationOn;
            edge .Lock.LTL.DW.SensorG.u_off goto Off;
        end
        plant automaton SensorR2:
          alg bool InitialLocationOn = false;
          location Off:
            initial not InitialLocationOn;
            marked not InitialLocationOn;
            edge .Lock.LTL.DW.SensorR2.u_on goto On;
          location On:
            initial InitialLocationOn;
            marked InitialLocationOn;
            edge .Lock.LTL.DW.SensorR2.u_off goto Off;
        end
        plant automaton DynamicsR1:
          alg bool On = not Actuator.Green;
          alg bool Off = Actuator.Green;
          location:
            initial;
            marked;
            edge .Lock.LTL.DW.SensorR1.u_on when On;
            edge .Lock.LTL.DW.SensorR1.u_off when Off;
        end
        plant automaton DynamicsG:
          alg bool On = Actuator.Green or Actuator.RedGreen;
          alg bool Off = Actuator.Red or Actuator.RedRed;
          location:
            initial;
            marked;
            edge .Lock.LTL.DW.SensorG.u_on when On;
            edge .Lock.LTL.DW.SensorG.u_off when Off;
        end
        plant automaton DynamicsR2:
          alg bool On = Actuator.RedRed;
          alg bool Off = not Actuator.RedRed;
          location:
            initial;
            marked;
            edge .Lock.LTL.DW.SensorR2.u_on when On;
            edge .Lock.LTL.DW.SensorR2.u_off when Off;
        end
      end
      group UE:
        alg bool RedRed = Actuator.RedRed and SensorR1.On and SensorG.Off and SensorR2.On;
        alg bool Red = Actuator.Red and SensorR1.On and SensorG.Off and SensorR2.Off;
        alg bool RedGreen = Actuator.RedGreen and SensorR1.On and SensorG.On and SensorR2.Off;
        alg bool Green = Actuator.Green and SensorR1.Off and SensorG.On and SensorR2.Off;
        plant automaton Actuator:
          location RedRed:
            marked;
            edge .Lock.LTL.UE.Actuator.c_r, .Lock.LTL.UE.Actuator.c_emerg goto Red;
          location Red:
            initial;
            marked;
            edge .Lock.LTL.UE.Actuator.c_rr goto RedRed;
            edge .Lock.LTL.UE.Actuator.c_rg goto RedGreen;
          location RedGreen:
            edge .Lock.LTL.UE.Actuator.c_r, .Lock.LTL.UE.Actuator.c_emerg goto Red;
            edge .Lock.LTL.UE.Actuator.c_g goto Green;
          location Green:
            edge .Lock.LTL.UE.Actuator.c_r, .Lock.LTL.UE.Actuator.c_emerg goto Red;
        end
        plant automaton SensorR1:
          alg bool InitialLocationOn = true;
          location Off:
            initial not InitialLocationOn;
            marked not InitialLocationOn;
            edge .Lock.LTL.UE.SensorR1.u_on goto On;
          location On:
            initial InitialLocationOn;
            marked InitialLocationOn;
            edge .Lock.LTL.UE.SensorR1.u_off goto Off;
        end
        plant automaton SensorG:
          alg bool InitialLocationOn = false;
          location Off:
            initial not InitialLocationOn;
            marked not InitialLocationOn;
            edge .Lock.LTL.UE.SensorG.u_on goto On;
          location On:
            initial InitialLocationOn;
            marked InitialLocationOn;
            edge .Lock.LTL.UE.SensorG.u_off goto Off;
        end
        plant automaton SensorR2:
          alg bool InitialLocationOn = false;
          location Off:
            initial not InitialLocationOn;
            marked not InitialLocationOn;
            edge .Lock.LTL.UE.SensorR2.u_on goto On;
          location On:
            initial InitialLocationOn;
            marked InitialLocationOn;
            edge .Lock.LTL.UE.SensorR2.u_off goto Off;
        end
        plant automaton DynamicsR1:
          alg bool On = not Actuator.Green;
          alg bool Off = Actuator.Green;
          location:
            initial;
            marked;
            edge .Lock.LTL.UE.SensorR1.u_on when On;
            edge .Lock.LTL.UE.SensorR1.u_off when Off;
        end
        plant automaton DynamicsG:
          alg bool On = Actuator.Green or Actuator.RedGreen;
          alg bool Off = Actuator.Red or Actuator.RedRed;
          location:
            initial;
            marked;
            edge .Lock.LTL.UE.SensorG.u_on when On;
            edge .Lock.LTL.UE.SensorG.u_off when Off;
        end
        plant automaton DynamicsR2:
          alg bool On = Actuator.RedRed;
          alg bool Off = not Actuator.RedRed;
          location:
            initial;
            marked;
            edge .Lock.LTL.UE.SensorR2.u_on when On;
            edge .Lock.LTL.UE.SensorR2.u_off when Off;
        end
      end
      group UW:
        alg bool RedRed = Actuator.RedRed and SensorR1.On and SensorG.Off and SensorR2.On;
        alg bool Red = Actuator.Red and SensorR1.On and SensorG.Off and SensorR2.Off;
        alg bool RedGreen = Actuator.RedGreen and SensorR1.On and SensorG.On and SensorR2.Off;
        alg bool Green = Actuator.Green and SensorR1.Off and SensorG.On and SensorR2.Off;
        plant automaton Actuator:
          location RedRed:
            marked;
            edge .Lock.LTL.UW.Actuator.c_r, .Lock.LTL.UW.Actuator.c_emerg goto Red;
          location Red:
            initial;
            marked;
            edge .Lock.LTL.UW.Actuator.c_rr goto RedRed;
            edge .Lock.LTL.UW.Actuator.c_rg goto RedGreen;
          location RedGreen:
            edge .Lock.LTL.UW.Actuator.c_r, .Lock.LTL.UW.Actuator.c_emerg goto Red;
            edge .Lock.LTL.UW.Actuator.c_g goto Green;
          location Green:
            edge .Lock.LTL.UW.Actuator.c_r, .Lock.LTL.UW.Actuator.c_emerg goto Red;
        end
        plant automaton SensorR1:
          alg bool InitialLocationOn = true;
          location Off:
            initial not InitialLocationOn;
            marked not InitialLocationOn;
            edge .Lock.LTL.UW.SensorR1.u_on goto On;
          location On:
            initial InitialLocationOn;
            marked InitialLocationOn;
            edge .Lock.LTL.UW.SensorR1.u_off goto Off;
        end
        plant automaton SensorG:
          alg bool InitialLocationOn = false;
          location Off:
            initial not InitialLocationOn;
            marked not InitialLocationOn;
            edge .Lock.LTL.UW.SensorG.u_on goto On;
          location On:
            initial InitialLocationOn;
            marked InitialLocationOn;
            edge .Lock.LTL.UW.SensorG.u_off goto Off;
        end
        plant automaton SensorR2:
          alg bool InitialLocationOn = false;
          location Off:
            initial not InitialLocationOn;
            marked not InitialLocationOn;
            edge .Lock.LTL.UW.SensorR2.u_on goto On;
          location On:
            initial InitialLocationOn;
            marked InitialLocationOn;
            edge .Lock.LTL.UW.SensorR2.u_off goto Off;
        end
        plant automaton DynamicsR1:
          alg bool On = not Actuator.Green;
          alg bool Off = Actuator.Green;
          location:
            initial;
            marked;
            edge .Lock.LTL.UW.SensorR1.u_on when On;
            edge .Lock.LTL.UW.SensorR1.u_off when Off;
        end
        plant automaton DynamicsG:
          alg bool On = Actuator.Green or Actuator.RedGreen;
          alg bool Off = Actuator.Red or Actuator.RedRed;
          location:
            initial;
            marked;
            edge .Lock.LTL.UW.SensorG.u_on when On;
            edge .Lock.LTL.UW.SensorG.u_off when Off;
        end
        plant automaton DynamicsR2:
          alg bool On = Actuator.RedRed;
          alg bool Off = not Actuator.RedRed;
          location:
            initial;
            marked;
            edge .Lock.LTL.UW.SensorR2.u_on when On;
            edge .Lock.LTL.UW.SensorR2.u_off when Off;
        end
      end
    end
    group BTL:
      alg bool DRed = DE.Red and DW.Red;
      group DE:
        alg bool Red = Actuator.Red and SensorR.On and SensorG.Off;
        alg bool RedGreen = Actuator.RedGreen and SensorR.On and SensorG.On;
        alg bool Green = Actuator.Green and SensorR.Off and SensorG.On;
        plant automaton Actuator:
          location Red:
            initial;
            marked;
            edge .Lock.BTL.DE.Actuator.c_rg goto RedGreen;
          location RedGreen:
            edge .Lock.BTL.DE.Actuator.c_r, .Lock.BTL.DE.Actuator.c_emerg goto Red;
            edge .Lock.BTL.DE.Actuator.c_g goto Green;
          location Green:
            edge .Lock.BTL.DE.Actuator.c_r, .Lock.BTL.DE.Actuator.c_emerg goto Red;
        end
        plant automaton SensorR:
          alg bool InitialLocationOn = true;
          location Off:
            initial not InitialLocationOn;
            marked not InitialLocationOn;
            edge .Lock.BTL.DE.SensorR.u_on goto On;
          location On:
            initial InitialLocationOn;
            marked InitialLocationOn;
            edge .Lock.BTL.DE.SensorR.u_off goto Off;
        end
        plant automaton SensorG:
          alg bool InitialLocationOn = false;
          location Off:
            initial not InitialLocationOn;
            marked not InitialLocationOn;
            edge .Lock.BTL.DE.SensorG.u_on goto On;
          location On:
            initial InitialLocationOn;
            marked InitialLocationOn;
            edge .Lock.BTL.DE.SensorG.u_off goto Off;
        end
        plant automaton DynamicsR:
          alg bool On = not Actuator.Green;
          alg bool Off = Actuator.Green;
          location:
            initial;
            marked;
            edge .Lock.BTL.DE.SensorR.u_on when On;
            edge .Lock.BTL.DE.SensorR.u_off when Off;
        end
        plant automaton DynamicsG:
          alg bool On = not Actuator.Red;
          alg bool Off = Actuator.Red;
          location:
            initial;
            marked;
            edge .Lock.BTL.DE.SensorG.u_on when On;
            edge .Lock.BTL.DE.SensorG.u_off when Off;
        end
      end
      group DW:
        alg bool Red = Actuator.Red and SensorR.On and SensorG.Off;
        alg bool RedGreen = Actuator.RedGreen and SensorR.On and SensorG.On;
        alg bool Green = Actuator.Green and SensorR.Off and SensorG.On;
        plant automaton Actuator:
          location Red:
            initial;
            marked;
            edge .Lock.BTL.DW.Actuator.c_rg goto RedGreen;
          location RedGreen:
            edge .Lock.BTL.DW.Actuator.c_r, .Lock.BTL.DW.Actuator.c_emerg goto Red;
            edge .Lock.BTL.DW.Actuator.c_g goto Green;
          location Green:
            edge .Lock.BTL.DW.Actuator.c_r, .Lock.BTL.DW.Actuator.c_emerg goto Red;
        end
        plant automaton SensorR:
          alg bool InitialLocationOn = true;
          location Off:
            initial not InitialLocationOn;
            marked not InitialLocationOn;
            edge .Lock.BTL.DW.SensorR.u_on goto On;
          location On:
            initial InitialLocationOn;
            marked InitialLocationOn;
            edge .Lock.BTL.DW.SensorR.u_off goto Off;
        end
        plant automaton SensorG:
          alg bool InitialLocationOn = false;
          location Off:
            initial not InitialLocationOn;
            marked not InitialLocationOn;
            edge .Lock.BTL.DW.SensorG.u_on goto On;
          location On:
            initial InitialLocationOn;
            marked InitialLocationOn;
            edge .Lock.BTL.DW.SensorG.u_off goto Off;
        end
        plant automaton DynamicsR:
          alg bool On = not Actuator.Green;
          alg bool Off = Actuator.Green;
          location:
            initial;
            marked;
            edge .Lock.BTL.DW.SensorR.u_on when On;
            edge .Lock.BTL.DW.SensorR.u_off when Off;
        end
        plant automaton DynamicsG:
          alg bool On = not Actuator.Red;
          alg bool Off = Actuator.Red;
          location:
            initial;
            marked;
            edge .Lock.BTL.DW.SensorG.u_on when On;
            edge .Lock.BTL.DW.SensorG.u_off when Off;
        end
      end
    end
    group UpstreamEbb:
      alg bool GatesOpen = EastGate.Open and WestGate.Open;
      alg bool GatesClosed = EastGate.Closed and WestGate.Closed;
      alg bool GatesMoving = EastGate.Moving or WestGate.Moving;
      alg bool PaddlesOpen = EastPaddle.Open and WestPaddle.Open;
      alg bool PaddlesClosed = EastPaddle.Closed and WestPaddle.Closed;
      alg bool PaddlesMoving = EastPaddle.Moving or WestPaddle.Moving;
      alg bool Closed = GatesClosed and PaddlesClosed;
      alg bool Moving = GatesMoving or PaddlesMoving;
      group EastGate:
        alg bool Moving = not Actuator.Rest;
        alg bool Closed = Actuator.Rest and Sensor.Closed;
        alg bool Open = Actuator.Rest and Sensor.Open;
        alg bool InitialLocationClosed = true;
        plant automaton Actuator:
          location Rest:
            initial;
            marked;
            edge .Lock.UpstreamEbb.EastGate.Actuator.c_open goto Opening;
            edge .Lock.UpstreamEbb.EastGate.Actuator.c_close goto Closing;
          location Opening:
            edge .Lock.UpstreamEbb.EastGate.Actuator.c_emrgStop, .Lock.UpstreamEbb.EastGate.Actuator.c_endStopOpening goto Rest;
          location Closing:
            edge .Lock.UpstreamEbb.EastGate.Actuator.c_emrgStop, .Lock.UpstreamEbb.EastGate.Actuator.c_endStopClosing goto Rest;
        end
        plant automaton Sensor:
          alg bool InitialLocationClosed = .sup.Lock.UpstreamEbb.EastGate.InitialLocationClosed;
          location Closed:
            initial InitialLocationClosed;
            marked InitialLocationClosed;
            edge .Lock.UpstreamEbb.EastGate.Sensor.u_closed_off goto Intermediate;
          location Intermediate:
            edge .Lock.UpstreamEbb.EastGate.Sensor.u_closed_on goto Closed;
            edge .Lock.UpstreamEbb.EastGate.Sensor.u_open_on goto Open;
          location Open:
            initial not InitialLocationClosed;
            marked not InitialLocationClosed;
            edge .Lock.UpstreamEbb.EastGate.Sensor.u_open_off goto Intermediate;
        end
        plant automaton Dynamics:
          location:
            initial;
            marked;
            edge .Lock.UpstreamEbb.EastGate.Sensor.u_open_on, .Lock.UpstreamEbb.EastGate.Sensor.u_closed_off when Actuator.Opening;
            edge .Lock.UpstreamEbb.EastGate.Sensor.u_closed_on, .Lock.UpstreamEbb.EastGate.Sensor.u_open_off when Actuator.Closing;
        end
        requirement invariant .Lock.UpstreamEbb.EastGate.Actuator.c_endStopOpening needs Sensor.Open;
        requirement invariant .Lock.UpstreamEbb.EastGate.Actuator.c_endStopClosing needs Sensor.Closed;
        requirement invariant .Lock.UpstreamEbb.EastGate.Actuator.c_open needs not Sensor.Open;
        requirement invariant .Lock.UpstreamEbb.EastGate.Actuator.c_close needs not Sensor.Closed;
      end
      group WestGate:
        alg bool Moving = not Actuator.Rest;
        alg bool Closed = Actuator.Rest and Sensor.Closed;
        alg bool Open = Actuator.Rest and Sensor.Open;
        alg bool InitialLocationClosed = true;
        plant automaton Actuator:
          location Rest:
            initial;
            marked;
            edge .Lock.UpstreamEbb.WestGate.Actuator.c_open goto Opening;
            edge .Lock.UpstreamEbb.WestGate.Actuator.c_close goto Closing;
          location Opening:
            edge .Lock.UpstreamEbb.WestGate.Actuator.c_emrgStop, .Lock.UpstreamEbb.WestGate.Actuator.c_endStopOpening goto Rest;
          location Closing:
            edge .Lock.UpstreamEbb.WestGate.Actuator.c_emrgStop, .Lock.UpstreamEbb.WestGate.Actuator.c_endStopClosing goto Rest;
        end
        plant automaton Sensor:
          alg bool InitialLocationClosed = .sup.Lock.UpstreamEbb.WestGate.InitialLocationClosed;
          location Closed:
            initial InitialLocationClosed;
            marked InitialLocationClosed;
            edge .Lock.UpstreamEbb.WestGate.Sensor.u_closed_off goto Intermediate;
          location Intermediate:
            edge .Lock.UpstreamEbb.WestGate.Sensor.u_closed_on goto Closed;
            edge .Lock.UpstreamEbb.WestGate.Sensor.u_open_on goto Open;
          location Open:
            initial not InitialLocationClosed;
            marked not InitialLocationClosed;
            edge .Lock.UpstreamEbb.WestGate.Sensor.u_open_off goto Intermediate;
        end
        plant automaton Dynamics:
          location:
            initial;
            marked;
            edge .Lock.UpstreamEbb.WestGate.Sensor.u_open_on, .Lock.UpstreamEbb.WestGate.Sensor.u_closed_off when Actuator.Opening;
            edge .Lock.UpstreamEbb.WestGate.Sensor.u_closed_on, .Lock.UpstreamEbb.WestGate.Sensor.u_open_off when Actuator.Closing;
        end
        requirement invariant .Lock.UpstreamEbb.WestGate.Actuator.c_endStopOpening needs Sensor.Open;
        requirement invariant .Lock.UpstreamEbb.WestGate.Actuator.c_endStopClosing needs Sensor.Closed;
        requirement invariant .Lock.UpstreamEbb.WestGate.Actuator.c_open needs not Sensor.Open;
        requirement invariant .Lock.UpstreamEbb.WestGate.Actuator.c_close needs not Sensor.Closed;
      end
      group EastPaddle:
        alg bool Moving = not Actuator.Rest;
        alg bool Closed = Actuator.Rest and Sensor.Closed;
        alg bool Open = Actuator.Rest and Sensor.Open;
        alg bool InitialLocationClosed = true;
        plant automaton Actuator:
          location Rest:
            initial;
            marked;
            edge .Lock.UpstreamEbb.EastPaddle.Actuator.c_open goto Opening;
            edge .Lock.UpstreamEbb.EastPaddle.Actuator.c_close goto Closing;
          location Opening:
            edge .Lock.UpstreamEbb.EastPaddle.Actuator.c_emrgStop, .Lock.UpstreamEbb.EastPaddle.Actuator.c_endStopOpening goto Rest;
          location Closing:
            edge .Lock.UpstreamEbb.EastPaddle.Actuator.c_emrgStop, .Lock.UpstreamEbb.EastPaddle.Actuator.c_endStopClosing goto Rest;
        end
        plant automaton Sensor:
          alg bool InitialLocationClosed = .sup.Lock.UpstreamEbb.EastPaddle.InitialLocationClosed;
          location Closed:
            initial InitialLocationClosed;
            marked InitialLocationClosed;
            edge .Lock.UpstreamEbb.EastPaddle.Sensor.u_closed_off goto Intermediate;
          location Intermediate:
            edge .Lock.UpstreamEbb.EastPaddle.Sensor.u_closed_on goto Closed;
            edge .Lock.UpstreamEbb.EastPaddle.Sensor.u_open_on goto Open;
          location Open:
            initial not InitialLocationClosed;
            marked not InitialLocationClosed;
            edge .Lock.UpstreamEbb.EastPaddle.Sensor.u_open_off goto Intermediate;
        end
        plant automaton Dynamics:
          location:
            initial;
            marked;
            edge .Lock.UpstreamEbb.EastPaddle.Sensor.u_open_on, .Lock.UpstreamEbb.EastPaddle.Sensor.u_closed_off when Actuator.Opening;
            edge .Lock.UpstreamEbb.EastPaddle.Sensor.u_closed_on, .Lock.UpstreamEbb.EastPaddle.Sensor.u_open_off when Actuator.Closing;
        end
        requirement invariant .Lock.UpstreamEbb.EastPaddle.Actuator.c_endStopOpening needs Sensor.Open;
        requirement invariant .Lock.UpstreamEbb.EastPaddle.Actuator.c_endStopClosing needs Sensor.Closed;
        requirement invariant .Lock.UpstreamEbb.EastPaddle.Actuator.c_open needs not Sensor.Open;
        requirement invariant .Lock.UpstreamEbb.EastPaddle.Actuator.c_close needs not Sensor.Closed;
      end
      group WestPaddle:
        alg bool Moving = not Actuator.Rest;
        alg bool Closed = Actuator.Rest and Sensor.Closed;
        alg bool Open = Actuator.Rest and Sensor.Open;
        alg bool InitialLocationClosed = true;
        plant automaton Actuator:
          location Rest:
            initial;
            marked;
            edge .Lock.UpstreamEbb.WestPaddle.Actuator.c_open goto Opening;
            edge .Lock.UpstreamEbb.WestPaddle.Actuator.c_close goto Closing;
          location Opening:
            edge .Lock.UpstreamEbb.WestPaddle.Actuator.c_emrgStop, .Lock.UpstreamEbb.WestPaddle.Actuator.c_endStopOpening goto Rest;
          location Closing:
            edge .Lock.UpstreamEbb.WestPaddle.Actuator.c_emrgStop, .Lock.UpstreamEbb.WestPaddle.Actuator.c_endStopClosing goto Rest;
        end
        plant automaton Sensor:
          alg bool InitialLocationClosed = .sup.Lock.UpstreamEbb.WestPaddle.InitialLocationClosed;
          location Closed:
            initial InitialLocationClosed;
            marked InitialLocationClosed;
            edge .Lock.UpstreamEbb.WestPaddle.Sensor.u_closed_off goto Intermediate;
          location Intermediate:
            edge .Lock.UpstreamEbb.WestPaddle.Sensor.u_closed_on goto Closed;
            edge .Lock.UpstreamEbb.WestPaddle.Sensor.u_open_on goto Open;
          location Open:
            initial not InitialLocationClosed;
            marked not InitialLocationClosed;
            edge .Lock.UpstreamEbb.WestPaddle.Sensor.u_open_off goto Intermediate;
        end
        plant automaton Dynamics:
          location:
            initial;
            marked;
            edge .Lock.UpstreamEbb.WestPaddle.Sensor.u_open_on, .Lock.UpstreamEbb.WestPaddle.Sensor.u_closed_off when Actuator.Opening;
            edge .Lock.UpstreamEbb.WestPaddle.Sensor.u_closed_on, .Lock.UpstreamEbb.WestPaddle.Sensor.u_open_off when Actuator.Closing;
        end
        requirement invariant .Lock.UpstreamEbb.WestPaddle.Actuator.c_endStopOpening needs Sensor.Open;
        requirement invariant .Lock.UpstreamEbb.WestPaddle.Actuator.c_endStopClosing needs Sensor.Closed;
        requirement invariant .Lock.UpstreamEbb.WestPaddle.Actuator.c_open needs not Sensor.Open;
        requirement invariant .Lock.UpstreamEbb.WestPaddle.Actuator.c_close needs not Sensor.Closed;
      end
    end
    group UpstreamFlood:
      alg bool GatesOpen = EastGate.Open and WestGate.Open;
      alg bool GatesClosed = EastGate.Closed and WestGate.Closed;
      alg bool GatesMoving = EastGate.Moving or WestGate.Moving;
      alg bool PaddlesOpen = EastPaddle.Open and WestPaddle.Open;
      alg bool PaddlesClosed = EastPaddle.Closed and WestPaddle.Closed;
      alg bool PaddlesMoving = EastPaddle.Moving or WestPaddle.Moving;
      alg bool Closed = GatesClosed and PaddlesClosed;
      alg bool Moving = GatesMoving or PaddlesMoving;
      group EastGate:
        alg bool Moving = not Actuator.Rest;
        alg bool Closed = Actuator.Rest and Sensor.Closed;
        alg bool Open = Actuator.Rest and Sensor.Open;
        alg bool InitialLocationClosed = true;
        plant automaton Actuator:
          location Rest:
            initial;
            marked;
            edge .Lock.UpstreamFlood.EastGate.Actuator.c_open goto Opening;
            edge .Lock.UpstreamFlood.EastGate.Actuator.c_close goto Closing;
          location Opening:
            edge .Lock.UpstreamFlood.EastGate.Actuator.c_emrgStop, .Lock.UpstreamFlood.EastGate.Actuator.c_endStopOpening goto Rest;
          location Closing:
            edge .Lock.UpstreamFlood.EastGate.Actuator.c_emrgStop, .Lock.UpstreamFlood.EastGate.Actuator.c_endStopClosing goto Rest;
        end
        plant automaton Sensor:
          alg bool InitialLocationClosed = .sup.Lock.UpstreamFlood.EastGate.InitialLocationClosed;
          location Closed:
            initial InitialLocationClosed;
            marked InitialLocationClosed;
            edge .Lock.UpstreamFlood.EastGate.Sensor.u_closed_off goto Intermediate;
          location Intermediate:
            edge .Lock.UpstreamFlood.EastGate.Sensor.u_closed_on goto Closed;
            edge .Lock.UpstreamFlood.EastGate.Sensor.u_open_on goto Open;
          location Open:
            initial not InitialLocationClosed;
            marked not InitialLocationClosed;
            edge .Lock.UpstreamFlood.EastGate.Sensor.u_open_off goto Intermediate;
        end
        plant automaton Dynamics:
          location:
            initial;
            marked;
            edge .Lock.UpstreamFlood.EastGate.Sensor.u_open_on, .Lock.UpstreamFlood.EastGate.Sensor.u_closed_off when Actuator.Opening;
            edge .Lock.UpstreamFlood.EastGate.Sensor.u_closed_on, .Lock.UpstreamFlood.EastGate.Sensor.u_open_off when Actuator.Closing;
        end
        requirement invariant .Lock.UpstreamFlood.EastGate.Actuator.c_endStopOpening needs Sensor.Open;
        requirement invariant .Lock.UpstreamFlood.EastGate.Actuator.c_endStopClosing needs Sensor.Closed;
        requirement invariant .Lock.UpstreamFlood.EastGate.Actuator.c_open needs not Sensor.Open;
        requirement invariant .Lock.UpstreamFlood.EastGate.Actuator.c_close needs not Sensor.Closed;
      end
      group WestGate:
        alg bool Moving = not Actuator.Rest;
        alg bool Closed = Actuator.Rest and Sensor.Closed;
        alg bool Open = Actuator.Rest and Sensor.Open;
        alg bool InitialLocationClosed = true;
        plant automaton Actuator:
          location Rest:
            initial;
            marked;
            edge .Lock.UpstreamFlood.WestGate.Actuator.c_open goto Opening;
            edge .Lock.UpstreamFlood.WestGate.Actuator.c_close goto Closing;
          location Opening:
            edge .Lock.UpstreamFlood.WestGate.Actuator.c_emrgStop, .Lock.UpstreamFlood.WestGate.Actuator.c_endStopOpening goto Rest;
          location Closing:
            edge .Lock.UpstreamFlood.WestGate.Actuator.c_emrgStop, .Lock.UpstreamFlood.WestGate.Actuator.c_endStopClosing goto Rest;
        end
        plant automaton Sensor:
          alg bool InitialLocationClosed = .sup.Lock.UpstreamFlood.WestGate.InitialLocationClosed;
          location Closed:
            initial InitialLocationClosed;
            marked InitialLocationClosed;
            edge .Lock.UpstreamFlood.WestGate.Sensor.u_closed_off goto Intermediate;
          location Intermediate:
            edge .Lock.UpstreamFlood.WestGate.Sensor.u_closed_on goto Closed;
            edge .Lock.UpstreamFlood.WestGate.Sensor.u_open_on goto Open;
          location Open:
            initial not InitialLocationClosed;
            marked not InitialLocationClosed;
            edge .Lock.UpstreamFlood.WestGate.Sensor.u_open_off goto Intermediate;
        end
        plant automaton Dynamics:
          location:
            initial;
            marked;
            edge .Lock.UpstreamFlood.WestGate.Sensor.u_open_on, .Lock.UpstreamFlood.WestGate.Sensor.u_closed_off when Actuator.Opening;
            edge .Lock.UpstreamFlood.WestGate.Sensor.u_closed_on, .Lock.UpstreamFlood.WestGate.Sensor.u_open_off when Actuator.Closing;
        end
        requirement invariant .Lock.UpstreamFlood.WestGate.Actuator.c_endStopOpening needs Sensor.Open;
        requirement invariant .Lock.UpstreamFlood.WestGate.Actuator.c_endStopClosing needs Sensor.Closed;
        requirement invariant .Lock.UpstreamFlood.WestGate.Actuator.c_open needs not Sensor.Open;
        requirement invariant .Lock.UpstreamFlood.WestGate.Actuator.c_close needs not Sensor.Closed;
      end
      group EastPaddle:
        alg bool Moving = not Actuator.Rest;
        alg bool Closed = Actuator.Rest and Sensor.Closed;
        alg bool Open = Actuator.Rest and Sensor.Open;
        alg bool InitialLocationClosed = true;
        plant automaton Actuator:
          location Rest:
            initial;
            marked;
            edge .Lock.UpstreamFlood.EastPaddle.Actuator.c_open goto Opening;
            edge .Lock.UpstreamFlood.EastPaddle.Actuator.c_close goto Closing;
          location Opening:
            edge .Lock.UpstreamFlood.EastPaddle.Actuator.c_emrgStop, .Lock.UpstreamFlood.EastPaddle.Actuator.c_endStopOpening goto Rest;
          location Closing:
            edge .Lock.UpstreamFlood.EastPaddle.Actuator.c_emrgStop, .Lock.UpstreamFlood.EastPaddle.Actuator.c_endStopClosing goto Rest;
        end
        plant automaton Sensor:
          alg bool InitialLocationClosed = .sup.Lock.UpstreamFlood.EastPaddle.InitialLocationClosed;
          location Closed:
            initial InitialLocationClosed;
            marked InitialLocationClosed;
            edge .Lock.UpstreamFlood.EastPaddle.Sensor.u_closed_off goto Intermediate;
          location Intermediate:
            edge .Lock.UpstreamFlood.EastPaddle.Sensor.u_closed_on goto Closed;
            edge .Lock.UpstreamFlood.EastPaddle.Sensor.u_open_on goto Open;
          location Open:
            initial not InitialLocationClosed;
            marked not InitialLocationClosed;
            edge .Lock.UpstreamFlood.EastPaddle.Sensor.u_open_off goto Intermediate;
        end
        plant automaton Dynamics:
          location:
            initial;
            marked;
            edge .Lock.UpstreamFlood.EastPaddle.Sensor.u_open_on, .Lock.UpstreamFlood.EastPaddle.Sensor.u_closed_off when Actuator.Opening;
            edge .Lock.UpstreamFlood.EastPaddle.Sensor.u_closed_on, .Lock.UpstreamFlood.EastPaddle.Sensor.u_open_off when Actuator.Closing;
        end
        requirement invariant .Lock.UpstreamFlood.EastPaddle.Actuator.c_endStopOpening needs Sensor.Open;
        requirement invariant .Lock.UpstreamFlood.EastPaddle.Actuator.c_endStopClosing needs Sensor.Closed;
        requirement invariant .Lock.UpstreamFlood.EastPaddle.Actuator.c_open needs not Sensor.Open;
        requirement invariant .Lock.UpstreamFlood.EastPaddle.Actuator.c_close needs not Sensor.Closed;
      end
      group WestPaddle:
        alg bool Moving = not Actuator.Rest;
        alg bool Closed = Actuator.Rest and Sensor.Closed;
        alg bool Open = Actuator.Rest and Sensor.Open;
        alg bool InitialLocationClosed = true;
        plant automaton Actuator:
          location Rest:
            initial;
            marked;
            edge .Lock.UpstreamFlood.WestPaddle.Actuator.c_open goto Opening;
            edge .Lock.UpstreamFlood.WestPaddle.Actuator.c_close goto Closing;
          location Opening:
            edge .Lock.UpstreamFlood.WestPaddle.Actuator.c_emrgStop, .Lock.UpstreamFlood.WestPaddle.Actuator.c_endStopOpening goto Rest;
          location Closing:
            edge .Lock.UpstreamFlood.WestPaddle.Actuator.c_emrgStop, .Lock.UpstreamFlood.WestPaddle.Actuator.c_endStopClosing goto Rest;
        end
        plant automaton Sensor:
          alg bool InitialLocationClosed = .sup.Lock.UpstreamFlood.WestPaddle.InitialLocationClosed;
          location Closed:
            initial InitialLocationClosed;
            marked InitialLocationClosed;
            edge .Lock.UpstreamFlood.WestPaddle.Sensor.u_closed_off goto Intermediate;
          location Intermediate:
            edge .Lock.UpstreamFlood.WestPaddle.Sensor.u_closed_on goto Closed;
            edge .Lock.UpstreamFlood.WestPaddle.Sensor.u_open_on goto Open;
          location Open:
            initial not InitialLocationClosed;
            marked not InitialLocationClosed;
            edge .Lock.UpstreamFlood.WestPaddle.Sensor.u_open_off goto Intermediate;
        end
        plant automaton Dynamics:
          location:
            initial;
            marked;
            edge .Lock.UpstreamFlood.WestPaddle.Sensor.u_open_on, .Lock.UpstreamFlood.WestPaddle.Sensor.u_closed_off when Actuator.Opening;
            edge .Lock.UpstreamFlood.WestPaddle.Sensor.u_closed_on, .Lock.UpstreamFlood.WestPaddle.Sensor.u_open_off when Actuator.Closing;
        end
        requirement invariant .Lock.UpstreamFlood.WestPaddle.Actuator.c_endStopOpening needs Sensor.Open;
        requirement invariant .Lock.UpstreamFlood.WestPaddle.Actuator.c_endStopClosing needs Sensor.Closed;
        requirement invariant .Lock.UpstreamFlood.WestPaddle.Actuator.c_open needs not Sensor.Open;
        requirement invariant .Lock.UpstreamFlood.WestPaddle.Actuator.c_close needs not Sensor.Closed;
      end
    end
    group DownstreamEbb:
      alg bool GatesOpen = EastGate.Open and WestGate.Open;
      alg bool GatesClosed = EastGate.Closed and WestGate.Closed;
      alg bool GatesMoving = EastGate.Moving or WestGate.Moving;
      alg bool PaddlesOpen = EastPaddle.Open and WestPaddle.Open;
      alg bool PaddlesClosed = EastPaddle.Closed and WestPaddle.Closed;
      alg bool PaddlesMoving = EastPaddle.Moving or WestPaddle.Moving;
      alg bool Closed = GatesClosed and PaddlesClosed;
      alg bool Moving = GatesMoving or PaddlesMoving;
      group EastGate:
        alg bool Moving = not Actuator.Rest;
        alg bool Closed = Actuator.Rest and Sensor.Closed;
        alg bool Open = Actuator.Rest and Sensor.Open;
        alg bool InitialLocationClosed = true;
        plant automaton Actuator:
          location Rest:
            initial;
            marked;
            edge .Lock.DownstreamEbb.EastGate.Actuator.c_open goto Opening;
            edge .Lock.DownstreamEbb.EastGate.Actuator.c_close goto Closing;
          location Opening:
            edge .Lock.DownstreamEbb.EastGate.Actuator.c_emrgStop, .Lock.DownstreamEbb.EastGate.Actuator.c_endStopOpening goto Rest;
          location Closing:
            edge .Lock.DownstreamEbb.EastGate.Actuator.c_emrgStop, .Lock.DownstreamEbb.EastGate.Actuator.c_endStopClosing goto Rest;
        end
        plant automaton Sensor:
          alg bool InitialLocationClosed = .sup.Lock.DownstreamEbb.EastGate.InitialLocationClosed;
          location Closed:
            initial InitialLocationClosed;
            marked InitialLocationClosed;
            edge .Lock.DownstreamEbb.EastGate.Sensor.u_closed_off goto Intermediate;
          location Intermediate:
            edge .Lock.DownstreamEbb.EastGate.Sensor.u_closed_on goto Closed;
            edge .Lock.DownstreamEbb.EastGate.Sensor.u_open_on goto Open;
          location Open:
            initial not InitialLocationClosed;
            marked not InitialLocationClosed;
            edge .Lock.DownstreamEbb.EastGate.Sensor.u_open_off goto Intermediate;
        end
        plant automaton Dynamics:
          location:
            initial;
            marked;
            edge .Lock.DownstreamEbb.EastGate.Sensor.u_open_on, .Lock.DownstreamEbb.EastGate.Sensor.u_closed_off when Actuator.Opening;
            edge .Lock.DownstreamEbb.EastGate.Sensor.u_closed_on, .Lock.DownstreamEbb.EastGate.Sensor.u_open_off when Actuator.Closing;
        end
        requirement invariant .Lock.DownstreamEbb.EastGate.Actuator.c_endStopOpening needs Sensor.Open;
        requirement invariant .Lock.DownstreamEbb.EastGate.Actuator.c_endStopClosing needs Sensor.Closed;
        requirement invariant .Lock.DownstreamEbb.EastGate.Actuator.c_open needs not Sensor.Open;
        requirement invariant .Lock.DownstreamEbb.EastGate.Actuator.c_close needs not Sensor.Closed;
      end
      group WestGate:
        alg bool Moving = not Actuator.Rest;
        alg bool Closed = Actuator.Rest and Sensor.Closed;
        alg bool Open = Actuator.Rest and Sensor.Open;
        alg bool InitialLocationClosed = true;
        plant automaton Actuator:
          location Rest:
            initial;
            marked;
            edge .Lock.DownstreamEbb.WestGate.Actuator.c_open goto Opening;
            edge .Lock.DownstreamEbb.WestGate.Actuator.c_close goto Closing;
          location Opening:
            edge .Lock.DownstreamEbb.WestGate.Actuator.c_emrgStop, .Lock.DownstreamEbb.WestGate.Actuator.c_endStopOpening goto Rest;
          location Closing:
            edge .Lock.DownstreamEbb.WestGate.Actuator.c_emrgStop, .Lock.DownstreamEbb.WestGate.Actuator.c_endStopClosing goto Rest;
        end
        plant automaton Sensor:
          alg bool InitialLocationClosed = .sup.Lock.DownstreamEbb.WestGate.InitialLocationClosed;
          location Closed:
            initial InitialLocationClosed;
            marked InitialLocationClosed;
            edge .Lock.DownstreamEbb.WestGate.Sensor.u_closed_off goto Intermediate;
          location Intermediate:
            edge .Lock.DownstreamEbb.WestGate.Sensor.u_closed_on goto Closed;
            edge .Lock.DownstreamEbb.WestGate.Sensor.u_open_on goto Open;
          location Open:
            initial not InitialLocationClosed;
            marked not InitialLocationClosed;
            edge .Lock.DownstreamEbb.WestGate.Sensor.u_open_off goto Intermediate;
        end
        plant automaton Dynamics:
          location:
            initial;
            marked;
            edge .Lock.DownstreamEbb.WestGate.Sensor.u_open_on, .Lock.DownstreamEbb.WestGate.Sensor.u_closed_off when Actuator.Opening;
            edge .Lock.DownstreamEbb.WestGate.Sensor.u_closed_on, .Lock.DownstreamEbb.WestGate.Sensor.u_open_off when Actuator.Closing;
        end
        requirement invariant .Lock.DownstreamEbb.WestGate.Actuator.c_endStopOpening needs Sensor.Open;
        requirement invariant .Lock.DownstreamEbb.WestGate.Actuator.c_endStopClosing needs Sensor.Closed;
        requirement invariant .Lock.DownstreamEbb.WestGate.Actuator.c_open needs not Sensor.Open;
        requirement invariant .Lock.DownstreamEbb.WestGate.Actuator.c_close needs not Sensor.Closed;
      end
      group EastPaddle:
        alg bool Moving = not Actuator.Rest;
        alg bool Closed = Actuator.Rest and Sensor.Closed;
        alg bool Open = Actuator.Rest and Sensor.Open;
        alg bool InitialLocationClosed = true;
        plant automaton Actuator:
          location Rest:
            initial;
            marked;
            edge .Lock.DownstreamEbb.EastPaddle.Actuator.c_open goto Opening;
            edge .Lock.DownstreamEbb.EastPaddle.Actuator.c_close goto Closing;
          location Opening:
            edge .Lock.DownstreamEbb.EastPaddle.Actuator.c_emrgStop, .Lock.DownstreamEbb.EastPaddle.Actuator.c_endStopOpening goto Rest;
          location Closing:
            edge .Lock.DownstreamEbb.EastPaddle.Actuator.c_emrgStop, .Lock.DownstreamEbb.EastPaddle.Actuator.c_endStopClosing goto Rest;
        end
        plant automaton Sensor:
          alg bool InitialLocationClosed = .sup.Lock.DownstreamEbb.EastPaddle.InitialLocationClosed;
          location Closed:
            initial InitialLocationClosed;
            marked InitialLocationClosed;
            edge .Lock.DownstreamEbb.EastPaddle.Sensor.u_closed_off goto Intermediate;
          location Intermediate:
            edge .Lock.DownstreamEbb.EastPaddle.Sensor.u_closed_on goto Closed;
            edge .Lock.DownstreamEbb.EastPaddle.Sensor.u_open_on goto Open;
          location Open:
            initial not InitialLocationClosed;
            marked not InitialLocationClosed;
            edge .Lock.DownstreamEbb.EastPaddle.Sensor.u_open_off goto Intermediate;
        end
        plant automaton Dynamics:
          location:
            initial;
            marked;
            edge .Lock.DownstreamEbb.EastPaddle.Sensor.u_open_on, .Lock.DownstreamEbb.EastPaddle.Sensor.u_closed_off when Actuator.Opening;
            edge .Lock.DownstreamEbb.EastPaddle.Sensor.u_closed_on, .Lock.DownstreamEbb.EastPaddle.Sensor.u_open_off when Actuator.Closing;
        end
        requirement invariant .Lock.DownstreamEbb.EastPaddle.Actuator.c_endStopOpening needs Sensor.Open;
        requirement invariant .Lock.DownstreamEbb.EastPaddle.Actuator.c_endStopClosing needs Sensor.Closed;
        requirement invariant .Lock.DownstreamEbb.EastPaddle.Actuator.c_open needs not Sensor.Open;
        requirement invariant .Lock.DownstreamEbb.EastPaddle.Actuator.c_close needs not Sensor.Closed;
      end
      group WestPaddle:
        alg bool Moving = not Actuator.Rest;
        alg bool Closed = Actuator.Rest and Sensor.Closed;
        alg bool Open = Actuator.Rest and Sensor.Open;
        alg bool InitialLocationClosed = true;
        plant automaton Actuator:
          location Rest:
            initial;
            marked;
            edge .Lock.DownstreamEbb.WestPaddle.Actuator.c_open goto Opening;
            edge .Lock.DownstreamEbb.WestPaddle.Actuator.c_close goto Closing;
          location Opening:
            edge .Lock.DownstreamEbb.WestPaddle.Actuator.c_emrgStop, .Lock.DownstreamEbb.WestPaddle.Actuator.c_endStopOpening goto Rest;
          location Closing:
            edge .Lock.DownstreamEbb.WestPaddle.Actuator.c_emrgStop, .Lock.DownstreamEbb.WestPaddle.Actuator.c_endStopClosing goto Rest;
        end
        plant automaton Sensor:
          alg bool InitialLocationClosed = .sup.Lock.DownstreamEbb.WestPaddle.InitialLocationClosed;
          location Closed:
            initial InitialLocationClosed;
            marked InitialLocationClosed;
            edge .Lock.DownstreamEbb.WestPaddle.Sensor.u_closed_off goto Intermediate;
          location Intermediate:
            edge .Lock.DownstreamEbb.WestPaddle.Sensor.u_closed_on goto Closed;
            edge .Lock.DownstreamEbb.WestPaddle.Sensor.u_open_on goto Open;
          location Open:
            initial not InitialLocationClosed;
            marked not InitialLocationClosed;
            edge .Lock.DownstreamEbb.WestPaddle.Sensor.u_open_off goto Intermediate;
        end
        plant automaton Dynamics:
          location:
            initial;
            marked;
            edge .Lock.DownstreamEbb.WestPaddle.Sensor.u_open_on, .Lock.DownstreamEbb.WestPaddle.Sensor.u_closed_off when Actuator.Opening;
            edge .Lock.DownstreamEbb.WestPaddle.Sensor.u_closed_on, .Lock.DownstreamEbb.WestPaddle.Sensor.u_open_off when Actuator.Closing;
        end
        requirement invariant .Lock.DownstreamEbb.WestPaddle.Actuator.c_endStopOpening needs Sensor.Open;
        requirement invariant .Lock.DownstreamEbb.WestPaddle.Actuator.c_endStopClosing needs Sensor.Closed;
        requirement invariant .Lock.DownstreamEbb.WestPaddle.Actuator.c_open needs not Sensor.Open;
        requirement invariant .Lock.DownstreamEbb.WestPaddle.Actuator.c_close needs not Sensor.Closed;
      end
    end
    group DownstreamFlood:
      alg bool GatesOpen = EastGate.Open and WestGate.Open;
      alg bool GatesClosed = EastGate.Closed and WestGate.Closed;
      alg bool GatesMoving = EastGate.Moving or WestGate.Moving;
      alg bool PaddlesOpen = EastPaddle.Open and WestPaddle.Open;
      alg bool PaddlesClosed = EastPaddle.Closed and WestPaddle.Closed;
      alg bool PaddlesMoving = EastPaddle.Moving or WestPaddle.Moving;
      alg bool Closed = GatesClosed and PaddlesClosed;
      alg bool Moving = GatesMoving or PaddlesMoving;
      group EastGate:
        alg bool Moving = not Actuator.Rest;
        alg bool Closed = Actuator.Rest and Sensor.Closed;
        alg bool Open = Actuator.Rest and Sensor.Open;
        alg bool InitialLocationClosed = true;
        plant automaton Actuator:
          location Rest:
            initial;
            marked;
            edge .Lock.DownstreamFlood.EastGate.Actuator.c_open goto Opening;
            edge .Lock.DownstreamFlood.EastGate.Actuator.c_close goto Closing;
          location Opening:
            edge .Lock.DownstreamFlood.EastGate.Actuator.c_emrgStop, .Lock.DownstreamFlood.EastGate.Actuator.c_endStopOpening goto Rest;
          location Closing:
            edge .Lock.DownstreamFlood.EastGate.Actuator.c_emrgStop, .Lock.DownstreamFlood.EastGate.Actuator.c_endStopClosing goto Rest;
        end
        plant automaton Sensor:
          alg bool InitialLocationClosed = .sup.Lock.DownstreamFlood.EastGate.InitialLocationClosed;
          location Closed:
            initial InitialLocationClosed;
            marked InitialLocationClosed;
            edge .Lock.DownstreamFlood.EastGate.Sensor.u_closed_off goto Intermediate;
          location Intermediate:
            edge .Lock.DownstreamFlood.EastGate.Sensor.u_closed_on goto Closed;
            edge .Lock.DownstreamFlood.EastGate.Sensor.u_open_on goto Open;
          location Open:
            initial not InitialLocationClosed;
            marked not InitialLocationClosed;
            edge .Lock.DownstreamFlood.EastGate.Sensor.u_open_off goto Intermediate;
        end
        plant automaton Dynamics:
          location:
            initial;
            marked;
            edge .Lock.DownstreamFlood.EastGate.Sensor.u_open_on, .Lock.DownstreamFlood.EastGate.Sensor.u_closed_off when Actuator.Opening;
            edge .Lock.DownstreamFlood.EastGate.Sensor.u_closed_on, .Lock.DownstreamFlood.EastGate.Sensor.u_open_off when Actuator.Closing;
        end
        requirement invariant .Lock.DownstreamFlood.EastGate.Actuator.c_endStopOpening needs Sensor.Open;
        requirement invariant .Lock.DownstreamFlood.EastGate.Actuator.c_endStopClosing needs Sensor.Closed;
        requirement invariant .Lock.DownstreamFlood.EastGate.Actuator.c_open needs not Sensor.Open;
        requirement invariant .Lock.DownstreamFlood.EastGate.Actuator.c_close needs not Sensor.Closed;
      end
      group WestGate:
        alg bool Moving = not Actuator.Rest;
        alg bool Closed = Actuator.Rest and Sensor.Closed;
        alg bool Open = Actuator.Rest and Sensor.Open;
        alg bool InitialLocationClosed = true;
        plant automaton Actuator:
          location Rest:
            initial;
            marked;
            edge .Lock.DownstreamFlood.WestGate.Actuator.c_open goto Opening;
            edge .Lock.DownstreamFlood.WestGate.Actuator.c_close goto Closing;
          location Opening:
            edge .Lock.DownstreamFlood.WestGate.Actuator.c_emrgStop, .Lock.DownstreamFlood.WestGate.Actuator.c_endStopOpening goto Rest;
          location Closing:
            edge .Lock.DownstreamFlood.WestGate.Actuator.c_emrgStop, .Lock.DownstreamFlood.WestGate.Actuator.c_endStopClosing goto Rest;
        end
        plant automaton Sensor:
          alg bool InitialLocationClosed = .sup.Lock.DownstreamFlood.WestGate.InitialLocationClosed;
          location Closed:
            initial InitialLocationClosed;
            marked InitialLocationClosed;
            edge .Lock.DownstreamFlood.WestGate.Sensor.u_closed_off goto Intermediate;
          location Intermediate:
            edge .Lock.DownstreamFlood.WestGate.Sensor.u_closed_on goto Closed;
            edge .Lock.DownstreamFlood.WestGate.Sensor.u_open_on goto Open;
          location Open:
            initial not InitialLocationClosed;
            marked not InitialLocationClosed;
            edge .Lock.DownstreamFlood.WestGate.Sensor.u_open_off goto Intermediate;
        end
        plant automaton Dynamics:
          location:
            initial;
            marked;
            edge .Lock.DownstreamFlood.WestGate.Sensor.u_open_on, .Lock.DownstreamFlood.WestGate.Sensor.u_closed_off when Actuator.Opening;
            edge .Lock.DownstreamFlood.WestGate.Sensor.u_closed_on, .Lock.DownstreamFlood.WestGate.Sensor.u_open_off when Actuator.Closing;
        end
        requirement invariant .Lock.DownstreamFlood.WestGate.Actuator.c_endStopOpening needs Sensor.Open;
        requirement invariant .Lock.DownstreamFlood.WestGate.Actuator.c_endStopClosing needs Sensor.Closed;
        requirement invariant .Lock.DownstreamFlood.WestGate.Actuator.c_open needs not Sensor.Open;
        requirement invariant .Lock.DownstreamFlood.WestGate.Actuator.c_close needs not Sensor.Closed;
      end
      group EastPaddle:
        alg bool Moving = not Actuator.Rest;
        alg bool Closed = Actuator.Rest and Sensor.Closed;
        alg bool Open = Actuator.Rest and Sensor.Open;
        alg bool InitialLocationClosed = true;
        plant automaton Actuator:
          location Rest:
            initial;
            marked;
            edge .Lock.DownstreamFlood.EastPaddle.Actuator.c_open goto Opening;
            edge .Lock.DownstreamFlood.EastPaddle.Actuator.c_close goto Closing;
          location Opening:
            edge .Lock.DownstreamFlood.EastPaddle.Actuator.c_emrgStop, .Lock.DownstreamFlood.EastPaddle.Actuator.c_endStopOpening goto Rest;
          location Closing:
            edge .Lock.DownstreamFlood.EastPaddle.Actuator.c_emrgStop, .Lock.DownstreamFlood.EastPaddle.Actuator.c_endStopClosing goto Rest;
        end
        plant automaton Sensor:
          alg bool InitialLocationClosed = .sup.Lock.DownstreamFlood.EastPaddle.InitialLocationClosed;
          location Closed:
            initial InitialLocationClosed;
            marked InitialLocationClosed;
            edge .Lock.DownstreamFlood.EastPaddle.Sensor.u_closed_off goto Intermediate;
          location Intermediate:
            edge .Lock.DownstreamFlood.EastPaddle.Sensor.u_closed_on goto Closed;
            edge .Lock.DownstreamFlood.EastPaddle.Sensor.u_open_on goto Open;
          location Open:
            initial not InitialLocationClosed;
            marked not InitialLocationClosed;
            edge .Lock.DownstreamFlood.EastPaddle.Sensor.u_open_off goto Intermediate;
        end
        plant automaton Dynamics:
          location:
            initial;
            marked;
            edge .Lock.DownstreamFlood.EastPaddle.Sensor.u_open_on, .Lock.DownstreamFlood.EastPaddle.Sensor.u_closed_off when Actuator.Opening;
            edge .Lock.DownstreamFlood.EastPaddle.Sensor.u_closed_on, .Lock.DownstreamFlood.EastPaddle.Sensor.u_open_off when Actuator.Closing;
        end
        requirement invariant .Lock.DownstreamFlood.EastPaddle.Actuator.c_endStopOpening needs Sensor.Open;
        requirement invariant .Lock.DownstreamFlood.EastPaddle.Actuator.c_endStopClosing needs Sensor.Closed;
        requirement invariant .Lock.DownstreamFlood.EastPaddle.Actuator.c_open needs not Sensor.Open;
        requirement invariant .Lock.DownstreamFlood.EastPaddle.Actuator.c_close needs not Sensor.Closed;
      end
      group WestPaddle:
        alg bool Moving = not Actuator.Rest;
        alg bool Closed = Actuator.Rest and Sensor.Closed;
        alg bool Open = Actuator.Rest and Sensor.Open;
        alg bool InitialLocationClosed = true;
        plant automaton Actuator:
          location Rest:
            initial;
            marked;
            edge .Lock.DownstreamFlood.WestPaddle.Actuator.c_open goto Opening;
            edge .Lock.DownstreamFlood.WestPaddle.Actuator.c_close goto Closing;
          location Opening:
            edge .Lock.DownstreamFlood.WestPaddle.Actuator.c_emrgStop, .Lock.DownstreamFlood.WestPaddle.Actuator.c_endStopOpening goto Rest;
          location Closing:
            edge .Lock.DownstreamFlood.WestPaddle.Actuator.c_emrgStop, .Lock.DownstreamFlood.WestPaddle.Actuator.c_endStopClosing goto Rest;
        end
        plant automaton Sensor:
          alg bool InitialLocationClosed = .sup.Lock.DownstreamFlood.WestPaddle.InitialLocationClosed;
          location Closed:
            initial InitialLocationClosed;
            marked InitialLocationClosed;
            edge .Lock.DownstreamFlood.WestPaddle.Sensor.u_closed_off goto Intermediate;
          location Intermediate:
            edge .Lock.DownstreamFlood.WestPaddle.Sensor.u_closed_on goto Closed;
            edge .Lock.DownstreamFlood.WestPaddle.Sensor.u_open_on goto Open;
          location Open:
            initial not InitialLocationClosed;
            marked not InitialLocationClosed;
            edge .Lock.DownstreamFlood.WestPaddle.Sensor.u_open_off goto Intermediate;
        end
        plant automaton Dynamics:
          location:
            initial;
            marked;
            edge .Lock.DownstreamFlood.WestPaddle.Sensor.u_open_on, .Lock.DownstreamFlood.WestPaddle.Sensor.u_closed_off when Actuator.Opening;
            edge .Lock.DownstreamFlood.WestPaddle.Sensor.u_closed_on, .Lock.DownstreamFlood.WestPaddle.Sensor.u_open_off when Actuator.Closing;
        end
        requirement invariant .Lock.DownstreamFlood.WestPaddle.Actuator.c_endStopOpening needs Sensor.Open;
        requirement invariant .Lock.DownstreamFlood.WestPaddle.Actuator.c_endStopClosing needs Sensor.Closed;
        requirement invariant .Lock.DownstreamFlood.WestPaddle.Actuator.c_open needs not Sensor.Open;
        requirement invariant .Lock.DownstreamFlood.WestPaddle.Actuator.c_close needs not Sensor.Closed;
      end
    end
    group DownstreamStormFlood:
      alg bool GatesOpen = EastGate.Open and WestGate.Open;
      alg bool GatesClosed = EastGate.Closed and WestGate.Closed;
      alg bool GatesMoving = EastGate.Moving or WestGate.Moving;
      alg bool PaddlesOpen = EastPaddle.Open and WestPaddle.Open;
      alg bool PaddlesClosed = EastPaddle.Closed and WestPaddle.Closed;
      alg bool PaddlesMoving = EastPaddle.Moving or WestPaddle.Moving;
      alg bool Closed = GatesClosed and PaddlesClosed;
      alg bool Moving = GatesMoving or PaddlesMoving;
      group EastGate:
        alg bool Moving = not Actuator.Rest;
        alg bool Closed = Actuator.Rest and Sensor.Closed;
        alg bool Open = Actuator.Rest and Sensor.Open;
        alg bool InitialLocationClosed = true;
        plant automaton Actuator:
          location Rest:
            initial;
            marked;
            edge .Lock.DownstreamStormFlood.EastGate.Actuator.c_open goto Opening;
            edge .Lock.DownstreamStormFlood.EastGate.Actuator.c_close goto Closing;
          location Opening:
            edge .Lock.DownstreamStormFlood.EastGate.Actuator.c_emrgStop, .Lock.DownstreamStormFlood.EastGate.Actuator.c_endStopOpening goto Rest;
          location Closing:
            edge .Lock.DownstreamStormFlood.EastGate.Actuator.c_emrgStop, .Lock.DownstreamStormFlood.EastGate.Actuator.c_endStopClosing goto Rest;
        end
        plant automaton Sensor:
          alg bool InitialLocationClosed = .sup.Lock.DownstreamStormFlood.EastGate.InitialLocationClosed;
          location Closed:
            initial InitialLocationClosed;
            marked InitialLocationClosed;
            edge .Lock.DownstreamStormFlood.EastGate.Sensor.u_closed_off goto Intermediate;
          location Intermediate:
            edge .Lock.DownstreamStormFlood.EastGate.Sensor.u_closed_on goto Closed;
            edge .Lock.DownstreamStormFlood.EastGate.Sensor.u_open_on goto Open;
          location Open:
            initial not InitialLocationClosed;
            marked not InitialLocationClosed;
            edge .Lock.DownstreamStormFlood.EastGate.Sensor.u_open_off goto Intermediate;
        end
        plant automaton Dynamics:
          location:
            initial;
            marked;
            edge .Lock.DownstreamStormFlood.EastGate.Sensor.u_open_on, .Lock.DownstreamStormFlood.EastGate.Sensor.u_closed_off when Actuator.Opening;
            edge .Lock.DownstreamStormFlood.EastGate.Sensor.u_closed_on, .Lock.DownstreamStormFlood.EastGate.Sensor.u_open_off when Actuator.Closing;
        end
        requirement invariant .Lock.DownstreamStormFlood.EastGate.Actuator.c_endStopOpening needs Sensor.Open;
        requirement invariant .Lock.DownstreamStormFlood.EastGate.Actuator.c_endStopClosing needs Sensor.Closed;
        requirement invariant .Lock.DownstreamStormFlood.EastGate.Actuator.c_open needs not Sensor.Open;
        requirement invariant .Lock.DownstreamStormFlood.EastGate.Actuator.c_close needs not Sensor.Closed;
      end
      group WestGate:
        alg bool Moving = not Actuator.Rest;
        alg bool Closed = Actuator.Rest and Sensor.Closed;
        alg bool Open = Actuator.Rest and Sensor.Open;
        alg bool InitialLocationClosed = true;
        plant automaton Actuator:
          location Rest:
            initial;
            marked;
            edge .Lock.DownstreamStormFlood.WestGate.Actuator.c_open goto Opening;
            edge .Lock.DownstreamStormFlood.WestGate.Actuator.c_close goto Closing;
          location Opening:
            edge .Lock.DownstreamStormFlood.WestGate.Actuator.c_emrgStop, .Lock.DownstreamStormFlood.WestGate.Actuator.c_endStopOpening goto Rest;
          location Closing:
            edge .Lock.DownstreamStormFlood.WestGate.Actuator.c_emrgStop, .Lock.DownstreamStormFlood.WestGate.Actuator.c_endStopClosing goto Rest;
        end
        plant automaton Sensor:
          alg bool InitialLocationClosed = .sup.Lock.DownstreamStormFlood.WestGate.InitialLocationClosed;
          location Closed:
            initial InitialLocationClosed;
            marked InitialLocationClosed;
            edge .Lock.DownstreamStormFlood.WestGate.Sensor.u_closed_off goto Intermediate;
          location Intermediate:
            edge .Lock.DownstreamStormFlood.WestGate.Sensor.u_closed_on goto Closed;
            edge .Lock.DownstreamStormFlood.WestGate.Sensor.u_open_on goto Open;
          location Open:
            initial not InitialLocationClosed;
            marked not InitialLocationClosed;
            edge .Lock.DownstreamStormFlood.WestGate.Sensor.u_open_off goto Intermediate;
        end
        plant automaton Dynamics:
          location:
            initial;
            marked;
            edge .Lock.DownstreamStormFlood.WestGate.Sensor.u_open_on, .Lock.DownstreamStormFlood.WestGate.Sensor.u_closed_off when Actuator.Opening;
            edge .Lock.DownstreamStormFlood.WestGate.Sensor.u_closed_on, .Lock.DownstreamStormFlood.WestGate.Sensor.u_open_off when Actuator.Closing;
        end
        requirement invariant .Lock.DownstreamStormFlood.WestGate.Actuator.c_endStopOpening needs Sensor.Open;
        requirement invariant .Lock.DownstreamStormFlood.WestGate.Actuator.c_endStopClosing needs Sensor.Closed;
        requirement invariant .Lock.DownstreamStormFlood.WestGate.Actuator.c_open needs not Sensor.Open;
        requirement invariant .Lock.DownstreamStormFlood.WestGate.Actuator.c_close needs not Sensor.Closed;
      end
      group EastPaddle:
        alg bool Moving = not Actuator.Rest;
        alg bool Closed = Actuator.Rest and Sensor.Closed;
        alg bool Open = Actuator.Rest and Sensor.Open;
        alg bool InitialLocationClosed = true;
        plant automaton Actuator:
          location Rest:
            initial;
            marked;
            edge .Lock.DownstreamStormFlood.EastPaddle.Actuator.c_open goto Opening;
            edge .Lock.DownstreamStormFlood.EastPaddle.Actuator.c_close goto Closing;
          location Opening:
            edge .Lock.DownstreamStormFlood.EastPaddle.Actuator.c_emrgStop, .Lock.DownstreamStormFlood.EastPaddle.Actuator.c_endStopOpening goto Rest;
          location Closing:
            edge .Lock.DownstreamStormFlood.EastPaddle.Actuator.c_emrgStop, .Lock.DownstreamStormFlood.EastPaddle.Actuator.c_endStopClosing goto Rest;
        end
        plant automaton Sensor:
          alg bool InitialLocationClosed = .sup.Lock.DownstreamStormFlood.EastPaddle.InitialLocationClosed;
          location Closed:
            initial InitialLocationClosed;
            marked InitialLocationClosed;
            edge .Lock.DownstreamStormFlood.EastPaddle.Sensor.u_closed_off goto Intermediate;
          location Intermediate:
            edge .Lock.DownstreamStormFlood.EastPaddle.Sensor.u_closed_on goto Closed;
            edge .Lock.DownstreamStormFlood.EastPaddle.Sensor.u_open_on goto Open;
          location Open:
            initial not InitialLocationClosed;
            marked not InitialLocationClosed;
            edge .Lock.DownstreamStormFlood.EastPaddle.Sensor.u_open_off goto Intermediate;
        end
        plant automaton Dynamics:
          location:
            initial;
            marked;
            edge .Lock.DownstreamStormFlood.EastPaddle.Sensor.u_open_on, .Lock.DownstreamStormFlood.EastPaddle.Sensor.u_closed_off when Actuator.Opening;
            edge .Lock.DownstreamStormFlood.EastPaddle.Sensor.u_closed_on, .Lock.DownstreamStormFlood.EastPaddle.Sensor.u_open_off when Actuator.Closing;
        end
        requirement invariant .Lock.DownstreamStormFlood.EastPaddle.Actuator.c_endStopOpening needs Sensor.Open;
        requirement invariant .Lock.DownstreamStormFlood.EastPaddle.Actuator.c_endStopClosing needs Sensor.Closed;
        requirement invariant .Lock.DownstreamStormFlood.EastPaddle.Actuator.c_open needs not Sensor.Open;
        requirement invariant .Lock.DownstreamStormFlood.EastPaddle.Actuator.c_close needs not Sensor.Closed;
      end
      group WestPaddle:
        alg bool Moving = not Actuator.Rest;
        alg bool Closed = Actuator.Rest and Sensor.Closed;
        alg bool Open = Actuator.Rest and Sensor.Open;
        alg bool InitialLocationClosed = true;
        plant automaton Actuator:
          location Rest:
            initial;
            marked;
            edge .Lock.DownstreamStormFlood.WestPaddle.Actuator.c_open goto Opening;
            edge .Lock.DownstreamStormFlood.WestPaddle.Actuator.c_close goto Closing;
          location Opening:
            edge .Lock.DownstreamStormFlood.WestPaddle.Actuator.c_emrgStop, .Lock.DownstreamStormFlood.WestPaddle.Actuator.c_endStopOpening goto Rest;
          location Closing:
            edge .Lock.DownstreamStormFlood.WestPaddle.Actuator.c_emrgStop, .Lock.DownstreamStormFlood.WestPaddle.Actuator.c_endStopClosing goto Rest;
        end
        plant automaton Sensor:
          alg bool InitialLocationClosed = .sup.Lock.DownstreamStormFlood.WestPaddle.InitialLocationClosed;
          location Closed:
            initial InitialLocationClosed;
            marked InitialLocationClosed;
            edge .Lock.DownstreamStormFlood.WestPaddle.Sensor.u_closed_off goto Intermediate;
          location Intermediate:
            edge .Lock.DownstreamStormFlood.WestPaddle.Sensor.u_closed_on goto Closed;
            edge .Lock.DownstreamStormFlood.WestPaddle.Sensor.u_open_on goto Open;
          location Open:
            initial not InitialLocationClosed;
            marked not InitialLocationClosed;
            edge .Lock.DownstreamStormFlood.WestPaddle.Sensor.u_open_off goto Intermediate;
        end
        plant automaton Dynamics:
          location:
            initial;
            marked;
            edge .Lock.DownstreamStormFlood.WestPaddle.Sensor.u_open_on, .Lock.DownstreamStormFlood.WestPaddle.Sensor.u_closed_off when Actuator.Opening;
            edge .Lock.DownstreamStormFlood.WestPaddle.Sensor.u_closed_on, .Lock.DownstreamStormFlood.WestPaddle.Sensor.u_open_off when Actuator.Closing;
        end
        requirement invariant .Lock.DownstreamStormFlood.WestPaddle.Actuator.c_endStopOpening needs Sensor.Open;
        requirement invariant .Lock.DownstreamStormFlood.WestPaddle.Actuator.c_endStopClosing needs Sensor.Closed;
        requirement invariant .Lock.DownstreamStormFlood.WestPaddle.Actuator.c_open needs not Sensor.Open;
        requirement invariant .Lock.DownstreamStormFlood.WestPaddle.Actuator.c_close needs not Sensor.Closed;
      end
    end
    plant automaton EqualWaterUpstream:
      alg bool InitialLocationOn = false;
      location Off:
        initial not InitialLocationOn;
        marked not InitialLocationOn;
        edge .Lock.EqualWaterUpstream.u_on goto On;
      location On:
        initial InitialLocationOn;
        marked InitialLocationOn;
        edge .Lock.EqualWaterUpstream.u_off goto Off;
    end
    plant automaton EqualWaterDownstream:
      alg bool InitialLocationOn = true;
      location Off:
        initial not InitialLocationOn;
        marked not InitialLocationOn;
        edge .Lock.EqualWaterDownstream.u_on goto On;
      location On:
        initial InitialLocationOn;
        marked InitialLocationOn;
        edge .Lock.EqualWaterDownstream.u_off goto Off;
    end
  end
  group Bridge:
    group UI:
      plant automaton LT:
        location Deactivated:
          initial;
          marked;
          edge .Bridge.UI.LT.u_activate goto Activated;
          edge .Bridge.UI.LT.u_stop goto Stopped;
        location Activated:
          edge .Bridge.UI.LT.u_deactivate goto Deactivated;
          edge .Bridge.UI.LT.u_stop goto Stopped;
        location Stopped:
          edge .Bridge.UI.LT.u_activate goto Activated;
          edge .Bridge.UI.LT.u_deactivate goto Deactivated;
      end
      plant automaton Barrier1:
        alg bool InitialOpen = true;
        location Open:
          initial InitialOpen;
          marked InitialOpen;
          edge .Bridge.UI.Barrier1.u_close goto Close;
          edge .Bridge.UI.Barrier1.u_stop goto Stop;
        location Close:
          initial not InitialOpen;
          marked not InitialOpen;
          edge .Bridge.UI.Barrier1.u_open goto Open;
          edge .Bridge.UI.Barrier1.u_stop goto Stop;
        location Stop:
          edge .Bridge.UI.Barrier1.u_close goto Close;
          edge .Bridge.UI.Barrier1.u_open goto Open;
      end
      plant automaton Barrier27:
        alg bool InitialOpen = true;
        location Open:
          initial InitialOpen;
          marked InitialOpen;
          edge .Bridge.UI.Barrier27.u_close goto Close;
          edge .Bridge.UI.Barrier27.u_stop goto Stop;
        location Close:
          initial not InitialOpen;
          marked not InitialOpen;
          edge .Bridge.UI.Barrier27.u_open goto Open;
          edge .Bridge.UI.Barrier27.u_stop goto Stop;
        location Stop:
          edge .Bridge.UI.Barrier27.u_close goto Close;
          edge .Bridge.UI.Barrier27.u_open goto Open;
      end
      plant automaton Barrier36:
        alg bool InitialOpen = true;
        location Open:
          initial InitialOpen;
          marked InitialOpen;
          edge .Bridge.UI.Barrier36.u_close goto Close;
          edge .Bridge.UI.Barrier36.u_stop goto Stop;
        location Close:
          initial not InitialOpen;
          marked not InitialOpen;
          edge .Bridge.UI.Barrier36.u_open goto Open;
          edge .Bridge.UI.Barrier36.u_stop goto Stop;
        location Stop:
          edge .Bridge.UI.Barrier36.u_close goto Close;
          edge .Bridge.UI.Barrier36.u_open goto Open;
      end
      plant automaton Barrier48:
        alg bool InitialOpen = true;
        location Open:
          initial InitialOpen;
          marked InitialOpen;
          edge .Bridge.UI.Barrier48.u_close goto Close;
          edge .Bridge.UI.Barrier48.u_stop goto Stop;
        location Close:
          initial not InitialOpen;
          marked not InitialOpen;
          edge .Bridge.UI.Barrier48.u_open goto Open;
          edge .Bridge.UI.Barrier48.u_stop goto Stop;
        location Stop:
          edge .Bridge.UI.Barrier48.u_close goto Close;
          edge .Bridge.UI.Barrier48.u_open goto Open;
      end
      plant automaton Barrier5:
        alg bool InitialOpen = true;
        location Open:
          initial InitialOpen;
          marked InitialOpen;
          edge .Bridge.UI.Barrier5.u_close goto Close;
          edge .Bridge.UI.Barrier5.u_stop goto Stop;
        location Close:
          initial not InitialOpen;
          marked not InitialOpen;
          edge .Bridge.UI.Barrier5.u_open goto Open;
          edge .Bridge.UI.Barrier5.u_stop goto Stop;
        location Stop:
          edge .Bridge.UI.Barrier5.u_close goto Close;
          edge .Bridge.UI.Barrier5.u_open goto Open;
      end
      plant automaton Deck:
        alg bool InitialOpen = false;
        location Open:
          initial InitialOpen;
          marked InitialOpen;
          edge .Bridge.UI.Deck.u_close goto Close;
          edge .Bridge.UI.Deck.u_stop goto Stop;
        location Close:
          initial not InitialOpen;
          marked not InitialOpen;
          edge .Bridge.UI.Deck.u_open goto Open;
          edge .Bridge.UI.Deck.u_stop goto Stop;
        location Stop:
          edge .Bridge.UI.Deck.u_close goto Close;
          edge .Bridge.UI.Deck.u_open goto Open;
      end
    end
    plant automaton EmergencyStop:
      location Deactivated:
        initial;
        marked;
        edge .Bridge.EmergencyStop.u_activate goto Activated;
      location Activated:
        edge .Bridge.EmergencyStop.u_reset goto Deactivated;
    end
    group LTAS:
      alg bool FarOn = ApproachSign1.On and ApproachSign2.On and FarActuator.On;
      alg bool NearOn = ApproachSign3.On and ApproachSign4.On and ApproachSign5.On and NearActuator.On;
      alg bool On = FarOn and NearOn;
      alg bool NearOff = ApproachSign3.Off and ApproachSign4.Off and ApproachSign5.Off and NearActuator.Off;
      alg bool On15TimeOk = On15Timer.Finished and On;
      alg bool On20TimeOk = On20Timer.Finished and On;
      alg bool OffNear60TimeOk = NearOff60Timer.Finished and NearOff;
      plant automaton FarActuator:
        alg bool InitialLocationOn = false;
        location Off:
          initial not InitialLocationOn;
          marked not InitialLocationOn;
          edge .Bridge.LTAS.FarActuator.c_on goto On;
        location On:
          initial InitialLocationOn;
          marked InitialLocationOn;
          edge .Bridge.LTAS.FarActuator.c_off goto Off;
      end
      plant automaton NearActuator:
        alg bool InitialLocationOn = false;
        location Off:
          initial not InitialLocationOn;
          marked not InitialLocationOn;
          edge .Bridge.LTAS.NearActuator.c_on goto On;
        location On:
          initial InitialLocationOn;
          marked InitialLocationOn;
          edge .Bridge.LTAS.NearActuator.c_off goto Off;
      end
      group ApproachSign1:
        alg bool On = Sensor.On;
        alg bool Off = Sensor.Off;
        plant automaton Sensor:
          alg bool InitialLocationOn = false;
          location Off:
            initial not InitialLocationOn;
            marked not InitialLocationOn;
            edge .Bridge.LTAS.ApproachSign1.Sensor.u_on goto On;
          location On:
            initial InitialLocationOn;
            marked InitialLocationOn;
            edge .Bridge.LTAS.ApproachSign1.Sensor.u_off goto Off;
        end
        plant automaton Dynamics:
          alg bool On = FarActuator.On;
          alg bool Off = FarActuator.Off;
          location:
            initial;
            marked;
            edge .Bridge.LTAS.ApproachSign1.Sensor.u_on when On;
            edge .Bridge.LTAS.ApproachSign1.Sensor.u_off when Off;
        end
      end
      group ApproachSign2:
        alg bool On = Sensor.On;
        alg bool Off = Sensor.Off;
        plant automaton Sensor:
          alg bool InitialLocationOn = false;
          location Off:
            initial not InitialLocationOn;
            marked not InitialLocationOn;
            edge .Bridge.LTAS.ApproachSign2.Sensor.u_on goto On;
          location On:
            initial InitialLocationOn;
            marked InitialLocationOn;
            edge .Bridge.LTAS.ApproachSign2.Sensor.u_off goto Off;
        end
        plant automaton Dynamics:
          alg bool On = FarActuator.On;
          alg bool Off = FarActuator.Off;
          location:
            initial;
            marked;
            edge .Bridge.LTAS.ApproachSign2.Sensor.u_on when On;
            edge .Bridge.LTAS.ApproachSign2.Sensor.u_off when Off;
        end
      end
      group ApproachSign3:
        alg bool On = Sensor.On;
        alg bool Off = Sensor.Off;
        plant automaton Sensor:
          alg bool InitialLocationOn = false;
          location Off:
            initial not InitialLocationOn;
            marked not InitialLocationOn;
            edge .Bridge.LTAS.ApproachSign3.Sensor.u_on goto On;
          location On:
            initial InitialLocationOn;
            marked InitialLocationOn;
            edge .Bridge.LTAS.ApproachSign3.Sensor.u_off goto Off;
        end
        plant automaton Dynamics:
          alg bool On = NearActuator.On;
          alg bool Off = NearActuator.Off;
          location:
            initial;
            marked;
            edge .Bridge.LTAS.ApproachSign3.Sensor.u_on when On;
            edge .Bridge.LTAS.ApproachSign3.Sensor.u_off when Off;
        end
      end
      group ApproachSign4:
        alg bool On = Sensor.On;
        alg bool Off = Sensor.Off;
        plant automaton Sensor:
          alg bool InitialLocationOn = false;
          location Off:
            initial not InitialLocationOn;
            marked not InitialLocationOn;
            edge .Bridge.LTAS.ApproachSign4.Sensor.u_on goto On;
          location On:
            initial InitialLocationOn;
            marked InitialLocationOn;
            edge .Bridge.LTAS.ApproachSign4.Sensor.u_off goto Off;
        end
        plant automaton Dynamics:
          alg bool On = NearActuator.On;
          alg bool Off = NearActuator.Off;
          location:
            initial;
            marked;
            edge .Bridge.LTAS.ApproachSign4.Sensor.u_on when On;
            edge .Bridge.LTAS.ApproachSign4.Sensor.u_off when Off;
        end
      end
      group ApproachSign5:
        alg bool On = Sensor.On;
        alg bool Off = Sensor.Off;
        plant automaton Sensor:
          alg bool InitialLocationOn = false;
          location Off:
            initial not InitialLocationOn;
            marked not InitialLocationOn;
            edge .Bridge.LTAS.ApproachSign5.Sensor.u_on goto On;
          location On:
            initial InitialLocationOn;
            marked InitialLocationOn;
            edge .Bridge.LTAS.ApproachSign5.Sensor.u_off goto Off;
        end
        plant automaton Dynamics:
          alg bool On = NearActuator.On;
          alg bool Off = NearActuator.Off;
          location:
            initial;
            marked;
            edge .Bridge.LTAS.ApproachSign5.Sensor.u_on when On;
            edge .Bridge.LTAS.ApproachSign5.Sensor.u_off when Off;
        end
      end
      plant automaton On15Timer:
        alg bool EnablementGuard = On;
        alg bool DisablementGuard = not On;
        location Off:
          initial;
          marked;
          edge .Bridge.LTAS.On15Timer.c_on when EnablementGuard goto Running;
        location Running:
          edge .Bridge.LTAS.On15Timer.c_reset when DisablementGuard goto Off;
          edge .Bridge.LTAS.On15Timer.u_timeout goto Finished;
        location Finished:
          marked;
          edge .Bridge.LTAS.On15Timer.c_reset when DisablementGuard goto Off;
      end
      plant automaton On20Timer:
        alg bool EnablementGuard = On;
        alg bool DisablementGuard = not On;
        location Off:
          initial;
          marked;
          edge .Bridge.LTAS.On20Timer.c_on when EnablementGuard goto Running;
        location Running:
          edge .Bridge.LTAS.On20Timer.c_reset when DisablementGuard goto Off;
          edge .Bridge.LTAS.On20Timer.u_timeout goto Finished;
        location Finished:
          marked;
          edge .Bridge.LTAS.On20Timer.c_reset when DisablementGuard goto Off;
      end
      plant automaton NearOff60Timer:
        alg bool EnablementGuard = NearOff;
        alg bool DisablementGuard = not NearOff;
        location Off:
          initial;
          marked;
          edge .Bridge.LTAS.NearOff60Timer.c_on when EnablementGuard goto Running;
        location Running:
          edge .Bridge.LTAS.NearOff60Timer.c_reset when DisablementGuard goto Off;
          edge .Bridge.LTAS.NearOff60Timer.u_timeout goto Finished;
        location Finished:
          marked;
          edge .Bridge.LTAS.NearOff60Timer.c_reset when DisablementGuard goto Off;
      end
    end
    group LTSS:
      alg bool On = StopSign1.On and StopSign2.On and StopSign3.On and StopSign4.On and StopSign5.On and StopSign6.On and StopSign7.On and StopSign8.On and StopSign9.On and StopSign10.On and StopSign11.On and StopSign12.On and MainLaneActuator.On and SwitchLaneActuator.On;
      alg bool Off = StopSign1.Off and StopSign2.Off and StopSign3.Off and StopSign4.Off and StopSign5.Off and StopSign6.Off and StopSign7.Off and StopSign8.Off and StopSign9.Off and StopSign10.Off and StopSign11.Off and StopSign12.Off and MainLaneActuator.Off and SwitchLaneActuator.Off;
      alg bool On15TimeOk = On15Timer.Finished and On;
      alg bool Off60TimeOk = Off60Timer.Finished and Off;
      plant automaton MainLaneActuator:
        alg bool InitialLocationOn = false;
        location Off:
          initial not InitialLocationOn;
          marked not InitialLocationOn;
          edge .Bridge.LTSS.MainLaneActuator.c_on goto On;
        location On:
          initial InitialLocationOn;
          marked InitialLocationOn;
          edge .Bridge.LTSS.MainLaneActuator.c_off goto Off;
      end
      plant automaton SwitchLaneActuator:
        alg bool InitialLocationOn = false;
        location Off:
          initial not InitialLocationOn;
          marked not InitialLocationOn;
          edge .Bridge.LTSS.SwitchLaneActuator.c_on goto On;
        location On:
          initial InitialLocationOn;
          marked InitialLocationOn;
          edge .Bridge.LTSS.SwitchLaneActuator.c_off goto Off;
      end
      group StopSign1:
        alg bool On = Sensor.On;
        alg bool Off = Sensor.Off;
        plant automaton Sensor:
          alg bool InitialLocationOn = false;
          location Off:
            initial not InitialLocationOn;
            marked not InitialLocationOn;
            edge .Bridge.LTSS.StopSign1.Sensor.u_on goto On;
          location On:
            initial InitialLocationOn;
            marked InitialLocationOn;
            edge .Bridge.LTSS.StopSign1.Sensor.u_off goto Off;
        end
        plant automaton Dynamics:
          alg bool On = SwitchLaneActuator.On;
          alg bool Off = SwitchLaneActuator.Off;
          location:
            initial;
            marked;
            edge .Bridge.LTSS.StopSign1.Sensor.u_on when On;
            edge .Bridge.LTSS.StopSign1.Sensor.u_off when Off;
        end
      end
      group StopSign2:
        alg bool On = Sensor.On;
        alg bool Off = Sensor.Off;
        plant automaton Sensor:
          alg bool InitialLocationOn = false;
          location Off:
            initial not InitialLocationOn;
            marked not InitialLocationOn;
            edge .Bridge.LTSS.StopSign2.Sensor.u_on goto On;
          location On:
            initial InitialLocationOn;
            marked InitialLocationOn;
            edge .Bridge.LTSS.StopSign2.Sensor.u_off goto Off;
        end
        plant automaton Dynamics:
          alg bool On = SwitchLaneActuator.On;
          alg bool Off = SwitchLaneActuator.Off;
          location:
            initial;
            marked;
            edge .Bridge.LTSS.StopSign2.Sensor.u_on when On;
            edge .Bridge.LTSS.StopSign2.Sensor.u_off when Off;
        end
      end
      group StopSign3:
        alg bool On = Sensor.On;
        alg bool Off = Sensor.Off;
        plant automaton Sensor:
          alg bool InitialLocationOn = false;
          location Off:
            initial not InitialLocationOn;
            marked not InitialLocationOn;
            edge .Bridge.LTSS.StopSign3.Sensor.u_on goto On;
          location On:
            initial InitialLocationOn;
            marked InitialLocationOn;
            edge .Bridge.LTSS.StopSign3.Sensor.u_off goto Off;
        end
        plant automaton Dynamics:
          alg bool On = SwitchLaneActuator.On;
          alg bool Off = SwitchLaneActuator.Off;
          location:
            initial;
            marked;
            edge .Bridge.LTSS.StopSign3.Sensor.u_on when On;
            edge .Bridge.LTSS.StopSign3.Sensor.u_off when Off;
        end
      end
      group StopSign4:
        alg bool On = Sensor.On;
        alg bool Off = Sensor.Off;
        plant automaton Sensor:
          alg bool InitialLocationOn = false;
          location Off:
            initial not InitialLocationOn;
            marked not InitialLocationOn;
            edge .Bridge.LTSS.StopSign4.Sensor.u_on goto On;
          location On:
            initial InitialLocationOn;
            marked InitialLocationOn;
            edge .Bridge.LTSS.StopSign4.Sensor.u_off goto Off;
        end
        plant automaton Dynamics:
          alg bool On = SwitchLaneActuator.On;
          alg bool Off = SwitchLaneActuator.Off;
          location:
            initial;
            marked;
            edge .Bridge.LTSS.StopSign4.Sensor.u_on when On;
            edge .Bridge.LTSS.StopSign4.Sensor.u_off when Off;
        end
      end
      group StopSign5:
        alg bool On = Sensor.On;
        alg bool Off = Sensor.Off;
        plant automaton Sensor:
          alg bool InitialLocationOn = false;
          location Off:
            initial not InitialLocationOn;
            marked not InitialLocationOn;
            edge .Bridge.LTSS.StopSign5.Sensor.u_on goto On;
          location On:
            initial InitialLocationOn;
            marked InitialLocationOn;
            edge .Bridge.LTSS.StopSign5.Sensor.u_off goto Off;
        end
        plant automaton Dynamics:
          alg bool On = MainLaneActuator.On;
          alg bool Off = MainLaneActuator.Off;
          location:
            initial;
            marked;
            edge .Bridge.LTSS.StopSign5.Sensor.u_on when On;
            edge .Bridge.LTSS.StopSign5.Sensor.u_off when Off;
        end
      end
      group StopSign6:
        alg bool On = Sensor.On;
        alg bool Off = Sensor.Off;
        plant automaton Sensor:
          alg bool InitialLocationOn = false;
          location Off:
            initial not InitialLocationOn;
            marked not InitialLocationOn;
            edge .Bridge.LTSS.StopSign6.Sensor.u_on goto On;
          location On:
            initial InitialLocationOn;
            marked InitialLocationOn;
            edge .Bridge.LTSS.StopSign6.Sensor.u_off goto Off;
        end
        plant automaton Dynamics:
          alg bool On = MainLaneActuator.On;
          alg bool Off = MainLaneActuator.Off;
          location:
            initial;
            marked;
            edge .Bridge.LTSS.StopSign6.Sensor.u_on when On;
            edge .Bridge.LTSS.StopSign6.Sensor.u_off when Off;
        end
      end
      group StopSign7:
        alg bool On = Sensor.On;
        alg bool Off = Sensor.Off;
        plant automaton Sensor:
          alg bool InitialLocationOn = false;
          location Off:
            initial not InitialLocationOn;
            marked not InitialLocationOn;
            edge .Bridge.LTSS.StopSign7.Sensor.u_on goto On;
          location On:
            initial InitialLocationOn;
            marked InitialLocationOn;
            edge .Bridge.LTSS.StopSign7.Sensor.u_off goto Off;
        end
        plant automaton Dynamics:
          alg bool On = MainLaneActuator.On;
          alg bool Off = MainLaneActuator.Off;
          location:
            initial;
            marked;
            edge .Bridge.LTSS.StopSign7.Sensor.u_on when On;
            edge .Bridge.LTSS.StopSign7.Sensor.u_off when Off;
        end
      end
      group StopSign8:
        alg bool On = Sensor.On;
        alg bool Off = Sensor.Off;
        plant automaton Sensor:
          alg bool InitialLocationOn = false;
          location Off:
            initial not InitialLocationOn;
            marked not InitialLocationOn;
            edge .Bridge.LTSS.StopSign8.Sensor.u_on goto On;
          location On:
            initial InitialLocationOn;
            marked InitialLocationOn;
            edge .Bridge.LTSS.StopSign8.Sensor.u_off goto Off;
        end
        plant automaton Dynamics:
          alg bool On = MainLaneActuator.On;
          alg bool Off = MainLaneActuator.Off;
          location:
            initial;
            marked;
            edge .Bridge.LTSS.StopSign8.Sensor.u_on when On;
            edge .Bridge.LTSS.StopSign8.Sensor.u_off when Off;
        end
      end
      group StopSign9:
        alg bool On = Sensor.On;
        alg bool Off = Sensor.Off;
        plant automaton Sensor:
          alg bool InitialLocationOn = false;
          location Off:
            initial not InitialLocationOn;
            marked not InitialLocationOn;
            edge .Bridge.LTSS.StopSign9.Sensor.u_on goto On;
          location On:
            initial InitialLocationOn;
            marked InitialLocationOn;
            edge .Bridge.LTSS.StopSign9.Sensor.u_off goto Off;
        end
        plant automaton Dynamics:
          alg bool On = MainLaneActuator.On;
          alg bool Off = MainLaneActuator.Off;
          location:
            initial;
            marked;
            edge .Bridge.LTSS.StopSign9.Sensor.u_on when On;
            edge .Bridge.LTSS.StopSign9.Sensor.u_off when Off;
        end
      end
      group StopSign10:
        alg bool On = Sensor.On;
        alg bool Off = Sensor.Off;
        plant automaton Sensor:
          alg bool InitialLocationOn = false;
          location Off:
            initial not InitialLocationOn;
            marked not InitialLocationOn;
            edge .Bridge.LTSS.StopSign10.Sensor.u_on goto On;
          location On:
            initial InitialLocationOn;
            marked InitialLocationOn;
            edge .Bridge.LTSS.StopSign10.Sensor.u_off goto Off;
        end
        plant automaton Dynamics:
          alg bool On = MainLaneActuator.On;
          alg bool Off = MainLaneActuator.Off;
          location:
            initial;
            marked;
            edge .Bridge.LTSS.StopSign10.Sensor.u_on when On;
            edge .Bridge.LTSS.StopSign10.Sensor.u_off when Off;
        end
      end
      group StopSign11:
        alg bool On = Sensor.On;
        alg bool Off = Sensor.Off;
        plant automaton Sensor:
          alg bool InitialLocationOn = false;
          location Off:
            initial not InitialLocationOn;
            marked not InitialLocationOn;
            edge .Bridge.LTSS.StopSign11.Sensor.u_on goto On;
          location On:
            initial InitialLocationOn;
            marked InitialLocationOn;
            edge .Bridge.LTSS.StopSign11.Sensor.u_off goto Off;
        end
        plant automaton Dynamics:
          alg bool On = MainLaneActuator.On;
          alg bool Off = MainLaneActuator.Off;
          location:
            initial;
            marked;
            edge .Bridge.LTSS.StopSign11.Sensor.u_on when On;
            edge .Bridge.LTSS.StopSign11.Sensor.u_off when Off;
        end
      end
      group StopSign12:
        alg bool On = Sensor.On;
        alg bool Off = Sensor.Off;
        plant automaton Sensor:
          alg bool InitialLocationOn = false;
          location Off:
            initial not InitialLocationOn;
            marked not InitialLocationOn;
            edge .Bridge.LTSS.StopSign12.Sensor.u_on goto On;
          location On:
            initial InitialLocationOn;
            marked InitialLocationOn;
            edge .Bridge.LTSS.StopSign12.Sensor.u_off goto Off;
        end
        plant automaton Dynamics:
          alg bool On = MainLaneActuator.On;
          alg bool Off = MainLaneActuator.Off;
          location:
            initial;
            marked;
            edge .Bridge.LTSS.StopSign12.Sensor.u_on when On;
            edge .Bridge.LTSS.StopSign12.Sensor.u_off when Off;
        end
      end
      plant automaton On15Timer:
        alg bool EnablementGuard = On;
        alg bool DisablementGuard = not On;
        location Off:
          initial;
          marked;
          edge .Bridge.LTSS.On15Timer.c_on when EnablementGuard goto Running;
        location Running:
          edge .Bridge.LTSS.On15Timer.c_reset when DisablementGuard goto Off;
          edge .Bridge.LTSS.On15Timer.u_timeout goto Finished;
        location Finished:
          marked;
          edge .Bridge.LTSS.On15Timer.c_reset when DisablementGuard goto Off;
      end
      plant automaton Off60Timer:
        alg bool EnablementGuard = .sup.Bridge.LTSS.Off;
        alg bool DisablementGuard = not .sup.Bridge.LTSS.Off;
        location Off:
          initial;
          marked;
          edge .Bridge.LTSS.Off60Timer.c_on when EnablementGuard goto Running;
        location Running:
          edge .Bridge.LTSS.Off60Timer.c_reset when DisablementGuard goto Off;
          edge .Bridge.LTSS.Off60Timer.u_timeout goto Finished;
        location Finished:
          marked;
          edge .Bridge.LTSS.Off60Timer.c_reset when DisablementGuard goto Off;
      end
    end
    group Barriers:
      alg bool EnteringClosed = B3.Closed and B6.Closed;
      alg bool LeavingClosed = B2.Closed and B7.Closed;
      alg bool LeavingOpen = B2.Open and B7.Open;
      alg bool SlowClosed = B4.Closed and B8.Closed;
      alg bool Closed = B1.Closed and B2.Closed and B3.Closed and B4.Closed and B5.Closed and B6.Closed and B7.Closed and B8.Closed;
      alg bool Open = B1.Open and B2.Open and B3.Open and B4.Open and B5.Open and B6.Open and B7.Open and B8.Open;
      alg bool B3B6Closed1TimeOk = B3B6Closed1Timer.Finished and EnteringClosed;
      alg bool B2B7Open1TimeOk = B2B7Open1Timer.Finished and LeavingOpen;
      alg bool SoundOn6TimeOk = SoundOn6Timer.Finished and SoundSignals.On;
      group B1:
        alg bool Moving = not Actuator.Rest;
        alg bool Closed = Actuator.Rest and Sensor.Closed;
        alg bool Open = Actuator.Rest and Sensor.Open;
        alg bool InitialLocationClosed = false;
        plant automaton Actuator:
          location Rest:
            initial;
            marked;
            edge .Bridge.Barriers.B1.Actuator.c_open goto Opening;
            edge .Bridge.Barriers.B1.Actuator.c_close goto Closing;
          location Opening:
            edge .Bridge.Barriers.B1.Actuator.c_emrgStop, .Bridge.Barriers.B1.Actuator.c_endStopOpening goto Rest;
          location Closing:
            edge .Bridge.Barriers.B1.Actuator.c_emrgStop, .Bridge.Barriers.B1.Actuator.c_endStopClosing goto Rest;
        end
        plant automaton Sensor:
          alg bool InitialLocationClosed = .sup.Bridge.Barriers.B1.InitialLocationClosed;
          location Closed:
            initial InitialLocationClosed;
            marked InitialLocationClosed;
            edge .Bridge.Barriers.B1.Sensor.u_closed_off goto Intermediate;
          location Intermediate:
            edge .Bridge.Barriers.B1.Sensor.u_closed_on goto Closed;
            edge .Bridge.Barriers.B1.Sensor.u_open_on goto Open;
          location Open:
            initial not InitialLocationClosed;
            marked not InitialLocationClosed;
            edge .Bridge.Barriers.B1.Sensor.u_open_off goto Intermediate;
        end
        plant automaton Dynamics:
          location:
            initial;
            marked;
            edge .Bridge.Barriers.B1.Sensor.u_open_on, .Bridge.Barriers.B1.Sensor.u_closed_off when Actuator.Opening;
            edge .Bridge.Barriers.B1.Sensor.u_closed_on, .Bridge.Barriers.B1.Sensor.u_open_off when Actuator.Closing;
        end
        requirement invariant .Bridge.Barriers.B1.Actuator.c_endStopOpening needs Sensor.Open;
        requirement invariant .Bridge.Barriers.B1.Actuator.c_endStopClosing needs Sensor.Closed;
        requirement invariant .Bridge.Barriers.B1.Actuator.c_open needs not Sensor.Open;
        requirement invariant .Bridge.Barriers.B1.Actuator.c_close needs not Sensor.Closed;
      end
      group B2:
        alg bool Moving = not Actuator.Rest;
        alg bool Closed = Actuator.Rest and Sensor.Closed;
        alg bool Open = Actuator.Rest and Sensor.Open;
        alg bool InitialLocationClosed = false;
        plant automaton Actuator:
          location Rest:
            initial;
            marked;
            edge .Bridge.Barriers.B2.Actuator.c_open goto Opening;
            edge .Bridge.Barriers.B2.Actuator.c_close goto Closing;
          location Opening:
            edge .Bridge.Barriers.B2.Actuator.c_emrgStop, .Bridge.Barriers.B2.Actuator.c_endStopOpening goto Rest;
          location Closing:
            edge .Bridge.Barriers.B2.Actuator.c_emrgStop, .Bridge.Barriers.B2.Actuator.c_endStopClosing goto Rest;
        end
        plant automaton Sensor:
          alg bool InitialLocationClosed = .sup.Bridge.Barriers.B2.InitialLocationClosed;
          location Closed:
            initial InitialLocationClosed;
            marked InitialLocationClosed;
            edge .Bridge.Barriers.B2.Sensor.u_closed_off goto Intermediate;
          location Intermediate:
            edge .Bridge.Barriers.B2.Sensor.u_closed_on goto Closed;
            edge .Bridge.Barriers.B2.Sensor.u_open_on goto Open;
          location Open:
            initial not InitialLocationClosed;
            marked not InitialLocationClosed;
            edge .Bridge.Barriers.B2.Sensor.u_open_off goto Intermediate;
        end
        plant automaton Dynamics:
          location:
            initial;
            marked;
            edge .Bridge.Barriers.B2.Sensor.u_open_on, .Bridge.Barriers.B2.Sensor.u_closed_off when Actuator.Opening;
            edge .Bridge.Barriers.B2.Sensor.u_closed_on, .Bridge.Barriers.B2.Sensor.u_open_off when Actuator.Closing;
        end
        requirement invariant .Bridge.Barriers.B2.Actuator.c_endStopOpening needs Sensor.Open;
        requirement invariant .Bridge.Barriers.B2.Actuator.c_endStopClosing needs Sensor.Closed;
        requirement invariant .Bridge.Barriers.B2.Actuator.c_open needs not Sensor.Open;
        requirement invariant .Bridge.Barriers.B2.Actuator.c_close needs not Sensor.Closed;
      end
      group B3:
        alg bool Moving = not Actuator.Rest;
        alg bool Closed = Actuator.Rest and Sensor.Closed;
        alg bool Open = Actuator.Rest and Sensor.Open;
        alg bool InitialLocationClosed = false;
        plant automaton Actuator:
          location Rest:
            initial;
            marked;
            edge .Bridge.Barriers.B3.Actuator.c_open goto Opening;
            edge .Bridge.Barriers.B3.Actuator.c_close goto Closing;
          location Opening:
            edge .Bridge.Barriers.B3.Actuator.c_emrgStop, .Bridge.Barriers.B3.Actuator.c_endStopOpening goto Rest;
          location Closing:
            edge .Bridge.Barriers.B3.Actuator.c_emrgStop, .Bridge.Barriers.B3.Actuator.c_endStopClosing goto Rest;
        end
        plant automaton Sensor:
          alg bool InitialLocationClosed = .sup.Bridge.Barriers.B3.InitialLocationClosed;
          location Closed:
            initial InitialLocationClosed;
            marked InitialLocationClosed;
            edge .Bridge.Barriers.B3.Sensor.u_closed_off goto Intermediate;
          location Intermediate:
            edge .Bridge.Barriers.B3.Sensor.u_closed_on goto Closed;
            edge .Bridge.Barriers.B3.Sensor.u_open_on goto Open;
          location Open:
            initial not InitialLocationClosed;
            marked not InitialLocationClosed;
            edge .Bridge.Barriers.B3.Sensor.u_open_off goto Intermediate;
        end
        plant automaton Dynamics:
          location:
            initial;
            marked;
            edge .Bridge.Barriers.B3.Sensor.u_open_on, .Bridge.Barriers.B3.Sensor.u_closed_off when Actuator.Opening;
            edge .Bridge.Barriers.B3.Sensor.u_closed_on, .Bridge.Barriers.B3.Sensor.u_open_off when Actuator.Closing;
        end
        requirement invariant .Bridge.Barriers.B3.Actuator.c_endStopOpening needs Sensor.Open;
        requirement invariant .Bridge.Barriers.B3.Actuator.c_endStopClosing needs Sensor.Closed;
        requirement invariant .Bridge.Barriers.B3.Actuator.c_open needs not Sensor.Open;
        requirement invariant .Bridge.Barriers.B3.Actuator.c_close needs not Sensor.Closed;
      end
      group B4:
        alg bool Moving = not Actuator.Rest;
        alg bool Closed = Actuator.Rest and Sensor.Closed;
        alg bool Open = Actuator.Rest and Sensor.Open;
        alg bool InitialLocationClosed = false;
        plant automaton Actuator:
          location Rest:
            initial;
            marked;
            edge .Bridge.Barriers.B4.Actuator.c_open goto Opening;
            edge .Bridge.Barriers.B4.Actuator.c_close goto Closing;
          location Opening:
            edge .Bridge.Barriers.B4.Actuator.c_emrgStop, .Bridge.Barriers.B4.Actuator.c_endStopOpening goto Rest;
          location Closing:
            edge .Bridge.Barriers.B4.Actuator.c_emrgStop, .Bridge.Barriers.B4.Actuator.c_endStopClosing goto Rest;
        end
        plant automaton Sensor:
          alg bool InitialLocationClosed = .sup.Bridge.Barriers.B4.InitialLocationClosed;
          location Closed:
            initial InitialLocationClosed;
            marked InitialLocationClosed;
            edge .Bridge.Barriers.B4.Sensor.u_closed_off goto Intermediate;
          location Intermediate:
            edge .Bridge.Barriers.B4.Sensor.u_closed_on goto Closed;
            edge .Bridge.Barriers.B4.Sensor.u_open_on goto Open;
          location Open:
            initial not InitialLocationClosed;
            marked not InitialLocationClosed;
            edge .Bridge.Barriers.B4.Sensor.u_open_off goto Intermediate;
        end
        plant automaton Dynamics:
          location:
            initial;
            marked;
            edge .Bridge.Barriers.B4.Sensor.u_open_on, .Bridge.Barriers.B4.Sensor.u_closed_off when Actuator.Opening;
            edge .Bridge.Barriers.B4.Sensor.u_closed_on, .Bridge.Barriers.B4.Sensor.u_open_off when Actuator.Closing;
        end
        requirement invariant .Bridge.Barriers.B4.Actuator.c_endStopOpening needs Sensor.Open;
        requirement invariant .Bridge.Barriers.B4.Actuator.c_endStopClosing needs Sensor.Closed;
        requirement invariant .Bridge.Barriers.B4.Actuator.c_open needs not Sensor.Open;
        requirement invariant .Bridge.Barriers.B4.Actuator.c_close needs not Sensor.Closed;
      end
      group B5:
        alg bool Moving = not Actuator.Rest;
        alg bool Closed = Actuator.Rest and Sensor.Closed;
        alg bool Open = Actuator.Rest and Sensor.Open;
        alg bool InitialLocationClosed = false;
        plant automaton Actuator:
          location Rest:
            initial;
            marked;
            edge .Bridge.Barriers.B5.Actuator.c_open goto Opening;
            edge .Bridge.Barriers.B5.Actuator.c_close goto Closing;
          location Opening:
            edge .Bridge.Barriers.B5.Actuator.c_emrgStop, .Bridge.Barriers.B5.Actuator.c_endStopOpening goto Rest;
          location Closing:
            edge .Bridge.Barriers.B5.Actuator.c_emrgStop, .Bridge.Barriers.B5.Actuator.c_endStopClosing goto Rest;
        end
        plant automaton Sensor:
          alg bool InitialLocationClosed = .sup.Bridge.Barriers.B5.InitialLocationClosed;
          location Closed:
            initial InitialLocationClosed;
            marked InitialLocationClosed;
            edge .Bridge.Barriers.B5.Sensor.u_closed_off goto Intermediate;
          location Intermediate:
            edge .Bridge.Barriers.B5.Sensor.u_closed_on goto Closed;
            edge .Bridge.Barriers.B5.Sensor.u_open_on goto Open;
          location Open:
            initial not InitialLocationClosed;
            marked not InitialLocationClosed;
            edge .Bridge.Barriers.B5.Sensor.u_open_off goto Intermediate;
        end
        plant automaton Dynamics:
          location:
            initial;
            marked;
            edge .Bridge.Barriers.B5.Sensor.u_open_on, .Bridge.Barriers.B5.Sensor.u_closed_off when Actuator.Opening;
            edge .Bridge.Barriers.B5.Sensor.u_closed_on, .Bridge.Barriers.B5.Sensor.u_open_off when Actuator.Closing;
        end
        requirement invariant .Bridge.Barriers.B5.Actuator.c_endStopOpening needs Sensor.Open;
        requirement invariant .Bridge.Barriers.B5.Actuator.c_endStopClosing needs Sensor.Closed;
        requirement invariant .Bridge.Barriers.B5.Actuator.c_open needs not Sensor.Open;
        requirement invariant .Bridge.Barriers.B5.Actuator.c_close needs not Sensor.Closed;
      end
      group B6:
        alg bool Moving = not Actuator.Rest;
        alg bool Closed = Actuator.Rest and Sensor.Closed;
        alg bool Open = Actuator.Rest and Sensor.Open;
        alg bool InitialLocationClosed = false;
        plant automaton Actuator:
          location Rest:
            initial;
            marked;
            edge .Bridge.Barriers.B6.Actuator.c_open goto Opening;
            edge .Bridge.Barriers.B6.Actuator.c_close goto Closing;
          location Opening:
            edge .Bridge.Barriers.B6.Actuator.c_emrgStop, .Bridge.Barriers.B6.Actuator.c_endStopOpening goto Rest;
          location Closing:
            edge .Bridge.Barriers.B6.Actuator.c_emrgStop, .Bridge.Barriers.B6.Actuator.c_endStopClosing goto Rest;
        end
        plant automaton Sensor:
          alg bool InitialLocationClosed = .sup.Bridge.Barriers.B6.InitialLocationClosed;
          location Closed:
            initial InitialLocationClosed;
            marked InitialLocationClosed;
            edge .Bridge.Barriers.B6.Sensor.u_closed_off goto Intermediate;
          location Intermediate:
            edge .Bridge.Barriers.B6.Sensor.u_closed_on goto Closed;
            edge .Bridge.Barriers.B6.Sensor.u_open_on goto Open;
          location Open:
            initial not InitialLocationClosed;
            marked not InitialLocationClosed;
            edge .Bridge.Barriers.B6.Sensor.u_open_off goto Intermediate;
        end
        plant automaton Dynamics:
          location:
            initial;
            marked;
            edge .Bridge.Barriers.B6.Sensor.u_open_on, .Bridge.Barriers.B6.Sensor.u_closed_off when Actuator.Opening;
            edge .Bridge.Barriers.B6.Sensor.u_closed_on, .Bridge.Barriers.B6.Sensor.u_open_off when Actuator.Closing;
        end
        requirement invariant .Bridge.Barriers.B6.Actuator.c_endStopOpening needs Sensor.Open;
        requirement invariant .Bridge.Barriers.B6.Actuator.c_endStopClosing needs Sensor.Closed;
        requirement invariant .Bridge.Barriers.B6.Actuator.c_open needs not Sensor.Open;
        requirement invariant .Bridge.Barriers.B6.Actuator.c_close needs not Sensor.Closed;
      end
      group B7:
        alg bool Moving = not Actuator.Rest;
        alg bool Closed = Actuator.Rest and Sensor.Closed;
        alg bool Open = Actuator.Rest and Sensor.Open;
        alg bool InitialLocationClosed = false;
        plant automaton Actuator:
          location Rest:
            initial;
            marked;
            edge .Bridge.Barriers.B7.Actuator.c_open goto Opening;
            edge .Bridge.Barriers.B7.Actuator.c_close goto Closing;
          location Opening:
            edge .Bridge.Barriers.B7.Actuator.c_emrgStop, .Bridge.Barriers.B7.Actuator.c_endStopOpening goto Rest;
          location Closing:
            edge .Bridge.Barriers.B7.Actuator.c_emrgStop, .Bridge.Barriers.B7.Actuator.c_endStopClosing goto Rest;
        end
        plant automaton Sensor:
          alg bool InitialLocationClosed = .sup.Bridge.Barriers.B7.InitialLocationClosed;
          location Closed:
            initial InitialLocationClosed;
            marked InitialLocationClosed;
            edge .Bridge.Barriers.B7.Sensor.u_closed_off goto Intermediate;
          location Intermediate:
            edge .Bridge.Barriers.B7.Sensor.u_closed_on goto Closed;
            edge .Bridge.Barriers.B7.Sensor.u_open_on goto Open;
          location Open:
            initial not InitialLocationClosed;
            marked not InitialLocationClosed;
            edge .Bridge.Barriers.B7.Sensor.u_open_off goto Intermediate;
        end
        plant automaton Dynamics:
          location:
            initial;
            marked;
            edge .Bridge.Barriers.B7.Sensor.u_open_on, .Bridge.Barriers.B7.Sensor.u_closed_off when Actuator.Opening;
            edge .Bridge.Barriers.B7.Sensor.u_closed_on, .Bridge.Barriers.B7.Sensor.u_open_off when Actuator.Closing;
        end
        requirement invariant .Bridge.Barriers.B7.Actuator.c_endStopOpening needs Sensor.Open;
        requirement invariant .Bridge.Barriers.B7.Actuator.c_endStopClosing needs Sensor.Closed;
        requirement invariant .Bridge.Barriers.B7.Actuator.c_open needs not Sensor.Open;
        requirement invariant .Bridge.Barriers.B7.Actuator.c_close needs not Sensor.Closed;
      end
      group B8:
        alg bool Moving = not Actuator.Rest;
        alg bool Closed = Actuator.Rest and Sensor.Closed;
        alg bool Open = Actuator.Rest and Sensor.Open;
        alg bool InitialLocationClosed = false;
        plant automaton Actuator:
          location Rest:
            initial;
            marked;
            edge .Bridge.Barriers.B8.Actuator.c_open goto Opening;
            edge .Bridge.Barriers.B8.Actuator.c_close goto Closing;
          location Opening:
            edge .Bridge.Barriers.B8.Actuator.c_emrgStop, .Bridge.Barriers.B8.Actuator.c_endStopOpening goto Rest;
          location Closing:
            edge .Bridge.Barriers.B8.Actuator.c_emrgStop, .Bridge.Barriers.B8.Actuator.c_endStopClosing goto Rest;
        end
        plant automaton Sensor:
          alg bool InitialLocationClosed = .sup.Bridge.Barriers.B8.InitialLocationClosed;
          location Closed:
            initial InitialLocationClosed;
            marked InitialLocationClosed;
            edge .Bridge.Barriers.B8.Sensor.u_closed_off goto Intermediate;
          location Intermediate:
            edge .Bridge.Barriers.B8.Sensor.u_closed_on goto Closed;
            edge .Bridge.Barriers.B8.Sensor.u_open_on goto Open;
          location Open:
            initial not InitialLocationClosed;
            marked not InitialLocationClosed;
            edge .Bridge.Barriers.B8.Sensor.u_open_off goto Intermediate;
        end
        plant automaton Dynamics:
          location:
            initial;
            marked;
            edge .Bridge.Barriers.B8.Sensor.u_open_on, .Bridge.Barriers.B8.Sensor.u_closed_off when Actuator.Opening;
            edge .Bridge.Barriers.B8.Sensor.u_closed_on, .Bridge.Barriers.B8.Sensor.u_open_off when Actuator.Closing;
        end
        requirement invariant .Bridge.Barriers.B8.Actuator.c_endStopOpening needs Sensor.Open;
        requirement invariant .Bridge.Barriers.B8.Actuator.c_endStopClosing needs Sensor.Closed;
        requirement invariant .Bridge.Barriers.B8.Actuator.c_open needs not Sensor.Open;
        requirement invariant .Bridge.Barriers.B8.Actuator.c_close needs not Sensor.Closed;
      end
      plant automaton LightSignals:
        alg bool InitialLocationOn = false;
        location Off:
          initial not InitialLocationOn;
          marked not InitialLocationOn;
          edge .Bridge.Barriers.LightSignals.c_on goto On;
        location On:
          initial InitialLocationOn;
          marked InitialLocationOn;
          edge .Bridge.Barriers.LightSignals.c_off goto Off;
      end
      plant automaton SoundSignals:
        alg bool InitialLocationOn = false;
        location Off:
          initial not InitialLocationOn;
          marked not InitialLocationOn;
          edge .Bridge.Barriers.SoundSignals.c_on goto On;
        location On:
          initial InitialLocationOn;
          marked InitialLocationOn;
          edge .Bridge.Barriers.SoundSignals.c_off goto Off;
      end
      plant automaton B3B6Closed1Timer:
        alg bool EnablementGuard = EnteringClosed;
        alg bool DisablementGuard = not EnteringClosed;
        location Off:
          initial;
          marked;
          edge .Bridge.Barriers.B3B6Closed1Timer.c_on when EnablementGuard goto Running;
        location Running:
          edge .Bridge.Barriers.B3B6Closed1Timer.c_reset when DisablementGuard goto Off;
          edge .Bridge.Barriers.B3B6Closed1Timer.u_timeout goto Finished;
        location Finished:
          marked;
          edge .Bridge.Barriers.B3B6Closed1Timer.c_reset when DisablementGuard goto Off;
      end
      plant automaton B2B7Open1Timer:
        alg bool EnablementGuard = LeavingOpen;
        alg bool DisablementGuard = not LeavingOpen;
        location Off:
          initial;
          marked;
          edge .Bridge.Barriers.B2B7Open1Timer.c_on when EnablementGuard goto Running;
        location Running:
          edge .Bridge.Barriers.B2B7Open1Timer.c_reset when DisablementGuard goto Off;
          edge .Bridge.Barriers.B2B7Open1Timer.u_timeout goto Finished;
        location Finished:
          marked;
          edge .Bridge.Barriers.B2B7Open1Timer.c_reset when DisablementGuard goto Off;
      end
      plant automaton SoundOn6Timer:
        alg bool EnablementGuard = SoundSignals.On;
        alg bool DisablementGuard = SoundSignals.Off;
        location Off:
          initial;
          marked;
          edge .Bridge.Barriers.SoundOn6Timer.c_on when EnablementGuard goto Running;
        location Running:
          edge .Bridge.Barriers.SoundOn6Timer.c_reset when DisablementGuard goto Off;
          edge .Bridge.Barriers.SoundOn6Timer.u_timeout goto Finished;
        location Finished:
          marked;
          edge .Bridge.Barriers.SoundOn6Timer.c_reset when DisablementGuard goto Off;
      end
    end
    group Deck:
      alg bool Moving = not Actuator.Rest;
      alg bool Closed = Actuator.Rest and Sensor.Closed;
      alg bool Open = Actuator.Rest and Sensor.Open;
      alg bool InitialLocationClosed = true;
      plant automaton Actuator:
        location Rest:
          initial;
          marked;
          edge .Bridge.Deck.Actuator.c_open goto Opening;
          edge .Bridge.Deck.Actuator.c_close goto Closing;
        location Opening:
          edge .Bridge.Deck.Actuator.c_emrgStop, .Bridge.Deck.Actuator.c_endStopOpening goto Rest;
        location Closing:
          edge .Bridge.Deck.Actuator.c_emrgStop, .Bridge.Deck.Actuator.c_endStopClosing goto Rest;
      end
      plant automaton Sensor:
        alg bool InitialLocationClosed = .sup.Bridge.Deck.InitialLocationClosed;
        location Closed:
          initial InitialLocationClosed;
          marked InitialLocationClosed;
          edge .Bridge.Deck.Sensor.u_closed_off goto Intermediate;
        location Intermediate:
          edge .Bridge.Deck.Sensor.u_closed_on goto Closed;
          edge .Bridge.Deck.Sensor.u_open_on goto Open;
        location Open:
          initial not InitialLocationClosed;
          marked not InitialLocationClosed;
          edge .Bridge.Deck.Sensor.u_open_off goto Intermediate;
      end
      plant automaton Dynamics:
        location:
          initial;
          marked;
          edge .Bridge.Deck.Sensor.u_open_on, .Bridge.Deck.Sensor.u_closed_off when Actuator.Opening;
          edge .Bridge.Deck.Sensor.u_closed_on, .Bridge.Deck.Sensor.u_open_off when Actuator.Closing;
      end
      requirement invariant .Bridge.Deck.Actuator.c_endStopOpening needs Sensor.Open;
      requirement invariant .Bridge.Deck.Actuator.c_endStopClosing needs Sensor.Closed;
      requirement invariant .Bridge.Deck.Actuator.c_open needs not Sensor.Open;
      requirement invariant .Bridge.Deck.Actuator.c_close needs not Sensor.Closed;
    end
    plant automaton CloseRequest:
      alg bool InitialLocationOn = false;
      location Off:
        initial not InitialLocationOn;
        marked not InitialLocationOn;
        edge .Bridge.CloseRequest.u_on goto On;
      location On:
        initial InitialLocationOn;
        marked InitialLocationOn;
        edge .Bridge.CloseRequest.u_off goto Off;
    end
  end
  supervisor automaton sup:
    alphabet .Lock.LTL.DE.Actuator.c_r, .Lock.LTL.DE.Actuator.c_emerg, .Lock.LTL.DE.Actuator.c_rr, .Lock.LTL.DE.Actuator.c_rg, .Lock.LTL.DE.Actuator.c_g, .Lock.LTL.DW.Actuator.c_r, .Lock.LTL.DW.Actuator.c_emerg, .Lock.LTL.DW.Actuator.c_rr, .Lock.LTL.DW.Actuator.c_rg, .Lock.LTL.DW.Actuator.c_g, .Lock.LTL.UE.Actuator.c_r, .Lock.LTL.UE.Actuator.c_emerg, .Lock.LTL.UE.Actuator.c_rr, .Lock.LTL.UE.Actuator.c_rg, .Lock.LTL.UE.Actuator.c_g, .Lock.LTL.UW.Actuator.c_r, .Lock.LTL.UW.Actuator.c_emerg, .Lock.LTL.UW.Actuator.c_rr, .Lock.LTL.UW.Actuator.c_rg, .Lock.LTL.UW.Actuator.c_g, .Lock.BTL.DE.Actuator.c_rg, .Lock.BTL.DE.Actuator.c_r, .Lock.BTL.DE.Actuator.c_emerg, .Lock.BTL.DE.Actuator.c_g, .Lock.BTL.DW.Actuator.c_rg, .Lock.BTL.DW.Actuator.c_r, .Lock.BTL.DW.Actuator.c_emerg, .Lock.BTL.DW.Actuator.c_g, .Lock.UpstreamEbb.EastGate.Actuator.c_open, .Lock.UpstreamEbb.EastGate.Actuator.c_close, .Lock.UpstreamEbb.EastGate.Actuator.c_emrgStop, .Lock.UpstreamEbb.EastGate.Actuator.c_endStopOpening, .Lock.UpstreamEbb.EastGate.Actuator.c_endStopClosing, .Lock.UpstreamEbb.WestGate.Actuator.c_open, .Lock.UpstreamEbb.WestGate.Actuator.c_close, .Lock.UpstreamEbb.WestGate.Actuator.c_emrgStop, .Lock.UpstreamEbb.WestGate.Actuator.c_endStopOpening, .Lock.UpstreamEbb.WestGate.Actuator.c_endStopClosing, .Lock.UpstreamEbb.EastPaddle.Actuator.c_open, .Lock.UpstreamEbb.EastPaddle.Actuator.c_close, .Lock.UpstreamEbb.EastPaddle.Actuator.c_emrgStop, .Lock.UpstreamEbb.EastPaddle.Actuator.c_endStopOpening, .Lock.UpstreamEbb.EastPaddle.Actuator.c_endStopClosing, .Lock.UpstreamEbb.WestPaddle.Actuator.c_open, .Lock.UpstreamEbb.WestPaddle.Actuator.c_close, .Lock.UpstreamEbb.WestPaddle.Actuator.c_emrgStop, .Lock.UpstreamEbb.WestPaddle.Actuator.c_endStopOpening, .Lock.UpstreamEbb.WestPaddle.Actuator.c_endStopClosing, .Lock.UpstreamFlood.EastGate.Actuator.c_open, .Lock.UpstreamFlood.EastGate.Actuator.c_close, .Lock.UpstreamFlood.EastGate.Actuator.c_emrgStop, .Lock.UpstreamFlood.EastGate.Actuator.c_endStopOpening, .Lock.UpstreamFlood.EastGate.Actuator.c_endStopClosing, .Lock.UpstreamFlood.WestGate.Actuator.c_open, .Lock.UpstreamFlood.WestGate.Actuator.c_close, .Lock.UpstreamFlood.WestGate.Actuator.c_emrgStop, .Lock.UpstreamFlood.WestGate.Actuator.c_endStopOpening, .Lock.UpstreamFlood.WestGate.Actuator.c_endStopClosing, .Lock.UpstreamFlood.EastPaddle.Actuator.c_open, .Lock.UpstreamFlood.EastPaddle.Actuator.c_close, .Lock.UpstreamFlood.EastPaddle.Actuator.c_emrgStop, .Lock.UpstreamFlood.EastPaddle.Actuator.c_endStopOpening, .Lock.UpstreamFlood.EastPaddle.Actuator.c_endStopClosing, .Lock.UpstreamFlood.WestPaddle.Actuator.c_open, .Lock.UpstreamFlood.WestPaddle.Actuator.c_close, .Lock.UpstreamFlood.WestPaddle.Actuator.c_emrgStop, .Lock.UpstreamFlood.WestPaddle.Actuator.c_endStopOpening, .Lock.UpstreamFlood.WestPaddle.Actuator.c_endStopClosing, .Lock.DownstreamEbb.EastGate.Actuator.c_open, .Lock.DownstreamEbb.EastGate.Actuator.c_close, .Lock.DownstreamEbb.EastGate.Actuator.c_emrgStop, .Lock.DownstreamEbb.EastGate.Actuator.c_endStopOpening, .Lock.DownstreamEbb.EastGate.Actuator.c_endStopClosing, .Lock.DownstreamEbb.WestGate.Actuator.c_open, .Lock.DownstreamEbb.WestGate.Actuator.c_close, .Lock.DownstreamEbb.WestGate.Actuator.c_emrgStop, .Lock.DownstreamEbb.WestGate.Actuator.c_endStopOpening, .Lock.DownstreamEbb.WestGate.Actuator.c_endStopClosing, .Lock.DownstreamEbb.EastPaddle.Actuator.c_open, .Lock.DownstreamEbb.EastPaddle.Actuator.c_close, .Lock.DownstreamEbb.EastPaddle.Actuator.c_emrgStop, .Lock.DownstreamEbb.EastPaddle.Actuator.c_endStopOpening, .Lock.DownstreamEbb.EastPaddle.Actuator.c_endStopClosing, .Lock.DownstreamEbb.WestPaddle.Actuator.c_open, .Lock.DownstreamEbb.WestPaddle.Actuator.c_close, .Lock.DownstreamEbb.WestPaddle.Actuator.c_emrgStop, .Lock.DownstreamEbb.WestPaddle.Actuator.c_endStopOpening, .Lock.DownstreamEbb.WestPaddle.Actuator.c_endStopClosing, .Lock.DownstreamFlood.EastGate.Actuator.c_open, .Lock.DownstreamFlood.EastGate.Actuator.c_close, .Lock.DownstreamFlood.EastGate.Actuator.c_emrgStop, .Lock.DownstreamFlood.EastGate.Actuator.c_endStopOpening, .Lock.DownstreamFlood.EastGate.Actuator.c_endStopClosing, .Lock.DownstreamFlood.WestGate.Actuator.c_open, .Lock.DownstreamFlood.WestGate.Actuator.c_close, .Lock.DownstreamFlood.WestGate.Actuator.c_emrgStop, .Lock.DownstreamFlood.WestGate.Actuator.c_endStopOpening, .Lock.DownstreamFlood.WestGate.Actuator.c_endStopClosing, .Lock.DownstreamFlood.EastPaddle.Actuator.c_open, .Lock.DownstreamFlood.EastPaddle.Actuator.c_close, .Lock.DownstreamFlood.EastPaddle.Actuator.c_emrgStop, .Lock.DownstreamFlood.EastPaddle.Actuator.c_endStopOpening, .Lock.DownstreamFlood.EastPaddle.Actuator.c_endStopClosing, .Lock.DownstreamFlood.WestPaddle.Actuator.c_open, .Lock.DownstreamFlood.WestPaddle.Actuator.c_close, .Lock.DownstreamFlood.WestPaddle.Actuator.c_emrgStop, .Lock.DownstreamFlood.WestPaddle.Actuator.c_endStopOpening, .Lock.DownstreamFlood.WestPaddle.Actuator.c_endStopClosing, .Lock.DownstreamStormFlood.EastGate.Actuator.c_open, .Lock.DownstreamStormFlood.EastGate.Actuator.c_close, .Lock.DownstreamStormFlood.EastGate.Actuator.c_emrgStop, .Lock.DownstreamStormFlood.EastGate.Actuator.c_endStopOpening, .Lock.DownstreamStormFlood.EastGate.Actuator.c_endStopClosing, .Lock.DownstreamStormFlood.WestGate.Actuator.c_open, .Lock.DownstreamStormFlood.WestGate.Actuator.c_close, .Lock.DownstreamStormFlood.WestGate.Actuator.c_emrgStop, .Lock.DownstreamStormFlood.WestGate.Actuator.c_endStopOpening, .Lock.DownstreamStormFlood.WestGate.Actuator.c_endStopClosing, .Lock.DownstreamStormFlood.EastPaddle.Actuator.c_open, .Lock.DownstreamStormFlood.EastPaddle.Actuator.c_close, .Lock.DownstreamStormFlood.EastPaddle.Actuator.c_emrgStop, .Lock.DownstreamStormFlood.EastPaddle.Actuator.c_endStopOpening, .Lock.DownstreamStormFlood.EastPaddle.Actuator.c_endStopClosing, .Lock.DownstreamStormFlood.WestPaddle.Actuator.c_open, .Lock.DownstreamStormFlood.WestPaddle.Actuator.c_close, .Lock.DownstreamStormFlood.WestPaddle.Actuator.c_emrgStop, .Lock.DownstreamStormFlood.WestPaddle.Actuator.c_endStopOpening, .Lock.DownstreamStormFlood.WestPaddle.Actuator.c_endStopClosing, .Bridge.LTAS.FarActuator.c_on, .Bridge.LTAS.FarActuator.c_off, .Bridge.LTAS.NearActuator.c_on, .Bridge.LTAS.NearActuator.c_off, .Bridge.LTAS.On15Timer.c_on, .Bridge.LTAS.On15Timer.c_reset, .Bridge.LTAS.On20Timer.c_on, .Bridge.LTAS.On20Timer.c_reset, .Bridge.LTAS.NearOff60Timer.c_on, .Bridge.LTAS.NearOff60Timer.c_reset, .Bridge.LTSS.MainLaneActuator.c_on, .Bridge.LTSS.MainLaneActuator.c_off, .Bridge.LTSS.SwitchLaneActuator.c_on, .Bridge.LTSS.SwitchLaneActuator.c_off, .Bridge.LTSS.On15Timer.c_on, .Bridge.LTSS.On15Timer.c_reset, .Bridge.LTSS.Off60Timer.c_on, .Bridge.LTSS.Off60Timer.c_reset, .Bridge.Barriers.B1.Actuator.c_open, .Bridge.Barriers.B1.Actuator.c_close, .Bridge.Barriers.B1.Actuator.c_emrgStop, .Bridge.Barriers.B1.Actuator.c_endStopOpening, .Bridge.Barriers.B1.Actuator.c_endStopClosing, .Bridge.Barriers.B2.Actuator.c_open, .Bridge.Barriers.B2.Actuator.c_close, .Bridge.Barriers.B2.Actuator.c_emrgStop, .Bridge.Barriers.B2.Actuator.c_endStopOpening, .Bridge.Barriers.B2.Actuator.c_endStopClosing, .Bridge.Barriers.B3.Actuator.c_open, .Bridge.Barriers.B3.Actuator.c_close, .Bridge.Barriers.B3.Actuator.c_emrgStop, .Bridge.Barriers.B3.Actuator.c_endStopOpening, .Bridge.Barriers.B3.Actuator.c_endStopClosing, .Bridge.Barriers.B4.Actuator.c_open, .Bridge.Barriers.B4.Actuator.c_close, .Bridge.Barriers.B4.Actuator.c_emrgStop, .Bridge.Barriers.B4.Actuator.c_endStopOpening, .Bridge.Barriers.B4.Actuator.c_endStopClosing, .Bridge.Barriers.B5.Actuator.c_open, .Bridge.Barriers.B5.Actuator.c_close, .Bridge.Barriers.B5.Actuator.c_emrgStop, .Bridge.Barriers.B5.Actuator.c_endStopOpening, .Bridge.Barriers.B5.Actuator.c_endStopClosing, .Bridge.Barriers.B6.Actuator.c_open, .Bridge.Barriers.B6.Actuator.c_close, .Bridge.Barriers.B6.Actuator.c_emrgStop, .Bridge.Barriers.B6.Actuator.c_endStopOpening, .Bridge.Barriers.B6.Actuator.c_endStopClosing, .Bridge.Barriers.B7.Actuator.c_open, .Bridge.Barriers.B7.Actuator.c_close, .Bridge.Barriers.B7.Actuator.c_emrgStop, .Bridge.Barriers.B7.Actuator.c_endStopOpening, .Bridge.Barriers.B7.Actuator.c_endStopClosing, .Bridge.Barriers.B8.Actuator.c_open, .Bridge.Barriers.B8.Actuator.c_close, .Bridge.Barriers.B8.Actuator.c_emrgStop, .Bridge.Barriers.B8.Actuator.c_endStopOpening, .Bridge.Barriers.B8.Actuator.c_endStopClosing, .Bridge.Barriers.LightSignals.c_on, .Bridge.Barriers.LightSignals.c_off, .Bridge.Barriers.SoundSignals.c_on, .Bridge.Barriers.SoundSignals.c_off, .Bridge.Barriers.B3B6Closed1Timer.c_on, .Bridge.Barriers.B3B6Closed1Timer.c_reset, .Bridge.Barriers.B2B7Open1Timer.c_on, .Bridge.Barriers.B2B7Open1Timer.c_reset, .Bridge.Barriers.SoundOn6Timer.c_on, .Bridge.Barriers.SoundOn6Timer.c_reset, .Bridge.Deck.Actuator.c_open, .Bridge.Deck.Actuator.c_close, .Bridge.Deck.Actuator.c_emrgStop, .Bridge.Deck.Actuator.c_endStopOpening, .Bridge.Deck.Actuator.c_endStopClosing;
    location:
      initial;
      marked;
      edge .Bridge.Barriers.B1.Actuator.c_close when true;
      edge .Bridge.Barriers.B1.Actuator.c_emrgStop when true;
      edge .Bridge.Barriers.B1.Actuator.c_endStopClosing when true;
      edge .Bridge.Barriers.B1.Actuator.c_endStopOpening when true;
      edge .Bridge.Barriers.B1.Actuator.c_open when true;
      edge .Bridge.Barriers.B2.Actuator.c_close when true;
      edge .Bridge.Barriers.B2.Actuator.c_emrgStop when true;
      edge .Bridge.Barriers.B2.Actuator.c_endStopClosing when true;
      edge .Bridge.Barriers.B2.Actuator.c_endStopOpening when true;
      edge .Bridge.Barriers.B2.Actuator.c_open when true;
      edge .Bridge.Barriers.B2B7Open1Timer.c_on when true;
      edge .Bridge.Barriers.B2B7Open1Timer.c_reset when true;
      edge .Bridge.Barriers.B3.Actuator.c_close when true;
      edge .Bridge.Barriers.B3.Actuator.c_emrgStop when true;
      edge .Bridge.Barriers.B3.Actuator.c_endStopClosing when true;
      edge .Bridge.Barriers.B3.Actuator.c_endStopOpening when true;
      edge .Bridge.Barriers.B3.Actuator.c_open when true;
      edge .Bridge.Barriers.B3B6Closed1Timer.c_on when true;
      edge .Bridge.Barriers.B3B6Closed1Timer.c_reset when true;
      edge .Bridge.Barriers.B4.Actuator.c_close when true;
      edge .Bridge.Barriers.B4.Actuator.c_emrgStop when true;
      edge .Bridge.Barriers.B4.Actuator.c_endStopClosing when true;
      edge .Bridge.Barriers.B4.Actuator.c_endStopOpening when true;
      edge .Bridge.Barriers.B4.Actuator.c_open when true;
      edge .Bridge.Barriers.B5.Actuator.c_close when true;
      edge .Bridge.Barriers.B5.Actuator.c_emrgStop when true;
      edge .Bridge.Barriers.B5.Actuator.c_endStopClosing when true;
      edge .Bridge.Barriers.B5.Actuator.c_endStopOpening when true;
      edge .Bridge.Barriers.B5.Actuator.c_open when true;
      edge .Bridge.Barriers.B6.Actuator.c_close when true;
      edge .Bridge.Barriers.B6.Actuator.c_emrgStop when true;
      edge .Bridge.Barriers.B6.Actuator.c_endStopClosing when true;
      edge .Bridge.Barriers.B6.Actuator.c_endStopOpening when true;
      edge .Bridge.Barriers.B6.Actuator.c_open when true;
      edge .Bridge.Barriers.B7.Actuator.c_close when true;
      edge .Bridge.Barriers.B7.Actuator.c_emrgStop when true;
      edge .Bridge.Barriers.B7.Actuator.c_endStopClosing when true;
      edge .Bridge.Barriers.B7.Actuator.c_endStopOpening when true;
      edge .Bridge.Barriers.B7.Actuator.c_open when true;
      edge .Bridge.Barriers.B8.Actuator.c_close when true;
      edge .Bridge.Barriers.B8.Actuator.c_emrgStop when true;
      edge .Bridge.Barriers.B8.Actuator.c_endStopClosing when true;
      edge .Bridge.Barriers.B8.Actuator.c_endStopOpening when true;
      edge .Bridge.Barriers.B8.Actuator.c_open when true;
      edge .Bridge.Barriers.LightSignals.c_off when true;
      edge .Bridge.Barriers.LightSignals.c_on when true;
      edge .Bridge.Barriers.SoundOn6Timer.c_on when true;
      edge .Bridge.Barriers.SoundOn6Timer.c_reset when true;
      edge .Bridge.Barriers.SoundSignals.c_off when true;
      edge .Bridge.Barriers.SoundSignals.c_on when true;
      edge .Bridge.Deck.Actuator.c_close when true;
      edge .Bridge.Deck.Actuator.c_emrgStop when true;
      edge .Bridge.Deck.Actuator.c_endStopClosing when true;
      edge .Bridge.Deck.Actuator.c_endStopOpening when true;
      edge .Bridge.Deck.Actuator.c_open when true;
      edge .Bridge.LTAS.FarActuator.c_off when true;
      edge .Bridge.LTAS.FarActuator.c_on when true;
      edge .Bridge.LTAS.NearActuator.c_off when true;
      edge .Bridge.LTAS.NearActuator.c_on when true;
      edge .Bridge.LTAS.NearOff60Timer.c_on when true;
      edge .Bridge.LTAS.NearOff60Timer.c_reset when true;
      edge .Bridge.LTAS.On15Timer.c_on when true;
      edge .Bridge.LTAS.On15Timer.c_reset when true;
      edge .Bridge.LTAS.On20Timer.c_on when true;
      edge .Bridge.LTAS.On20Timer.c_reset when true;
      edge .Bridge.LTSS.MainLaneActuator.c_off when true;
      edge .Bridge.LTSS.MainLaneActuator.c_on when true;
      edge .Bridge.LTSS.Off60Timer.c_on when true;
      edge .Bridge.LTSS.Off60Timer.c_reset when true;
      edge .Bridge.LTSS.On15Timer.c_on when true;
      edge .Bridge.LTSS.On15Timer.c_reset when true;
      edge .Bridge.LTSS.SwitchLaneActuator.c_off when true;
      edge .Bridge.LTSS.SwitchLaneActuator.c_on when true;
      edge .Lock.BTL.DE.Actuator.c_emerg when true;
      edge .Lock.BTL.DE.Actuator.c_g when true;
      edge .Lock.BTL.DE.Actuator.c_r when true;
      edge .Lock.BTL.DE.Actuator.c_rg when true;
      edge .Lock.BTL.DW.Actuator.c_emerg when true;
      edge .Lock.BTL.DW.Actuator.c_g when true;
      edge .Lock.BTL.DW.Actuator.c_r when true;
      edge .Lock.BTL.DW.Actuator.c_rg when true;
      edge .Lock.DownstreamEbb.EastGate.Actuator.c_close when true;
      edge .Lock.DownstreamEbb.EastGate.Actuator.c_emrgStop when true;
      edge .Lock.DownstreamEbb.EastGate.Actuator.c_endStopClosing when true;
      edge .Lock.DownstreamEbb.EastGate.Actuator.c_endStopOpening when true;
      edge .Lock.DownstreamEbb.EastGate.Actuator.c_open when Lock.DownstreamEbb.EastPaddle.Actuator.Rest and Lock.DownstreamEbb.EastPaddle.Sensor.Open;
      edge .Lock.DownstreamEbb.EastPaddle.Actuator.c_close when not Lock.DownstreamEbb.EastPaddle.Sensor.Intermediate and (Lock.DownstreamEbb.EastGate.Actuator.Rest and Lock.DownstreamEbb.EastGate.Sensor.Closed) or Lock.DownstreamEbb.EastPaddle.Sensor.Intermediate;
      edge .Lock.DownstreamEbb.EastPaddle.Actuator.c_emrgStop when true;
      edge .Lock.DownstreamEbb.EastPaddle.Actuator.c_endStopClosing when true;
      edge .Lock.DownstreamEbb.EastPaddle.Actuator.c_endStopOpening when true;
      edge .Lock.DownstreamEbb.EastPaddle.Actuator.c_open when true;
      edge .Lock.DownstreamEbb.WestGate.Actuator.c_close when true;
      edge .Lock.DownstreamEbb.WestGate.Actuator.c_emrgStop when true;
      edge .Lock.DownstreamEbb.WestGate.Actuator.c_endStopClosing when true;
      edge .Lock.DownstreamEbb.WestGate.Actuator.c_endStopOpening when true;
      edge .Lock.DownstreamEbb.WestGate.Actuator.c_open when Lock.DownstreamEbb.WestPaddle.Actuator.Rest and Lock.DownstreamEbb.WestPaddle.Sensor.Open;
      edge .Lock.DownstreamEbb.WestPaddle.Actuator.c_close when not Lock.DownstreamEbb.WestPaddle.Sensor.Intermediate and (Lock.DownstreamEbb.WestGate.Sensor.Closed and Lock.DownstreamEbb.WestGate.Actuator.Rest) or Lock.DownstreamEbb.WestPaddle.Sensor.Intermediate;
      edge .Lock.DownstreamEbb.WestPaddle.Actuator.c_emrgStop when true;
      edge .Lock.DownstreamEbb.WestPaddle.Actuator.c_endStopClosing when true;
      edge .Lock.DownstreamEbb.WestPaddle.Actuator.c_endStopOpening when true;
      edge .Lock.DownstreamEbb.WestPaddle.Actuator.c_open when true;
      edge .Lock.DownstreamFlood.EastGate.Actuator.c_close when true;
      edge .Lock.DownstreamFlood.EastGate.Actuator.c_emrgStop when true;
      edge .Lock.DownstreamFlood.EastGate.Actuator.c_endStopClosing when true;
      edge .Lock.DownstreamFlood.EastGate.Actuator.c_endStopOpening when true;
      edge .Lock.DownstreamFlood.EastGate.Actuator.c_open when Lock.DownstreamFlood.EastPaddle.Sensor.Open and Lock.DownstreamFlood.EastPaddle.Actuator.Rest;
      edge .Lock.DownstreamFlood.EastPaddle.Actuator.c_close when not Lock.DownstreamFlood.EastPaddle.Sensor.Intermediate and (Lock.DownstreamFlood.EastGate.Actuator.Rest and Lock.DownstreamFlood.EastGate.Sensor.Closed) or Lock.DownstreamFlood.EastPaddle.Sensor.Intermediate;
      edge .Lock.DownstreamFlood.EastPaddle.Actuator.c_emrgStop when true;
      edge .Lock.DownstreamFlood.EastPaddle.Actuator.c_endStopClosing when true;
      edge .Lock.DownstreamFlood.EastPaddle.Actuator.c_endStopOpening when true;
      edge .Lock.DownstreamFlood.EastPaddle.Actuator.c_open when true;
      edge .Lock.DownstreamFlood.WestGate.Actuator.c_close when true;
      edge .Lock.DownstreamFlood.WestGate.Actuator.c_emrgStop when true;
      edge .Lock.DownstreamFlood.WestGate.Actuator.c_endStopClosing when true;
      edge .Lock.DownstreamFlood.WestGate.Actuator.c_endStopOpening when true;
      edge .Lock.DownstreamFlood.WestGate.Actuator.c_open when Lock.DownstreamFlood.WestPaddle.Actuator.Rest and Lock.DownstreamFlood.WestPaddle.Sensor.Open;
      edge .Lock.DownstreamFlood.WestPaddle.Actuator.c_close when not Lock.DownstreamFlood.WestPaddle.Sensor.Intermediate and (Lock.DownstreamFlood.WestGate.Actuator.Rest and Lock.DownstreamFlood.WestGate.Sensor.Closed) or Lock.DownstreamFlood.WestPaddle.Sensor.Intermediate;
      edge .Lock.DownstreamFlood.WestPaddle.Actuator.c_emrgStop when true;
      edge .Lock.DownstreamFlood.WestPaddle.Actuator.c_endStopClosing when true;
      edge .Lock.DownstreamFlood.WestPaddle.Actuator.c_endStopOpening when true;
      edge .Lock.DownstreamFlood.WestPaddle.Actuator.c_open when true;
      edge .Lock.DownstreamStormFlood.EastGate.Actuator.c_close when true;
      edge .Lock.DownstreamStormFlood.EastGate.Actuator.c_emrgStop when true;
      edge .Lock.DownstreamStormFlood.EastGate.Actuator.c_endStopClosing when true;
      edge .Lock.DownstreamStormFlood.EastGate.Actuator.c_endStopOpening when true;
      edge .Lock.DownstreamStormFlood.EastGate.Actuator.c_open when Lock.DownstreamStormFlood.EastPaddle.Sensor.Open and Lock.DownstreamStormFlood.EastPaddle.Actuator.Rest;
      edge .Lock.DownstreamStormFlood.EastPaddle.Actuator.c_close when Lock.DownstreamStormFlood.EastGate.Actuator.Rest and Lock.DownstreamStormFlood.EastGate.Sensor.Closed;
      edge .Lock.DownstreamStormFlood.EastPaddle.Actuator.c_emrgStop when true;
      edge .Lock.DownstreamStormFlood.EastPaddle.Actuator.c_endStopClosing when true;
      edge .Lock.DownstreamStormFlood.EastPaddle.Actuator.c_endStopOpening when true;
      edge .Lock.DownstreamStormFlood.EastPaddle.Actuator.c_open when true;
      edge .Lock.DownstreamStormFlood.WestGate.Actuator.c_close when true;
      edge .Lock.DownstreamStormFlood.WestGate.Actuator.c_emrgStop when true;
      edge .Lock.DownstreamStormFlood.WestGate.Actuator.c_endStopClosing when true;
      edge .Lock.DownstreamStormFlood.WestGate.Actuator.c_endStopOpening when true;
      edge .Lock.DownstreamStormFlood.WestGate.Actuator.c_open when Lock.DownstreamStormFlood.WestPaddle.Sensor.Open and Lock.DownstreamStormFlood.WestPaddle.Actuator.Rest;
      edge .Lock.DownstreamStormFlood.WestPaddle.Actuator.c_close when Lock.DownstreamStormFlood.WestGate.Sensor.Closed and Lock.DownstreamStormFlood.WestGate.Actuator.Rest;
      edge .Lock.DownstreamStormFlood.WestPaddle.Actuator.c_emrgStop when true;
      edge .Lock.DownstreamStormFlood.WestPaddle.Actuator.c_endStopClosing when true;
      edge .Lock.DownstreamStormFlood.WestPaddle.Actuator.c_endStopOpening when true;
      edge .Lock.DownstreamStormFlood.WestPaddle.Actuator.c_open when true;
      edge .Lock.LTL.DE.Actuator.c_emerg when true;
      edge .Lock.LTL.DE.Actuator.c_g when true;
      edge .Lock.LTL.DE.Actuator.c_r when true;
      edge .Lock.LTL.DE.Actuator.c_rg when true;
      edge .Lock.LTL.DE.Actuator.c_rr when true;
      edge .Lock.LTL.DW.Actuator.c_emerg when true;
      edge .Lock.LTL.DW.Actuator.c_g when true;
      edge .Lock.LTL.DW.Actuator.c_r when true;
      edge .Lock.LTL.DW.Actuator.c_rg when true;
      edge .Lock.LTL.DW.Actuator.c_rr when true;
      edge .Lock.LTL.UE.Actuator.c_emerg when true;
      edge .Lock.LTL.UE.Actuator.c_g when true;
      edge .Lock.LTL.UE.Actuator.c_r when true;
      edge .Lock.LTL.UE.Actuator.c_rg when true;
      edge .Lock.LTL.UE.Actuator.c_rr when true;
      edge .Lock.LTL.UW.Actuator.c_emerg when true;
      edge .Lock.LTL.UW.Actuator.c_g when true;
      edge .Lock.LTL.UW.Actuator.c_r when true;
      edge .Lock.LTL.UW.Actuator.c_rg when true;
      edge .Lock.LTL.UW.Actuator.c_rr when true;
      edge .Lock.UpstreamEbb.EastGate.Actuator.c_close when true;
      edge .Lock.UpstreamEbb.EastGate.Actuator.c_emrgStop when true;
      edge .Lock.UpstreamEbb.EastGate.Actuator.c_endStopClosing when true;
      edge .Lock.UpstreamEbb.EastGate.Actuator.c_endStopOpening when true;
      edge .Lock.UpstreamEbb.EastGate.Actuator.c_open when Lock.UpstreamEbb.EastPaddle.Sensor.Open and Lock.UpstreamEbb.EastPaddle.Actuator.Rest;
      edge .Lock.UpstreamEbb.EastPaddle.Actuator.c_close when Lock.UpstreamEbb.EastGate.Actuator.Rest and Lock.UpstreamEbb.EastGate.Sensor.Closed;
      edge .Lock.UpstreamEbb.EastPaddle.Actuator.c_emrgStop when true;
      edge .Lock.UpstreamEbb.EastPaddle.Actuator.c_endStopClosing when true;
      edge .Lock.UpstreamEbb.EastPaddle.Actuator.c_endStopOpening when true;
      edge .Lock.UpstreamEbb.EastPaddle.Actuator.c_open when true;
      edge .Lock.UpstreamEbb.WestGate.Actuator.c_close when true;
      edge .Lock.UpstreamEbb.WestGate.Actuator.c_emrgStop when true;
      edge .Lock.UpstreamEbb.WestGate.Actuator.c_endStopClosing when true;
      edge .Lock.UpstreamEbb.WestGate.Actuator.c_endStopOpening when true;
      edge .Lock.UpstreamEbb.WestGate.Actuator.c_open when Lock.UpstreamEbb.WestPaddle.Sensor.Open and Lock.UpstreamEbb.WestPaddle.Actuator.Rest;
      edge .Lock.UpstreamEbb.WestPaddle.Actuator.c_close when Lock.UpstreamEbb.WestGate.Sensor.Closed and Lock.UpstreamEbb.WestGate.Actuator.Rest;
      edge .Lock.UpstreamEbb.WestPaddle.Actuator.c_emrgStop when true;
      edge .Lock.UpstreamEbb.WestPaddle.Actuator.c_endStopClosing when true;
      edge .Lock.UpstreamEbb.WestPaddle.Actuator.c_endStopOpening when true;
      edge .Lock.UpstreamEbb.WestPaddle.Actuator.c_open when true;
      edge .Lock.UpstreamFlood.EastGate.Actuator.c_close when true;
      edge .Lock.UpstreamFlood.EastGate.Actuator.c_emrgStop when true;
      edge .Lock.UpstreamFlood.EastGate.Actuator.c_endStopClosing when true;
      edge .Lock.UpstreamFlood.EastGate.Actuator.c_endStopOpening when true;
      edge .Lock.UpstreamFlood.EastGate.Actuator.c_open when Lock.UpstreamFlood.EastPaddle.Sensor.Open and Lock.UpstreamFlood.EastPaddle.Actuator.Rest;
      edge .Lock.UpstreamFlood.EastPaddle.Actuator.c_close when Lock.UpstreamFlood.EastGate.Sensor.Closed and Lock.UpstreamFlood.EastGate.Actuator.Rest;
      edge .Lock.UpstreamFlood.EastPaddle.Actuator.c_emrgStop when true;
      edge .Lock.UpstreamFlood.EastPaddle.Actuator.c_endStopClosing when true;
      edge .Lock.UpstreamFlood.EastPaddle.Actuator.c_endStopOpening when true;
      edge .Lock.UpstreamFlood.EastPaddle.Actuator.c_open when true;
      edge .Lock.UpstreamFlood.WestGate.Actuator.c_close when true;
      edge .Lock.UpstreamFlood.WestGate.Actuator.c_emrgStop when true;
      edge .Lock.UpstreamFlood.WestGate.Actuator.c_endStopClosing when true;
      edge .Lock.UpstreamFlood.WestGate.Actuator.c_endStopOpening when true;
      edge .Lock.UpstreamFlood.WestGate.Actuator.c_open when Lock.UpstreamFlood.WestPaddle.Actuator.Rest and Lock.UpstreamFlood.WestPaddle.Sensor.Open;
      edge .Lock.UpstreamFlood.WestPaddle.Actuator.c_close when Lock.UpstreamFlood.WestGate.Actuator.Rest and Lock.UpstreamFlood.WestGate.Sensor.Closed;
      edge .Lock.UpstreamFlood.WestPaddle.Actuator.c_emrgStop when true;
      edge .Lock.UpstreamFlood.WestPaddle.Actuator.c_endStopClosing when true;
      edge .Lock.UpstreamFlood.WestPaddle.Actuator.c_endStopOpening when true;
      edge .Lock.UpstreamFlood.WestPaddle.Actuator.c_open when true;
  end
end
group GateUpstreamEbbEast:
  alg string ID = "UpstreamEbbEast";
  alg bool SensorPaddleClosed = Lock.UpstreamEbb.EastPaddle.Sensor.Closed;
  alg int x = 633;
  alg int y = 413;
  alg int OpenDegree = 77;
  alg real a = Lock.UpstreamEbb.EastGate.a;
  svgout id "Gate" + ID attr "transform" value fmt("rotate(%s, %s, %s)", scale(a, 0, 3, 0.01, OpenDegree), x, y) file "../Image.svg";
  svgout id "Paddle" + ID attr "fill" value if SensorPaddleClosed: "grey" else "lightblue" end file "../Image.svg";
end
group GateUpstreamEbbWest:
  alg string ID = "UpstreamEbbWest";
  alg bool SensorPaddleClosed = Lock.UpstreamEbb.WestPaddle.Sensor.Closed;
  alg int x = 560;
  alg int y = 413;
  alg int OpenDegree = -77;
  alg real a = Lock.UpstreamEbb.WestGate.a;
  svgout id "Gate" + ID attr "transform" value fmt("rotate(%s, %s, %s)", scale(a, 0, 3, 0.01, OpenDegree), x, y) file "../Image.svg";
  svgout id "Paddle" + ID attr "fill" value if SensorPaddleClosed: "grey" else "lightblue" end file "../Image.svg";
end
group GateUpstreamFloodEast:
  alg string ID = "UpstreamFloodEast";
  alg bool SensorPaddleClosed = Lock.UpstreamFlood.EastPaddle.Sensor.Closed;
  alg int x = 633;
  alg int y = 445;
  alg int OpenDegree = -77;
  alg real a = Lock.UpstreamFlood.EastGate.a;
  svgout id "Gate" + ID attr "transform" value fmt("rotate(%s, %s, %s)", scale(a, 0, 3, 0.01, OpenDegree), x, y) file "../Image.svg";
  svgout id "Paddle" + ID attr "fill" value if SensorPaddleClosed: "grey" else "lightblue" end file "../Image.svg";
end
group GateUpstreamFloodWest:
  alg string ID = "UpstreamFloodWest";
  alg bool SensorPaddleClosed = Lock.UpstreamFlood.WestPaddle.Sensor.Closed;
  alg int x = 560;
  alg int y = 445;
  alg int OpenDegree = 77;
  alg real a = Lock.UpstreamFlood.WestGate.a;
  svgout id "Gate" + ID attr "transform" value fmt("rotate(%s, %s, %s)", scale(a, 0, 3, 0.01, OpenDegree), x, y) file "../Image.svg";
  svgout id "Paddle" + ID attr "fill" value if SensorPaddleClosed: "grey" else "lightblue" end file "../Image.svg";
end
group GateDownstreamEbbEast:
  alg string ID = "DownstreamEbbEast";
  alg bool SensorPaddleClosed = Lock.DownstreamEbb.EastPaddle.Sensor.Closed;
  alg int x = 633;
  alg int y = 811;
  alg int OpenDegree = 77;
  alg real a = Lock.DownstreamEbb.EastGate.a;
  svgout id "Gate" + ID attr "transform" value fmt("rotate(%s, %s, %s)", scale(a, 0, 3, 0.01, OpenDegree), x, y) file "../Image.svg";
  svgout id "Paddle" + ID attr "fill" value if SensorPaddleClosed: "grey" else "lightblue" end file "../Image.svg";
end
group GateDownstreamEbbWest:
  alg string ID = "DownstreamEbbWest";
  alg bool SensorPaddleClosed = Lock.DownstreamEbb.WestPaddle.Sensor.Closed;
  alg int x = 560;
  alg int y = 811;
  alg int OpenDegree = -77;
  alg real a = Lock.DownstreamEbb.WestGate.a;
  svgout id "Gate" + ID attr "transform" value fmt("rotate(%s, %s, %s)", scale(a, 0, 3, 0.01, OpenDegree), x, y) file "../Image.svg";
  svgout id "Paddle" + ID attr "fill" value if SensorPaddleClosed: "grey" else "lightblue" end file "../Image.svg";
end
group GateDownstreamFloodEast:
  alg string ID = "DownstreamFloodEast";
  alg bool SensorPaddleClosed = Lock.DownstreamFlood.EastPaddle.Sensor.Closed;
  alg int x = 633;
  alg int y = 838;
  alg int OpenDegree = -77;
  alg real a = Lock.DownstreamFlood.EastGate.a;
  svgout id "Gate" + ID attr "transform" value fmt("rotate(%s, %s, %s)", scale(a, 0, 3, 0.01, OpenDegree), x, y) file "../Image.svg";
  svgout id "Paddle" + ID attr "fill" value if SensorPaddleClosed: "grey" else "lightblue" end file "../Image.svg";
end
group GateDownstreamFloodWest:
  alg string ID = "DownstreamFloodWest";
  alg bool SensorPaddleClosed = Lock.DownstreamFlood.WestPaddle.Sensor.Closed;
  alg int x = 560;
  alg int y = 838;
  alg int OpenDegree = 77;
  alg real a = Lock.DownstreamFlood.WestGate.a;
  svgout id "Gate" + ID attr "transform" value fmt("rotate(%s, %s, %s)", scale(a, 0, 3, 0.01, OpenDegree), x, y) file "../Image.svg";
  svgout id "Paddle" + ID attr "fill" value if SensorPaddleClosed: "grey" else "lightblue" end file "../Image.svg";
end
group GateDownstreamStormFloodEast:
  alg string ID = "DownstreamStormFloodEast";
  alg bool SensorPaddleClosed = Lock.DownstreamStormFlood.EastPaddle.Sensor.Closed;
  alg int x = 633;
  alg int y = 900;
  alg int OpenDegree = -77;
  alg real a = Lock.DownstreamStormFlood.EastGate.a;
  svgout id "Gate" + ID attr "transform" value fmt("rotate(%s, %s, %s)", scale(a, 0, 3, 0.01, OpenDegree), x, y) file "../Image.svg";
  svgout id "Paddle" + ID attr "fill" value if SensorPaddleClosed: "grey" else "lightblue" end file "../Image.svg";
end
group GateDownstreamStormFloodWest:
  alg string ID = "DownstreamStormFloodWest";
  alg bool SensorPaddleClosed = Lock.DownstreamStormFlood.WestPaddle.Sensor.Closed;
  alg int x = 560;
  alg int y = 900;
  alg int OpenDegree = 77;
  alg real a = Lock.DownstreamStormFlood.WestGate.a;
  svgout id "Gate" + ID attr "transform" value fmt("rotate(%s, %s, %s)", scale(a, 0, 3, 0.01, OpenDegree), x, y) file "../Image.svg";
  svgout id "Paddle" + ID attr "fill" value if SensorPaddleClosed: "grey" else "lightblue" end file "../Image.svg";
end
group LTLUpstreamEast:
  alg string ID = "LTLUpstreamEast";
  svgout id ID + "Rgr" attr "fill" value if Lock.LTL.UE.Red1On: "red" else "grey" end file "../Image.svg";
  svgout id ID + "rGr" attr "fill" value if Lock.LTL.UE.GreenOn: "green" else "grey" end file "../Image.svg";
  svgout id ID + "rgR" attr "fill" value if Lock.LTL.UE.Red2On: "red" else "grey" end file "../Image.svg";
end
group LTLUpstreamWest:
  alg string ID = "LTLUpstreamWest";
  svgout id ID + "Rgr" attr "fill" value if Lock.LTL.UW.Red1On: "red" else "grey" end file "../Image.svg";
  svgout id ID + "rGr" attr "fill" value if Lock.LTL.UW.GreenOn: "green" else "grey" end file "../Image.svg";
  svgout id ID + "rgR" attr "fill" value if Lock.LTL.UW.Red2On: "red" else "grey" end file "../Image.svg";
end
group LTLDownstreamEast:
  alg string ID = "LTLDownstreamEast";
  svgout id ID + "Rgr" attr "fill" value if Lock.LTL.DE.Red1On: "red" else "grey" end file "../Image.svg";
  svgout id ID + "rGr" attr "fill" value if Lock.LTL.DE.GreenOn: "green" else "grey" end file "../Image.svg";
  svgout id ID + "rgR" attr "fill" value if Lock.LTL.DE.Red2On: "red" else "grey" end file "../Image.svg";
end
group LTLDownstreamWest:
  alg string ID = "LTLDownstreamWest";
  svgout id ID + "Rgr" attr "fill" value if Lock.LTL.DW.Red1On: "red" else "grey" end file "../Image.svg";
  svgout id ID + "rGr" attr "fill" value if Lock.LTL.DW.GreenOn: "green" else "grey" end file "../Image.svg";
  svgout id ID + "rgR" attr "fill" value if Lock.LTL.DW.Red2On: "red" else "grey" end file "../Image.svg";
end
group BTLDownstreamEast:
  alg string ID = "BTLDownstreamEast";
  svgout id ID + "r" attr "fill" value if Lock.BTL.DE.RedOn: "red" else "grey" end file "../Image.svg";
  svgout id ID + "g" attr "fill" value if Lock.BTL.DE.GreenOn: "green" else "grey" end file "../Image.svg";
end
group BTLDownstreamWest:
  alg string ID = "BTLDownstreamWest";
  svgout id ID + "r" attr "fill" value if Lock.BTL.DW.RedOn: "red" else "grey" end file "../Image.svg";
  svgout id ID + "g" attr "fill" value if Lock.BTL.DW.GreenOn: "green" else "grey" end file "../Image.svg";
end
group Command223224:
  alg int ID = 22;
  svgin id "Button" + <string>ID event if not Lock.UI.UEbbGate.Close: Lock.UI.UEbbGate.u_close else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 1) event if not Lock.UI.UEbbGate.Open: Lock.UI.UEbbGate.u_open else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 2) event if not Lock.UI.UEbbGate.Stop: Lock.UI.UEbbGate.u_stop else No.Event end file "../Image.svg";
  svgout id "Button" + <string>ID attr "fill" value if Lock.UI.UEbbGate.Close: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 1) attr "fill" value if Lock.UI.UEbbGate.Open: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 2) attr "fill" value if Lock.UI.UEbbGate.Stop: "yellowgreen" else "indianred" end file "../Image.svg";
end
group Command252627:
  alg int ID = 25;
  svgin id "Button" + <string>ID event if not Lock.UI.UFloodGate.Close: Lock.UI.UFloodGate.u_close else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 1) event if not Lock.UI.UFloodGate.Open: Lock.UI.UFloodGate.u_open else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 2) event if not Lock.UI.UFloodGate.Stop: Lock.UI.UFloodGate.u_stop else No.Event end file "../Image.svg";
  svgout id "Button" + <string>ID attr "fill" value if Lock.UI.UFloodGate.Close: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 1) attr "fill" value if Lock.UI.UFloodGate.Open: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 2) attr "fill" value if Lock.UI.UFloodGate.Stop: "yellowgreen" else "indianred" end file "../Image.svg";
end
group Command282930:
  alg int ID = 28;
  svgin id "Button" + <string>ID event if not Lock.UI.DEbbGate.Close: Lock.UI.DEbbGate.u_close else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 1) event if not Lock.UI.DEbbGate.Open: Lock.UI.DEbbGate.u_open else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 2) event if not Lock.UI.DEbbGate.Stop: Lock.UI.DEbbGate.u_stop else No.Event end file "../Image.svg";
  svgout id "Button" + <string>ID attr "fill" value if Lock.UI.DEbbGate.Close: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 1) attr "fill" value if Lock.UI.DEbbGate.Open: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 2) attr "fill" value if Lock.UI.DEbbGate.Stop: "yellowgreen" else "indianred" end file "../Image.svg";
end
group Command313233:
  alg int ID = 31;
  svgin id "Button" + <string>ID event if not Lock.UI.DFloodGate.Close: Lock.UI.DFloodGate.u_close else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 1) event if not Lock.UI.DFloodGate.Open: Lock.UI.DFloodGate.u_open else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 2) event if not Lock.UI.DFloodGate.Stop: Lock.UI.DFloodGate.u_stop else No.Event end file "../Image.svg";
  svgout id "Button" + <string>ID attr "fill" value if Lock.UI.DFloodGate.Close: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 1) attr "fill" value if Lock.UI.DFloodGate.Open: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 2) attr "fill" value if Lock.UI.DFloodGate.Stop: "yellowgreen" else "indianred" end file "../Image.svg";
end
group Command343536:
  alg int ID = 34;
  svgin id "Button" + <string>ID event if not Lock.UI.DStormFloodGate.Close: Lock.UI.DStormFloodGate.u_close else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 1) event if not Lock.UI.DStormFloodGate.Open: Lock.UI.DStormFloodGate.u_open else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 2) event if not Lock.UI.DStormFloodGate.Stop: Lock.UI.DStormFloodGate.u_stop else No.Event end file "../Image.svg";
  svgout id "Button" + <string>ID attr "fill" value if Lock.UI.DStormFloodGate.Close: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 1) attr "fill" value if Lock.UI.DStormFloodGate.Open: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 2) attr "fill" value if Lock.UI.DStormFloodGate.Stop: "yellowgreen" else "indianred" end file "../Image.svg";
end
group Command373839:
  alg int ID = 37;
  svgin id "Button" + <string>ID event if not Lock.UI.UEbbPaddle.Close: Lock.UI.UEbbPaddle.u_close else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 1) event if not Lock.UI.UEbbPaddle.Open: Lock.UI.UEbbPaddle.u_open else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 2) event if not Lock.UI.UEbbPaddle.Stop: Lock.UI.UEbbPaddle.u_stop else No.Event end file "../Image.svg";
  svgout id "Button" + <string>ID attr "fill" value if Lock.UI.UEbbPaddle.Close: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 1) attr "fill" value if Lock.UI.UEbbPaddle.Open: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 2) attr "fill" value if Lock.UI.UEbbPaddle.Stop: "yellowgreen" else "indianred" end file "../Image.svg";
end
group Command404142:
  alg int ID = 40;
  svgin id "Button" + <string>ID event if not Lock.UI.UFloodPaddle.Close: Lock.UI.UFloodPaddle.u_close else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 1) event if not Lock.UI.UFloodPaddle.Open: Lock.UI.UFloodPaddle.u_open else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 2) event if not Lock.UI.UFloodPaddle.Stop: Lock.UI.UFloodPaddle.u_stop else No.Event end file "../Image.svg";
  svgout id "Button" + <string>ID attr "fill" value if Lock.UI.UFloodPaddle.Close: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 1) attr "fill" value if Lock.UI.UFloodPaddle.Open: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 2) attr "fill" value if Lock.UI.UFloodPaddle.Stop: "yellowgreen" else "indianred" end file "../Image.svg";
end
group Command434445:
  alg int ID = 43;
  svgin id "Button" + <string>ID event if not Lock.UI.DEbbPaddle.Close: Lock.UI.DEbbPaddle.u_close else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 1) event if not Lock.UI.DEbbPaddle.Open: Lock.UI.DEbbPaddle.u_open else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 2) event if not Lock.UI.DEbbPaddle.Stop: Lock.UI.DEbbPaddle.u_stop else No.Event end file "../Image.svg";
  svgout id "Button" + <string>ID attr "fill" value if Lock.UI.DEbbPaddle.Close: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 1) attr "fill" value if Lock.UI.DEbbPaddle.Open: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 2) attr "fill" value if Lock.UI.DEbbPaddle.Stop: "yellowgreen" else "indianred" end file "../Image.svg";
end
group Command464748:
  alg int ID = 46;
  svgin id "Button" + <string>ID event if not Lock.UI.DFloodPaddle.Close: Lock.UI.DFloodPaddle.u_close else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 1) event if not Lock.UI.DFloodPaddle.Open: Lock.UI.DFloodPaddle.u_open else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 2) event if not Lock.UI.DFloodPaddle.Stop: Lock.UI.DFloodPaddle.u_stop else No.Event end file "../Image.svg";
  svgout id "Button" + <string>ID attr "fill" value if Lock.UI.DFloodPaddle.Close: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 1) attr "fill" value if Lock.UI.DFloodPaddle.Open: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 2) attr "fill" value if Lock.UI.DFloodPaddle.Stop: "yellowgreen" else "indianred" end file "../Image.svg";
end
group Command495051:
  alg int ID = 49;
  svgin id "Button" + <string>ID event if not Lock.UI.DStormFloodPaddle.Close: Lock.UI.DStormFloodPaddle.u_close else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 1) event if not Lock.UI.DStormFloodPaddle.Open: Lock.UI.DStormFloodPaddle.u_open else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 2) event if not Lock.UI.DStormFloodPaddle.Stop: Lock.UI.DStormFloodPaddle.u_stop else No.Event end file "../Image.svg";
  svgout id "Button" + <string>ID attr "fill" value if Lock.UI.DStormFloodPaddle.Close: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 1) attr "fill" value if Lock.UI.DStormFloodPaddle.Open: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 2) attr "fill" value if Lock.UI.DStormFloodPaddle.Stop: "yellowgreen" else "indianred" end file "../Image.svg";
end
group Command52535455:
  alg int ID = 52;
  svgin id "Button" + <string>ID event if not Lock.UI.ULockTrafficLight.Red: Lock.UI.ULockTrafficLight.u_r else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 1) event if Lock.UI.ULockTrafficLight.RedGreen: Lock.UI.ULockTrafficLight.u_g else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 2) event if Lock.UI.ULockTrafficLight.Red: Lock.UI.ULockTrafficLight.u_rg else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 3) event if Lock.UI.ULockTrafficLight.Red: Lock.UI.ULockTrafficLight.u_rr else No.Event end file "../Image.svg";
  svgout id "Button" + <string>ID attr "fill" value if Lock.UI.ULockTrafficLight.Red: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 1) attr "fill" value if Lock.UI.ULockTrafficLight.Green: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 2) attr "fill" value if Lock.UI.ULockTrafficLight.RedGreen: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 3) attr "fill" value if Lock.UI.ULockTrafficLight.RedRed: "yellowgreen" else "indianred" end file "../Image.svg";
end
group Command56575859:
  alg int ID = 56;
  svgin id "Button" + <string>ID event if not Lock.UI.DLockTrafficLight.Red: Lock.UI.DLockTrafficLight.u_r else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 1) event if Lock.UI.DLockTrafficLight.RedGreen: Lock.UI.DLockTrafficLight.u_g else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 2) event if Lock.UI.DLockTrafficLight.Red: Lock.UI.DLockTrafficLight.u_rg else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 3) event if Lock.UI.DLockTrafficLight.Red: Lock.UI.DLockTrafficLight.u_rr else No.Event end file "../Image.svg";
  svgout id "Button" + <string>ID attr "fill" value if Lock.UI.DLockTrafficLight.Red: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 1) attr "fill" value if Lock.UI.DLockTrafficLight.Green: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 2) attr "fill" value if Lock.UI.DLockTrafficLight.RedGreen: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 3) attr "fill" value if Lock.UI.DLockTrafficLight.RedRed: "yellowgreen" else "indianred" end file "../Image.svg";
end
group Command202122:
  alg int ID = 20;
  svgin id "Button" + <string>ID event if not Lock.UI.DBridgeTraffigLight.Red: Lock.UI.DBridgeTraffigLight.u_r else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 1) event if Lock.UI.DBridgeTraffigLight.RedGreen: Lock.UI.DBridgeTraffigLight.u_g else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 1) + "b" event if Lock.UI.DBridgeTraffigLight.Red: Lock.UI.DBridgeTraffigLight.u_rg else No.Event end file "../Image.svg";
  svgout id "Button" + <string>ID attr "fill" value if Lock.UI.DBridgeTraffigLight.Red: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 1) attr "fill" value if Lock.UI.DBridgeTraffigLight.Green: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 1) + "b" attr "fill" value if Lock.UI.DBridgeTraffigLight.RedGreen: "yellowgreen" else "indianred" end file "../Image.svg";
end
group EmergencyStopV:
  svgin id "EmergencyLockA" event if Lock.EmergencyStop.Deactivated: Lock.EmergencyStop.u_activate else No.Event end file "../Image.svg";
  svgout id "EmergencyLockA" attr "fill" value if Lock.EmergencyStop.Activated: "yellowgreen" else "indianred" end file "../Image.svg";
  svgin id "EmergencyLockD" event if Lock.EmergencyStop.Activated: Lock.EmergencyStop.u_reset else No.Event end file "../Image.svg";
  svgout id "EmergencyLockD" attr "fill" value if Lock.EmergencyStop.Activated: "indianred" else "yellowgreen" end file "../Image.svg";
  svgin id "EmergencyBridgeA" event if Bridge.EmergencyStop.Deactivated: Bridge.EmergencyStop.u_activate else No.Event end file "../Image.svg";
  svgout id "EmergencyBridgeA" attr "fill" value if Bridge.EmergencyStop.Activated: "yellowgreen" else "indianred" end file "../Image.svg";
  svgin id "EmergencyBridgeD" event if Bridge.EmergencyStop.Activated: Bridge.EmergencyStop.u_reset else No.Event end file "../Image.svg";
  svgout id "EmergencyBridgeD" attr "fill" value if Bridge.EmergencyStop.Activated: "indianred" else "yellowgreen" end file "../Image.svg";
end
automaton X:
  location:
    initial;
    edge No.Event;
end
group No:
  event Event;
end
group ApproachSign1:
  alg int ID = 1;
  alg bool SensorOn = Bridge.LTAS.ApproachSign1.Sensor.On;
  svgout id "ApproachSign" + <string>ID attr "fill" value if SensorOn: "orange" else "grey" end file "../Image.svg";
end
group ApproachSign2:
  alg int ID = 2;
  alg bool SensorOn = Bridge.LTAS.ApproachSign2.Sensor.On;
  svgout id "ApproachSign" + <string>ID attr "fill" value if SensorOn: "orange" else "grey" end file "../Image.svg";
end
group ApproachSign3:
  alg int ID = 3;
  alg bool SensorOn = Bridge.LTAS.ApproachSign3.Sensor.On;
  svgout id "ApproachSign" + <string>ID attr "fill" value if SensorOn: "orange" else "grey" end file "../Image.svg";
end
group ApproachSign4:
  alg int ID = 4;
  alg bool SensorOn = Bridge.LTAS.ApproachSign4.Sensor.On;
  svgout id "ApproachSign" + <string>ID attr "fill" value if SensorOn: "orange" else "grey" end file "../Image.svg";
end
group ApproachSign5:
  alg int ID = 5;
  alg bool SensorOn = Bridge.LTAS.ApproachSign5.Sensor.On;
  svgout id "ApproachSign" + <string>ID attr "fill" value if SensorOn: "orange" else "grey" end file "../Image.svg";
end
group StopSign1:
  alg int ID = 1;
  alg bool SensorOn = Bridge.LTSS.StopSign1.Sensor.On;
  svgout id "StopSign" + <string>ID attr "fill" value if SensorOn: "red" else "grey" end file "../Image.svg";
end
group StopSign2:
  alg int ID = 2;
  alg bool SensorOn = Bridge.LTSS.StopSign2.Sensor.On;
  svgout id "StopSign" + <string>ID attr "fill" value if SensorOn: "red" else "grey" end file "../Image.svg";
end
group StopSign3:
  alg int ID = 3;
  alg bool SensorOn = Bridge.LTSS.StopSign3.Sensor.On;
  svgout id "StopSign" + <string>ID attr "fill" value if SensorOn: "red" else "grey" end file "../Image.svg";
end
group StopSign4:
  alg int ID = 4;
  alg bool SensorOn = Bridge.LTSS.StopSign4.Sensor.On;
  svgout id "StopSign" + <string>ID attr "fill" value if SensorOn: "red" else "grey" end file "../Image.svg";
end
group StopSign5:
  alg int ID = 5;
  alg bool SensorOn = Bridge.LTSS.StopSign5.Sensor.On;
  svgout id "StopSign" + <string>ID attr "fill" value if SensorOn: "red" else "grey" end file "../Image.svg";
end
group StopSign6:
  alg int ID = 6;
  alg bool SensorOn = Bridge.LTSS.StopSign6.Sensor.On;
  svgout id "StopSign" + <string>ID attr "fill" value if SensorOn: "red" else "grey" end file "../Image.svg";
end
group StopSign7:
  alg int ID = 7;
  alg bool SensorOn = Bridge.LTSS.StopSign7.Sensor.On;
  svgout id "StopSign" + <string>ID attr "fill" value if SensorOn: "red" else "grey" end file "../Image.svg";
end
group StopSign8:
  alg int ID = 8;
  alg bool SensorOn = Bridge.LTSS.StopSign8.Sensor.On;
  svgout id "StopSign" + <string>ID attr "fill" value if SensorOn: "red" else "grey" end file "../Image.svg";
end
group StopSign9:
  alg int ID = 9;
  alg bool SensorOn = Bridge.LTSS.StopSign9.Sensor.On;
  svgout id "StopSign" + <string>ID attr "fill" value if SensorOn: "red" else "grey" end file "../Image.svg";
end
group StopSign10:
  alg int ID = 10;
  alg bool SensorOn = Bridge.LTSS.StopSign10.Sensor.On;
  svgout id "StopSign" + <string>ID attr "fill" value if SensorOn: "red" else "grey" end file "../Image.svg";
end
group StopSign11:
  alg int ID = 11;
  alg bool SensorOn = Bridge.LTSS.StopSign11.Sensor.On;
  svgout id "StopSign" + <string>ID attr "fill" value if SensorOn: "red" else "grey" end file "../Image.svg";
end
group StopSign12:
  alg int ID = 12;
  alg bool SensorOn = Bridge.LTSS.StopSign12.Sensor.On;
  svgout id "StopSign" + <string>ID attr "fill" value if SensorOn: "red" else "grey" end file "../Image.svg";
end
group Barrier1:
  alg int ID = 1;
  alg bool SensorClosed = Bridge.Barriers.B1.Sensor.Closed;
  alg real a = Bridge.Barriers.B1.a;
  svgout id "Barrier" + <string>ID attr "fill-opacity" value if SensorClosed: 100 else 0 end file "../Image.svg";
  svgout id "Barrier" + <string>ID attr "stroke-opacity" value if SensorClosed: 100 else 0 end file "../Image.svg";
  svgout id "prog_B" + <string>ID attr "width" value scale(a, 3, 0, 0.01, 100) file "../Image.svg";
end
group Barrier2:
  alg int ID = 2;
  alg bool SensorClosed = Bridge.Barriers.B2.Sensor.Closed;
  alg real a = Bridge.Barriers.B2.a;
  svgout id "Barrier" + <string>ID attr "fill-opacity" value if SensorClosed: 100 else 0 end file "../Image.svg";
  svgout id "Barrier" + <string>ID attr "stroke-opacity" value if SensorClosed: 100 else 0 end file "../Image.svg";
  svgout id "prog_B" + <string>ID attr "width" value scale(a, 3, 0, 0.01, 100) file "../Image.svg";
end
group Barrier3:
  alg int ID = 3;
  alg bool SensorClosed = Bridge.Barriers.B3.Sensor.Closed;
  alg real a = Bridge.Barriers.B3.a;
  svgout id "Barrier" + <string>ID attr "fill-opacity" value if SensorClosed: 100 else 0 end file "../Image.svg";
  svgout id "Barrier" + <string>ID attr "stroke-opacity" value if SensorClosed: 100 else 0 end file "../Image.svg";
  svgout id "prog_B" + <string>ID attr "width" value scale(a, 3, 0, 0.01, 100) file "../Image.svg";
end
group Barrier4:
  alg int ID = 4;
  alg bool SensorClosed = Bridge.Barriers.B4.Sensor.Closed;
  alg real a = Bridge.Barriers.B4.a;
  svgout id "Barrier" + <string>ID attr "fill-opacity" value if SensorClosed: 100 else 0 end file "../Image.svg";
  svgout id "Barrier" + <string>ID attr "stroke-opacity" value if SensorClosed: 100 else 0 end file "../Image.svg";
  svgout id "prog_B" + <string>ID attr "width" value scale(a, 3, 0, 0.01, 100) file "../Image.svg";
end
group Barrier5:
  alg int ID = 5;
  alg bool SensorClosed = Bridge.Barriers.B5.Sensor.Closed;
  alg real a = Bridge.Barriers.B5.a;
  svgout id "Barrier" + <string>ID attr "fill-opacity" value if SensorClosed: 100 else 0 end file "../Image.svg";
  svgout id "Barrier" + <string>ID attr "stroke-opacity" value if SensorClosed: 100 else 0 end file "../Image.svg";
  svgout id "prog_B" + <string>ID attr "width" value scale(a, 3, 0, 0.01, 100) file "../Image.svg";
end
group Barrier6:
  alg int ID = 6;
  alg bool SensorClosed = Bridge.Barriers.B6.Sensor.Closed;
  alg real a = Bridge.Barriers.B6.a;
  svgout id "Barrier" + <string>ID attr "fill-opacity" value if SensorClosed: 100 else 0 end file "../Image.svg";
  svgout id "Barrier" + <string>ID attr "stroke-opacity" value if SensorClosed: 100 else 0 end file "../Image.svg";
  svgout id "prog_B" + <string>ID attr "width" value scale(a, 3, 0, 0.01, 100) file "../Image.svg";
end
group Barrier7:
  alg int ID = 7;
  alg bool SensorClosed = Bridge.Barriers.B7.Sensor.Closed;
  alg real a = Bridge.Barriers.B7.a;
  svgout id "Barrier" + <string>ID attr "fill-opacity" value if SensorClosed: 100 else 0 end file "../Image.svg";
  svgout id "Barrier" + <string>ID attr "stroke-opacity" value if SensorClosed: 100 else 0 end file "../Image.svg";
  svgout id "prog_B" + <string>ID attr "width" value scale(a, 3, 0, 0.01, 100) file "../Image.svg";
end
group Barrier8:
  alg int ID = 8;
  alg bool SensorClosed = Bridge.Barriers.B8.Sensor.Closed;
  alg real a = Bridge.Barriers.B8.a;
  svgout id "Barrier" + <string>ID attr "fill-opacity" value if SensorClosed: 100 else 0 end file "../Image.svg";
  svgout id "Barrier" + <string>ID attr "stroke-opacity" value if SensorClosed: 100 else 0 end file "../Image.svg";
  svgout id "prog_B" + <string>ID attr "width" value scale(a, 3, 0, 0.01, 100) file "../Image.svg";
end
group Command234:
  alg int ID = 2;
  svgin id "Button" + <string>ID event if not Bridge.UI.Barrier36.Close: Bridge.UI.Barrier36.u_close else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 1) event if not Bridge.UI.Barrier36.Open: Bridge.UI.Barrier36.u_open else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 2) event if not Bridge.UI.Barrier36.Stop: Bridge.UI.Barrier36.u_stop else No.Event end file "../Image.svg";
  svgout id "Button" + <string>ID attr "fill" value if Bridge.UI.Barrier36.Close: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 1) attr "fill" value if Bridge.UI.Barrier36.Open: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 2) attr "fill" value if Bridge.UI.Barrier36.Stop: "yellowgreen" else "indianred" end file "../Image.svg";
end
group Command567:
  alg int ID = 5;
  svgin id "Button" + <string>ID event if not Bridge.UI.Barrier27.Close: Bridge.UI.Barrier27.u_close else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 1) event if not Bridge.UI.Barrier27.Open: Bridge.UI.Barrier27.u_open else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 2) event if not Bridge.UI.Barrier27.Stop: Bridge.UI.Barrier27.u_stop else No.Event end file "../Image.svg";
  svgout id "Button" + <string>ID attr "fill" value if Bridge.UI.Barrier27.Close: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 1) attr "fill" value if Bridge.UI.Barrier27.Open: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 2) attr "fill" value if Bridge.UI.Barrier27.Stop: "yellowgreen" else "indianred" end file "../Image.svg";
end
group Command8910:
  alg int ID = 8;
  svgin id "Button" + <string>ID event if not Bridge.UI.Barrier1.Close: Bridge.UI.Barrier1.u_close else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 1) event if not Bridge.UI.Barrier1.Open: Bridge.UI.Barrier1.u_open else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 2) event if not Bridge.UI.Barrier1.Stop: Bridge.UI.Barrier1.u_stop else No.Event end file "../Image.svg";
  svgout id "Button" + <string>ID attr "fill" value if Bridge.UI.Barrier1.Close: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 1) attr "fill" value if Bridge.UI.Barrier1.Open: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 2) attr "fill" value if Bridge.UI.Barrier1.Stop: "yellowgreen" else "indianred" end file "../Image.svg";
end
group Command111213:
  alg int ID = 11;
  svgin id "Button" + <string>ID event if not Bridge.UI.Barrier5.Close: Bridge.UI.Barrier5.u_close else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 1) event if not Bridge.UI.Barrier5.Open: Bridge.UI.Barrier5.u_open else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 2) event if not Bridge.UI.Barrier5.Stop: Bridge.UI.Barrier5.u_stop else No.Event end file "../Image.svg";
  svgout id "Button" + <string>ID attr "fill" value if Bridge.UI.Barrier5.Close: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 1) attr "fill" value if Bridge.UI.Barrier5.Open: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 2) attr "fill" value if Bridge.UI.Barrier5.Stop: "yellowgreen" else "indianred" end file "../Image.svg";
end
group Command141516:
  alg int ID = 14;
  svgin id "Button" + <string>ID event if not Bridge.UI.Barrier48.Close: Bridge.UI.Barrier48.u_close else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 1) event if not Bridge.UI.Barrier48.Open: Bridge.UI.Barrier48.u_open else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 2) event if not Bridge.UI.Barrier48.Stop: Bridge.UI.Barrier48.u_stop else No.Event end file "../Image.svg";
  svgout id "Button" + <string>ID attr "fill" value if Bridge.UI.Barrier48.Close: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 1) attr "fill" value if Bridge.UI.Barrier48.Open: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 2) attr "fill" value if Bridge.UI.Barrier48.Stop: "yellowgreen" else "indianred" end file "../Image.svg";
end
group Command171819:
  alg int ID = 17;
  svgin id "Button" + <string>ID event if not Bridge.UI.Deck.Close: Bridge.UI.Deck.u_close else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 1) event if not Bridge.UI.Deck.Open: Bridge.UI.Deck.u_open else No.Event end file "../Image.svg";
  svgin id "Button" + <string>(ID + 2) event if not Bridge.UI.Deck.Stop: Bridge.UI.Deck.u_stop else No.Event end file "../Image.svg";
  svgout id "Button" + <string>ID attr "fill" value if Bridge.UI.Deck.Close: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 1) attr "fill" value if Bridge.UI.Deck.Open: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button" + <string>(ID + 2) attr "fill" value if Bridge.UI.Deck.Stop: "yellowgreen" else "indianred" end file "../Image.svg";
end
group LTCommandV:
  svgin id "Button1a" event if not Bridge.UI.LT.Activated: Bridge.UI.LT.u_activate else No.Event end file "../Image.svg";
  svgin id "Button1b" event if not Bridge.UI.LT.Stopped: Bridge.UI.LT.u_stop else No.Event end file "../Image.svg";
  svgin id "Button1c" event if not Bridge.UI.LT.Deactivated: Bridge.UI.LT.u_deactivate else No.Event end file "../Image.svg";
  svgout id "Button1a" attr "fill" value if Bridge.UI.LT.Activated: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button1b" attr "fill" value if Bridge.UI.LT.Stopped: "yellowgreen" else "indianred" end file "../Image.svg";
  svgout id "Button1c" attr "fill" value if Bridge.UI.LT.Deactivated: "yellowgreen" else "indianred" end file "../Image.svg";
end
group CloseRequestV:
  svgin id "RequestClose" event if Bridge.CloseRequest.Off: Bridge.CloseRequest.u_on else Bridge.CloseRequest.u_off end file "../Image.svg";
  svgout id "RequestClose" attr "fill" value if Bridge.CloseRequest.On: "yellowgreen" else "indianred" end file "../Image.svg";
end
automaton Y:
  location:
    initial;
    edge No.Event;
end
svgout id "water_chamber" attr "fill" value if Lock.Water.h >= 10: "#000080" elif Lock.Water.h <= 2.0: "#9ecaff" else "#0000ff" end file "../Image.svg";
svgout id "prog_Deck" attr "width" value scale(Bridge.Deck.a, 0, 3, 0.01, 100) file "../Image.svg";
svgout id "Deck" attr "visibility" value if Bridge.Deck.Sensor.Open: "hidden" else "visible" end file "../Image.svg";
svgout id "SoundSignal" attr "visibility" value if Bridge.Barriers.SoundSignals.On: "visible" else "hidden" end file "../Image.svg";
